-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Heterogeneous, type-safe automatic backpropagation in Haskell
--   
--   See <a>README.md</a>
--   
--   At the moment, this project is in pre-alpha, and is published and put
--   up on Hackage with 100% documentation coverage as a call for comments
--   and thoughts. See <a>TODO</a> section in the README for more
--   information on what's missing and potential avenues for contribution.
@package backprop
@version 0.0.3.0


-- | A poor substitute for the <a>Control.Lens.Iso</a> module in
--   <i>lens</i>, providing the <a>Iso</a> type synonym and some sample
--   useful <a>Iso</a>s for usage with <i>backprop</i>, without incuring a
--   lens dependency.
--   
--   If you also import lens, you should only use this module for the
--   <a>Iso</a>s it exports, and not import the redefined <a>Iso</a> type
--   synonym or <a>from</a> / <a>iso</a> / <a>review</a>.
module Numeric.Backprop.Iso

-- | A family of isomorphisms. See <a>Iso'</a>.
type Iso s t a b = forall p f. (Profunctor p, Functor f) => p a (f b) -> p s (f t)

-- | An <tt><a>Iso'</a> s a</tt> encodes an isomorphism between an
--   <tt>s</tt> and an <tt>a</tt>. It basically lets you go from <tt>s
--   -&gt; a</tt> and back (from <tt>a -&gt; s</tt>) while preserving
--   structure. You can basically imagine an <tt><a>Iso'</a> s a</tt> to be
--   an <tt>(s -&gt; a, a -&gt; s)</tt> tuple.
--   
--   You can get the "forward" direction of an <a>Iso'</a> with
--   <a>view</a>:
--   
--   <pre>
--   <a>view</a> :: Iso'' s a -&gt; (s -&gt; a)
--   </pre>
--   
--   And the "backwards" direction with <a>review</a>:
--   
--   <pre>
--   <a>review</a> :: Iso'' s a -&gt; (a -&gt; s)
--   </pre>
--   
--   You can construct an <a>Iso'</a> using <a>iso</a>, giving the forward
--   and backwards functions:
--   
--   <pre>
--   &gt;&gt;&gt; myIso :: Iso' (Identity a) a
--       myIso = iso runIdentity Identity
--   
--   &gt;&gt;&gt; view myIso (Identity "hello")
--   "hello"
--   
--   &gt;&gt;&gt; review myIso "hello"
--   Identity "hello"
--   </pre>
--   
--   One powerful thing about <a>Iso'</a>s is that they're
--   <i>composable</i> using <a>.</a>:
--   
--   <pre>
--   (<a>.</a>) :: <a>Iso'</a> c b -&gt; <a>Iso'</a> b a -&gt; <a>Iso'</a> c a
--   </pre>
--   
--   This is basically provided here so that this package doesn't incurr a
--   <i>lens</i> dependecy, but if you already depend on <i>lens</i>, you
--   should use the version from <a>Control.Lens.Iso</a> instead.
type Iso' s a = Iso s s a a

-- | Construct an <a>Iso</a> by giving the "forward" and "backward"
--   direction functions:
--   
--   <pre>
--   &gt;&gt;&gt; myIso :: Iso' (Identity a) a
--       myIso = iso runIdentity Identity
--   
--   &gt;&gt;&gt; view myIso (Identity "hello")
--   "hello"
--   
--   &gt;&gt;&gt; review myIso "hello"
--   Identity "hello"
--   </pre>
--   
--   This is basically provided here so that this package doesn't incurr a
--   <i>lens</i> dependecy, but if you already depend on <i>lens</i>, you
--   should use the version from <a>Control.Lens.Iso</a> instead.
iso :: (s -> a) -> (b -> t) -> Iso s t a b

-- | Reverse an <a>Iso'</a>. The forward function becomes the backwards
--   function, and the backwards function becomes the forward function.
--   
--   This is basically provided here so that this package doesn't incurr a
--   <i>lens</i> dependecy, but if you already depend on <i>lens</i>, you
--   should use the version from <a>Control.Lens.Review</a> instead.
from :: Iso' s a -> Iso' a s

-- | Get the "reverse" direction function from an <a>Iso</a>.
--   
--   This is basically provided here so that this package doesn't incurr a
--   <i>lens</i> dependecy, but if you already depend on <i>lens</i>, you
--   should use the version from <a>Control.Lens.Review</a> instead.
review :: Iso s t a b -> b -> t

-- | <a>view</a> is a synonym for (<a>^.</a>):
--   
--   <pre>
--   &gt;&gt;&gt; view _1 (1, 2)
--   1
--   </pre>
--   
--   The reason it's not in <a>Lens.Micro</a> is that <tt>view</tt> in lens
--   has a more general signature:
--   
--   <pre>
--   view :: MonadReader s m =&gt; Getting a s a -&gt; m a
--   </pre>
--   
--   So, you would be able to use this <a>view</a> with functions, but not
--   in various reader monads. For most people this shouldn't be an issue;
--   if it is for you, use <tt>view</tt> from <a>microlens-mtl</a>.
view :: () => Getting a s a -> s -> a

-- | A useful <a>Iso</a> between two types with the same runtime
--   representation.
coerced :: Coercible s a => Iso' s a
tup1 :: forall a. Iso' a (Tuple '[a])
tup2 :: forall a b. Iso' (a, b) (Tuple '[a, b])
tup3 :: forall a b c. Iso' (a, b, c) (Tuple '[a, b, c])

-- | An <a>Iso</a> between a type that is a product type, and a tuple that
--   contains all of its components. Uses <a>Generics.SOP</a> and the
--   <a>Generic</a> typeclass.
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Generics.SOP as SOP
--   
--   &gt;&gt;&gt; data Foo = A Int Bool      deriving Generic
--   
--   &gt;&gt;&gt; instance SOP.Generic Foo
--   
--   &gt;&gt;&gt; view gTuple (A 10 True)
--   10 ::&lt; True ::&lt; Ø
--   
--   &gt;&gt;&gt; review gTuple (15 ::&lt; False ::&lt; Ø)
--   A 15 False
--   </pre>
gTuple :: (Generic a, Code a ~ '[as]) => Iso' a (Tuple as)

-- | An <a>Iso</a> between a sum type whose constructors are products, and
--   a sum (<a>Sum</a>) of products (<a>Tuple</a>). Uses
--   <a>Generics.SOP</a> and the <a>Generic</a> typeclass.
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Generics.SOP as SOP
--   
--   &gt;&gt;&gt; data Bar = A Int Bool | B String Double
--   
--   &gt;&gt;&gt; instance SOP.Generic Bar
--   
--   &gt;&gt;&gt; 'view' 'gSOP' (A 10 True)
--   'InL' (10 ::&lt; True ::&lt; Ø)
--   
--   &gt;&gt;&gt; 'view' 'gSOP' (B "hello" 3.4)
--   'InR' ('InL' ("hello" ::&lt; 3.4 ::&lt; Ø))
--   
--   &gt;&gt;&gt; 'review' 'gTuple' ('InL' (15 ::&lt; False ::&lt; Ø))
--   A 15 False
--   
--   &gt;&gt;&gt; 'review' 'gTuple' ('InR' ('InL' ("bye" ::&lt; 9.8 ::&lt; Ø)))
--   B "bye" 9.8
--   </pre>
gSOP :: Generic a => Iso' a (Sum Tuple (Code a))

-- | An iso between a single-type <a>Sum</a> and the single type.
sum1 :: Iso' (Sum f '[a]) (f a)

-- | An iso between a single type and a single-type <a>Sum</a>.
resum1 :: Iso' (f a) (Sum f '[a])
data Prod k (f :: k -> *) (a :: [k]) :: forall k. () => (k -> *) -> [k] -> *
[Ø] :: Prod k f [] k
[:<] :: Prod k f (:) k a1 as

-- | A Prod of simple Haskell types.
type Tuple = Prod * I
data Sum k (f :: k -> *) (a :: [k]) :: forall k. () => (k -> *) -> [k] -> *
[InL] :: Sum k f (:) k a1 as
[InR] :: Sum k f (:) k a1 as
newtype I a :: * -> *
I :: a -> I a
[getI] :: I a -> a


-- | Provides the <a>Op</a> (and <tt>OpM</tt>) type and combinators, which
--   represent differentiable functions/operations on values, and are used
--   by the library to perform back-propagation.
--   
--   Note that <a>Op</a> is a <i>subset</i> or <i>subtype</i> of
--   <tt>OpM</tt>, and so, any function that expects an <tt><tt>OpM</tt> m
--   as a</tt> (or an <tt><a>OpB</a> s as a</tt>) can be given an
--   <tt><a>Op</a> as a</tt> and it'll work just fine.
module Numeric.Backprop.Op

-- | An <tt><tt>OpM</tt> m as a</tt> represents a <i>differentiable</i>
--   (monadic) function from <tt>as</tt> to <tt>a</tt>, in the context of a
--   <a>Monad</a> <tt>m</tt>.
--   
--   For example, an
--   
--   <pre>
--   <tt>OpM</tt> IO '[Int, Bool] Double
--   </pre>
--   
--   would be a function that takes an <a>Int</a> and a <a>Bool</a> and
--   returns a <a>Double</a> (in <a>IO</a>). It can be differentiated to
--   give a <i>gradient</i> of an <a>Int</a> and a <a>Bool</a> (also in
--   <a>IO</a>) if given the total derivative for the <tt>Double</tt>.
--   
--   Note that an <tt>OpM</tt> is a <i>superclass</i> of <a>Op</a>, so any
--   function that expects an <tt><tt>OpM</tt> m as a</tt> can also accept
--   an <tt><a>Op</a> as a</tt>.
--   
--   See <tt>runOpM</tt>, <tt>gradOpM</tt>, and <tt>gradOpWithM</tt> for
--   examples on how to run it.
newtype Op as a

-- | Construct an <tt>OpM</tt> by giving a (monadic) function creating the
--   result, and also a continuation on how to create the gradient, given
--   the total derivative of <tt>a</tt>.
--   
--   See the module documentation for <a>Numeric.Backprop.Op</a> for more
--   details on the function that this constructor and <a>Op</a> expect.
Op :: (Tuple as -> (a, a -> Tuple as)) -> Op as a
[runOpWith] :: Op as a -> Tuple as -> (a, a -> Tuple as)
data Prod k (f :: k -> *) (a :: [k]) :: forall k. () => (k -> *) -> [k] -> *
[Ø] :: Prod k f [] k
[:<] :: Prod k f (:) k a1 as

-- | A Prod of simple Haskell types.
type Tuple = Prod * I
newtype I a :: * -> *
I :: a -> I a
[getI] :: I a -> a

-- | Run the function that an <a>Op</a> encodes, to get the resulting
--   output and also its gradient with respect to the inputs.
--   
--   <pre>
--   &gt;&gt;&gt; gradOp' (op2 (*)) (3 ::&lt; 5 ::&lt; Ø)
--   (15, 5 ::&lt; 3 ::&lt; Ø)
--   </pre>
runOp :: Num a => Op as a -> Tuple as -> (a, Tuple as)

-- | Run the function that an <a>Op</a> encodes, to get the result.
--   
--   <pre>
--   &gt;&gt;&gt; runOp (op2 (*)) (3 ::&lt; 5 ::&lt; Ø)
--   15
--   </pre>
evalOp :: Op as a -> Tuple as -> a

-- | Run the function that an <a>Op</a> encodes, and get the gradient of
--   the output with respect to the inputs.
--   
--   <pre>
--   &gt;&gt;&gt; gradOp (op2 (*)) (3 ::&lt; 5 ::&lt; Ø)
--   5 ::&lt; 3 ::&lt; Ø
--   -- the gradient of x*y is (y, x)
--   </pre>
gradOp :: Num a => Op as a -> Tuple as -> Tuple as

-- | A combination of <a>gradOp</a> and <a>gradOpWith</a>. The third
--   argument is (optionally) the total derivative the result. Give
--   <a>Nothing</a> and it is assumed that the result is the final result
--   (and the total derivative is 1), and this behaves the same as
--   <a>gradOp</a>. Give <tt><a>Just</a> d</tt> and it uses the <tt>d</tt>
--   as the total derivative of the result, and this behaves like
--   <a>gradOpWith</a>.
--   
--   See <a>gradOp</a> and the module documentaiton for
--   <a>Numeric.Backprop.Op</a> for more information.
gradOpWith :: Op as a -> Tuple as -> a -> Tuple as

-- | Compose <tt>OpM</tt>s together, similar to <a>.</a>. But, because all
--   <tt>OpM</tt>s are &lt;math&gt;, this is more like <a>sequence</a> for
--   functions, or <tt>liftAN</tt>.
--   
--   That is, given an <tt><tt>OpM</tt> m as b1</tt>, an <tt><tt>OpM</tt> m
--   as b2</tt>, and an <tt><tt>OpM</tt> m as b3</tt>, it can compose them
--   with an <tt><tt>OpM</tt> m '[b1,b2,b3] c</tt> to create an
--   <tt><tt>OpM</tt> m as c</tt>.
composeOp :: (Every Num as, Known Length as) => Prod (Op as) bs -> Op bs c -> Op as c

-- | Convenient wrapper over <a>composeOp</a> for the case where the second
--   function only takes one input, so the two <tt>OpM</tt>s can be
--   directly piped together, like for <a>.</a>.
composeOp1 :: (Every Num as, Known Length as) => Op as b -> Op '[b] c -> Op as c

-- | Convenient infix synonym for (flipped) <a>composeOp1</a>. Meant to be
--   used just like <a>.</a>:
--   
--   <pre>
--   <a>op1</a> negate            :: <a>Op</a> '[a]   a
--   <a>op2</a> (+)               :: Op '[a,a] a
--   
--   op1 negate <a>~.</a> op2 (+) :: Op '[a, a] a
--   </pre>
(~.) :: (Known Length as, Every Num as) => Op '[b] c -> Op as b -> Op as c
infixr 9 ~.

-- | A combination of <a>runOp</a> and <tt>gradOpWith'</tt>. Given an
--   <a>Op</a> and inputs, returns the result of the <a>Op</a> and a
--   continuation that gives its gradient.
--   
--   The continuation takes the total derivative of the result as input.
--   See documenation for <tt>gradOpWith'</tt> and module documentation for
--   <a>Numeric.Backprop.Op</a> for more information. runOp' :: Op as a --
--   ^ <a>Op</a> to run -&gt; Tuple as -- ^ Inputs -&gt; (a, a -&gt; Tuple
--   as) -- ^ Result, and continuation to get -- the gradient -- runOp' o =
--   (second . fmap) getI . getI . runOp' o runOp' (Op f) = f
--   
--   A version of <a>composeOp</a> taking explicit <a>Length</a>,
--   indicating the number of inputs expected and their types.
--   
--   Requiring an explicit <a>Length</a> is mostly useful for rare
--   "extremely polymorphic" situations, where GHC can't infer the type and
--   length of the the expected input tuple. If you ever actually
--   explicitly write down <tt>as</tt> as a list of types, you should be
--   able to just use <a>composeOp</a>.
composeOp' :: forall as bs c. Every Num as => Length as -> Prod (Op as) bs -> Op bs c -> Op as c

-- | A version of <a>composeOp1</a> taking explicit <a>Length</a>,
--   indicating the number of inputs expected and their types.
--   
--   Requiring an explicit <a>Length</a> is mostly useful for rare
--   "extremely polymorphic" situations, where GHC can't infer the type and
--   length of the the expected input tuple. If you ever actually
--   explicitly write down <tt>as</tt> as a list of types, you should be
--   able to just use <a>composeOp1</a>.
composeOp1' :: Every Num as => Length as -> Op as b -> Op '[b] c -> Op as c

-- | Create an <a>Op</a> that takes no inputs and always returns the given
--   value.
--   
--   There is no gradient, of course (using <a>gradOp</a> will give you an
--   empty tuple), because there is no input to have a gradient of.
--   
--   <pre>
--   &gt;&gt;&gt; gradOp' (op0 10) Ø
--   (10, Ø)
--   </pre>
--   
--   For a constant <a>Op</a> that takes input and ignores it, see
--   <a>opConst</a> and <a>opConst'</a>.
--   
--   Note that because this returns an <a>Op</a>, it can be used with any
--   function that expects an <tt>OpM</tt> or <a>OpB</a>, as well.
op0 :: a -> Op '[] a

-- | An <a>Op</a> that ignores all of its inputs and returns a given
--   constant value.
--   
--   <pre>
--   &gt;&gt;&gt; gradOp' (opConst 10) (1 ::&lt; 2 ::&lt; 3 ::&lt; Ø)
--   (10, 0 ::&lt; 0 ::&lt; 0 ::&lt; Ø)
--   </pre>
opConst :: forall as a. (Every Num as, Known Length as) => a -> Op as a

-- | An <a>Op</a> that just returns whatever it receives. The identity
--   function.
--   
--   <pre>
--   <a>idOp</a> = <a>opIso</a> <a>id</a>
--   </pre>
idOp :: Num a => Op '[a] a

-- | A version of <a>opConst</a> taking explicit <a>Length</a>, indicating
--   the number of inputs and their types.
--   
--   Requiring an explicit <a>Length</a> is mostly useful for rare
--   "extremely polymorphic" situations, where GHC can't infer the type and
--   length of the the expected input tuple. If you ever actually
--   explicitly write down <tt>as</tt> as a list of types, you should be
--   able to just use <a>opConst</a>.
opConst' :: forall as a. Every Num as => Length as -> a -> Op as a

-- | Create an <a>Op</a> of a function taking one input, by giving its
--   explicit derivative. The function should return a tuple containing the
--   result of the function, and also a function taking the derivative of
--   the result and return the derivative of the input.
--   
--   If we have
--   
--   &lt;math&gt;
--   
--   Then the derivative &lt;math&gt;, it would be:
--   
--   &lt;math&gt;
--   
--   If our <a>Op</a> represents &lt;math&gt;, then the second item in the
--   resulting tuple should be a function that takes &lt;math&gt; and
--   returns &lt;math&gt;.
--   
--   If the input is <a>Nothing</a>, then &lt;math&gt; should be taken to
--   be &lt;math&gt;.
--   
--   As an example, here is an <a>Op</a> that squares its input:
--   
--   <pre>
--   square :: Num a =&gt; <a>Op</a> '[a] a
--   square = <a>op1'</a> $ \x -&gt; (x*x, \case Nothing -&gt; 2 * x
--                                     Just d  -&gt; 2 * d * x
--                         )
--   </pre>
--   
--   Remember that, generally, end users shouldn't directly construct
--   <a>Op</a>s; they should be provided by libraries or generated
--   automatically.
--   
--   For numeric functions, single-input <a>Op</a>s can be generated
--   automatically using <a>op1</a>.
op1 :: (a -> (b, b -> a)) -> Op '[a] b

-- | Create an <a>Op</a> of a function taking two inputs, by giving its
--   explicit gradient. The function should return a tuple containing the
--   result of the function, and also a function taking the derivative of
--   the result and return the derivative of the input.
--   
--   If we have
--   
--   &lt;math&gt;
--   
--   Then the gradient &lt;math&gt; would be:
--   
--   &lt;math&gt;
--   
--   If our <a>Op</a> represents &lt;math&gt;, then the second item in the
--   resulting tuple should be a function that takes &lt;math&gt; and
--   returns &lt;math&gt;.
--   
--   If the input is <a>Nothing</a>, then &lt;math&gt; should be taken to
--   be &lt;math&gt;.
--   
--   As an example, here is an <a>Op</a> that multiplies its inputs:
--   
--   <pre>
--   mul :: Num a =&gt; <a>Op</a> '[a, a] a
--   mul = <a>op2'</a> $ \x y -&gt; (x*y, \case Nothing -&gt; (y  , x  )
--                                    Just d  -&gt; (d*y, x*d)
--                        )
--   </pre>
--   
--   Remember that, generally, end users shouldn't directly construct
--   <a>Op</a>s; they should be provided by libraries or generated
--   automatically.
--   
--   For numeric functions, two-input <a>Op</a>s can be generated
--   automatically using <a>op2</a>.
op2 :: (a -> b -> (c, c -> (a, b))) -> Op '[a, b] c

-- | Create an <a>Op</a> of a function taking three inputs, by giving its
--   explicit gradient. See documentation for <a>op2'</a> for more details.
op3 :: (a -> b -> c -> (d, d -> (a, b, c))) -> Op '[a, b, c] d

-- | Automatically create an <a>Op</a> of a numerical function taking one
--   argument. Uses <a>diff</a>, and so can take any numerical function
--   polymorphic over the standard numeric types.
--   
--   <pre>
--   &gt;&gt;&gt; gradOp' (op1 (recip . negate)) (5 ::&lt; Ø)
--   (-0.2, 0.04 ::&lt; Ø)
--   </pre>
op1' :: Num a => (forall s. AD s (Forward a) -> AD s (Forward a)) -> Op '[a] a

-- | Automatically create an <a>Op</a> of a numerical function taking two
--   arguments. Uses <a>grad</a>, and so can take any numerical function
--   polymorphic over the standard numeric types.
--   
--   <pre>
--   &gt;&gt;&gt; gradOp' (op2 (\x y -&gt; x * sqrt y)) (3 ::&lt; 4 ::&lt; Ø)
--   (6.0, 2.0 ::&lt; 0.75 ::&lt; Ø)
--   </pre>
op2' :: Num a => (forall s. Reifies s Tape => Reverse s a -> Reverse s a -> Reverse s a) -> Op '[a, a] a

-- | Automatically create an <a>Op</a> of a numerical function taking three
--   arguments. Uses <a>grad</a>, and so can take any numerical function
--   polymorphic over the standard numeric types.
--   
--   <pre>
--   &gt;&gt;&gt; gradOp' (op3 (\x y z -&gt; (x * sqrt y)**z)) (3 ::&lt; 4 ::&lt; 2 ::&lt; Ø)
--   (36.0, 24.0 ::&lt; 9.0 ::&lt; 64.503 ::&lt; Ø)
--   </pre>
op3' :: Num a => (forall s. Reifies s Tape => Reverse s a -> Reverse s a -> Reverse s a -> Reverse s a) -> Op '[a, a, a] a

-- | Automatically create an <a>Op</a> of a numerical function taking
--   multiple arguments. Uses <a>grad</a>, and so can take any numerical
--   function polymorphic over the standard numeric types.
--   
--   <pre>
--   &gt;&gt;&gt; gradOp' (opN (\(x :+ y :+ Ø) -&gt; x * sqrt y)) (3 ::&lt; 4 ::&lt; Ø)
--   (6.0, 2.0 ::&lt; 0.75 ::&lt; Ø)
--   </pre>
opN' :: (Num a, Known Nat n) => (forall s. Reifies s Tape => Vec n (Reverse s a) -> Reverse s a) -> Op (Replicate n a) a

-- | <tt><a>Replicate</a> n a</tt> is a list of <tt>a</tt>s repeated
--   <tt>n</tt> times.
--   
--   <pre>
--   &gt;&gt;&gt; :kind! Replicate N3 Int
--   '[Int, Int, Int]
--   
--   &gt;&gt;&gt; :kind! Replicate N5 Double
--   '[Double, Double, Double, Double, Double]
--   </pre>

-- | An <a>Op</a> that coerces an item into another item whose type has the
--   same runtime representation. Requires the input to be an instance of
--   <a>Num</a>.
--   
--   <pre>
--   &gt;&gt;&gt; gradOp' opCoerce (Identity 5) :: (Int, Identity Int)
--   (5, Identity 1)
--   </pre>
--   
--   <pre>
--   <a>opCoerce</a> = <a>opIso</a> <a>coerced</a>
--   </pre>
opCoerce :: Num a => Coercible a b => Op '[a] b

-- | An <a>Op</a> that takes <tt>as</tt> and returns exactly the input
--   tuple.
--   
--   <pre>
--   &gt;&gt;&gt; gradOp' opTup (1 ::&lt; 2 ::&lt; 3 ::&lt; Ø)
--   (1 ::&lt; 2 ::&lt; 3 ::&lt; Ø, 1 ::&lt; 1 ::&lt; 1 ::&lt; Ø)
--   </pre>
opTup :: (Every Num as, Known Length as) => Op as (Tuple as)

-- | An <a>Op</a> that runs the input value through the isomorphism encoded
--   in the <a>Iso</a>. Requires the input to be an instance of <a>Num</a>.
--   
--   Warning: This is unsafe! It assumes that the isomorphisms themselves
--   have derivative 1, so will break for things like
--   <a>exponentiating</a>. Basically, don't use this for any "numeric"
--   isomorphisms.
opIso :: Iso' a b -> Op '[a] b
opLens :: Num a => Lens' a b -> Op '[a] b

-- | Construct a two element Prod. Since the precedence of (:&gt;) is
--   higher than (:&lt;), we can conveniently write lists like:
--   
--   <pre>
--   &gt;&gt;&gt; a :&lt; b :&gt; c
--   </pre>
--   
--   Which is identical to:
--   
--   <pre>
--   &gt;&gt;&gt; a :&lt; b :&lt; c :&lt; Ø
--   </pre>
infix 6 :>

-- | Build a singleton Prod.
only :: () => f a -> Prod k f (:) k a [] k
head' :: () => Prod k f (:<) k a as -> f a

-- | Cons onto a Tuple.
infixr 5 ::<

-- | Singleton Tuple.
only_ :: () => a -> Tuple (:) * a [] *

-- | Optimized version of <tt><a>op1</a> (<a>+</a>)</tt>.
(+.) :: Num a => Op '[a, a] a

-- | Optimized version of <tt><a>op1</a> (<a>-</a>)</tt>.
(-.) :: Num a => Op '[a, a] a

-- | Optimized version of <tt><a>op1</a> (<a>*</a>)</tt>.
(*.) :: Num a => Op '[a, a] a

-- | Optimized version of <tt><a>op1</a> <a>negate</a></tt>.
negateOp :: Num a => Op '[a] a

-- | Optimized version of <tt><a>op1</a> <a>abs</a></tt>.
absOp :: Num a => Op '[a] a

-- | Optimized version of <tt><a>op1</a> <a>signum</a></tt>.
signumOp :: Num a => Op '[a] a

-- | Optimized version of <tt><a>op1</a> (<a>/</a>)</tt>.
(/.) :: Fractional a => Op '[a, a] a

-- | Optimized version of <tt><a>op1</a> <a>recip</a></tt>.
recipOp :: Fractional a => Op '[a] a

-- | Optimized version of <tt><a>op1</a> <a>exp</a></tt>.
expOp :: Floating a => Op '[a] a

-- | Optimized version of <tt><a>op1</a> <a>log</a></tt>.
logOp :: Floating a => Op '[a] a

-- | Optimized version of <tt><a>op1</a> <a>sqrt</a></tt>.
sqrtOp :: Floating a => Op '[a] a

-- | Optimized version of <tt><a>op1</a> (<a>**</a>)</tt>.
(**.) :: Floating a => Op '[a, a] a

-- | Optimized version of <tt><a>op2</a> <a>logBase</a></tt>.
logBaseOp :: Floating a => Op '[a, a] a

-- | Optimized version of <tt><a>op1</a> <a>sin</a></tt>.
sinOp :: Floating a => Op '[a] a

-- | Optimized version of <tt><a>op1</a> <a>cos</a></tt>.
cosOp :: Floating a => Op '[a] a

-- | Optimized version of <tt><a>op1</a> <a>tan</a></tt>.
tanOp :: Floating a => Op '[a] a

-- | Optimized version of <tt><a>op1</a> <a>asin</a></tt>.
asinOp :: Floating a => Op '[a] a

-- | Optimized version of <tt><a>op1</a> <a>acos</a></tt>.
acosOp :: Floating a => Op '[a] a

-- | Optimized version of <tt><a>op1</a> <a>atan</a></tt>.
atanOp :: Floating a => Op '[a] a

-- | Optimized version of <tt><a>op1</a> <a>sinh</a></tt>.
sinhOp :: Floating a => Op '[a] a

-- | Optimized version of <tt><a>op1</a> <a>cosh</a></tt>.
coshOp :: Floating a => Op '[a] a

-- | Optimized version of <tt><a>op1</a> <a>tanh</a></tt>.
tanhOp :: Floating a => Op '[a] a

-- | Optimized version of <tt><a>op1</a> <a>asinh</a></tt>.
asinhOp :: Floating a => Op '[a] a

-- | Optimized version of <tt><a>op1</a> <a>acosh</a></tt>.
acoshOp :: Floating a => Op '[a] a

-- | Optimized version of <tt><a>op1</a> <a>atanh</a></tt>.
atanhOp :: Floating a => Op '[a] a
instance (Type.Class.Known.Known [*] (Data.Type.Length.Length *) as, Data.Type.Index.Every * GHC.Num.Num as, GHC.Num.Num a) => GHC.Num.Num (Numeric.Backprop.Op.Op as a)
instance (Type.Class.Known.Known [*] (Data.Type.Length.Length *) as, Data.Type.Index.Every * GHC.Real.Fractional as, Data.Type.Index.Every * GHC.Num.Num as, GHC.Real.Fractional a) => GHC.Real.Fractional (Numeric.Backprop.Op.Op as a)
instance (Type.Class.Known.Known [*] (Data.Type.Length.Length *) as, Data.Type.Index.Every * GHC.Float.Floating as, Data.Type.Index.Every * GHC.Real.Fractional as, Data.Type.Index.Every * GHC.Num.Num as, GHC.Float.Floating a) => GHC.Float.Floating (Numeric.Backprop.Op.Op as a)


-- | Provides the <tt>BP</tt> monad and the <a>BVar</a> type; after
--   manipulating <a>BVar</a>s (inputs to your function) to produce a
--   result, the library tracks internal data dependencies, which are used
--   to perform back-propagation (reverse-mode automatic differentiation)
--   to calculate the gradient of the output with respect to the inputs.
--   
--   Similar to automatic differentiation from the <i>ad</i> library and
--   <a>Numeric.AD.Mode.Reverse</a>, except for a few key differences:
--   
--   <ol>
--   <li>Most importantly, this library implements <i>heterogeneous</i>
--   back-propagation, so you can manipulate values of different types
--   (like different matrix and vector types, and product and sum types).
--   This is essential for things like back-propagation for neural
--   networks.</li>
--   <li>This module allows you to <i>explicitly</i> build your data
--   dependency graph if you wish, which allows the library to perform
--   optimizations and reduce extra allocation, which may or may not
--   provide advantages over <a>Numeric.AD.Mode.Reverse</a>'s
--   <a>unsafePerformIO</a>-based implicit graph building.</li>
--   </ol>
--   
--   See the <a>README</a> for more information and links to demonstrations
--   and tutorials. If you want to plunge right in, you can also look
--   directly at the main types, <tt>BP</tt>, <tt>BPOp</tt>, <a>BVar</a>,
--   <a>Op</a>, and the main functions, <a>backprop</a> and <tt>opVar</tt>.
--   
--   Note that every type involved has to be an instance of <a>Num</a>.
--   This is because gradients all need to be "summable" (which is
--   implemented using <a>sum</a> and <a>+</a>), and we also need to able
--   to generate gradients of '1' and '0'.
module Numeric.Backprop
data BVar (s :: Type) (a :: Type)
data W
constVar :: a -> BVar s a
liftOpN :: forall s as b. (Reifies s W, Num b, Every Num as) => Op as b -> Prod (BVar s) as -> BVar s b
liftOp1 :: forall s a b. (Reifies s W, Num a, Num b) => Op '[a] b -> BVar s a -> BVar s b
liftOp2 :: forall s a b c. (Reifies s W, Num a, Num b, Num c) => Op '[a, b] c -> BVar s a -> BVar s b -> BVar s c
liftOp3 :: forall s a b c d. (Reifies s W, Num a, Num b, Num c, Num d) => Op '[a, b, c] d -> BVar s a -> BVar s b -> BVar s c -> BVar s d
liftOp4 :: forall s a b c d e. (Reifies s W, Num a, Num b, Num c, Num d, Num e) => Op '[a, b, c, d] e -> BVar s a -> BVar s b -> BVar s c -> BVar s d -> BVar s e
lensVar :: forall a b s. (Reifies s W, Num b, Num a) => Lens' b a -> BVar s b -> BVar s a
(^^.) :: forall a b s. (Reifies s W, Num b, Num a) => BVar s b -> Lens' b a -> BVar s a
infixl 8 ^^.
uncurryVar :: (Num a, Num b, Num (a, b)) => (forall s. Reifies s W => BVar s a -> BVar s b -> BVar s c) -> (forall s. Reifies s W => BVar s (a, b) -> BVar s c)
backprop :: forall a b. (Num a, Num b) => (forall s. Reifies s W => BVar s a -> BVar s b) -> a -> (b, a)
evalBP :: forall a b. (Num a, Num b) => (forall s. Reifies s W => BVar s a -> BVar s b) -> a -> b
gradBP :: forall a b. (Num a, Num b) => (forall s. Reifies s W => BVar s a -> BVar s b) -> a -> a

-- | An <tt><tt>OpM</tt> m as a</tt> represents a <i>differentiable</i>
--   (monadic) function from <tt>as</tt> to <tt>a</tt>, in the context of a
--   <a>Monad</a> <tt>m</tt>.
--   
--   For example, an
--   
--   <pre>
--   <tt>OpM</tt> IO '[Int, Bool] Double
--   </pre>
--   
--   would be a function that takes an <a>Int</a> and a <a>Bool</a> and
--   returns a <a>Double</a> (in <a>IO</a>). It can be differentiated to
--   give a <i>gradient</i> of an <a>Int</a> and a <a>Bool</a> (also in
--   <a>IO</a>) if given the total derivative for the <tt>Double</tt>.
--   
--   Note that an <tt>OpM</tt> is a <i>superclass</i> of <a>Op</a>, so any
--   function that expects an <tt><tt>OpM</tt> m as a</tt> can also accept
--   an <tt><a>Op</a> as a</tt>.
--   
--   See <tt>runOpM</tt>, <tt>gradOpM</tt>, and <tt>gradOpWithM</tt> for
--   examples on how to run it.
newtype Op as a

-- | Construct an <tt>OpM</tt> by giving a (monadic) function creating the
--   result, and also a continuation on how to create the gradient, given
--   the total derivative of <tt>a</tt>.
--   
--   See the module documentation for <a>Numeric.Backprop.Op</a> for more
--   details on the function that this constructor and <a>Op</a> expect.
Op :: (Tuple as -> (a, a -> Tuple as)) -> Op as a
[runOpWith] :: Op as a -> Tuple as -> (a, a -> Tuple as)
data Prod k (f :: k -> *) (a :: [k]) :: forall k. () => (k -> *) -> [k] -> *
[Ø] :: Prod k f [] k
[:<] :: Prod k f (:) k a1 as

-- | A Prod of simple Haskell types.
type Tuple = Prod * I
newtype I a :: * -> *
I :: a -> I a
[getI] :: I a -> a

-- | Create an <a>Op</a> that takes no inputs and always returns the given
--   value.
--   
--   There is no gradient, of course (using <a>gradOp</a> will give you an
--   empty tuple), because there is no input to have a gradient of.
--   
--   <pre>
--   &gt;&gt;&gt; gradOp' (op0 10) Ø
--   (10, Ø)
--   </pre>
--   
--   For a constant <a>Op</a> that takes input and ignores it, see
--   <a>opConst</a> and <a>opConst'</a>.
--   
--   Note that because this returns an <a>Op</a>, it can be used with any
--   function that expects an <tt>OpM</tt> or <a>OpB</a>, as well.
op0 :: a -> Op '[] a

-- | An <a>Op</a> that ignores all of its inputs and returns a given
--   constant value.
--   
--   <pre>
--   &gt;&gt;&gt; gradOp' (opConst 10) (1 ::&lt; 2 ::&lt; 3 ::&lt; Ø)
--   (10, 0 ::&lt; 0 ::&lt; 0 ::&lt; Ø)
--   </pre>
opConst :: forall as a. (Every Num as, Known Length as) => a -> Op as a

-- | An <a>Op</a> that just returns whatever it receives. The identity
--   function.
--   
--   <pre>
--   <a>idOp</a> = <a>opIso</a> <a>id</a>
--   </pre>
idOp :: Num a => Op '[a] a

-- | A version of <a>opConst</a> taking explicit <a>Length</a>, indicating
--   the number of inputs and their types.
--   
--   Requiring an explicit <a>Length</a> is mostly useful for rare
--   "extremely polymorphic" situations, where GHC can't infer the type and
--   length of the the expected input tuple. If you ever actually
--   explicitly write down <tt>as</tt> as a list of types, you should be
--   able to just use <a>opConst</a>.
opConst' :: forall as a. Every Num as => Length as -> a -> Op as a

-- | Create an <a>Op</a> of a function taking one input, by giving its
--   explicit derivative. The function should return a tuple containing the
--   result of the function, and also a function taking the derivative of
--   the result and return the derivative of the input.
--   
--   If we have
--   
--   &lt;math&gt;
--   
--   Then the derivative &lt;math&gt;, it would be:
--   
--   &lt;math&gt;
--   
--   If our <a>Op</a> represents &lt;math&gt;, then the second item in the
--   resulting tuple should be a function that takes &lt;math&gt; and
--   returns &lt;math&gt;.
--   
--   If the input is <a>Nothing</a>, then &lt;math&gt; should be taken to
--   be &lt;math&gt;.
--   
--   As an example, here is an <a>Op</a> that squares its input:
--   
--   <pre>
--   square :: Num a =&gt; <a>Op</a> '[a] a
--   square = <a>op1'</a> $ \x -&gt; (x*x, \case Nothing -&gt; 2 * x
--                                     Just d  -&gt; 2 * d * x
--                         )
--   </pre>
--   
--   Remember that, generally, end users shouldn't directly construct
--   <a>Op</a>s; they should be provided by libraries or generated
--   automatically.
--   
--   For numeric functions, single-input <a>Op</a>s can be generated
--   automatically using <a>op1</a>.
op1 :: (a -> (b, b -> a)) -> Op '[a] b

-- | Create an <a>Op</a> of a function taking two inputs, by giving its
--   explicit gradient. The function should return a tuple containing the
--   result of the function, and also a function taking the derivative of
--   the result and return the derivative of the input.
--   
--   If we have
--   
--   &lt;math&gt;
--   
--   Then the gradient &lt;math&gt; would be:
--   
--   &lt;math&gt;
--   
--   If our <a>Op</a> represents &lt;math&gt;, then the second item in the
--   resulting tuple should be a function that takes &lt;math&gt; and
--   returns &lt;math&gt;.
--   
--   If the input is <a>Nothing</a>, then &lt;math&gt; should be taken to
--   be &lt;math&gt;.
--   
--   As an example, here is an <a>Op</a> that multiplies its inputs:
--   
--   <pre>
--   mul :: Num a =&gt; <a>Op</a> '[a, a] a
--   mul = <a>op2'</a> $ \x y -&gt; (x*y, \case Nothing -&gt; (y  , x  )
--                                    Just d  -&gt; (d*y, x*d)
--                        )
--   </pre>
--   
--   Remember that, generally, end users shouldn't directly construct
--   <a>Op</a>s; they should be provided by libraries or generated
--   automatically.
--   
--   For numeric functions, two-input <a>Op</a>s can be generated
--   automatically using <a>op2</a>.
op2 :: (a -> b -> (c, c -> (a, b))) -> Op '[a, b] c

-- | Create an <a>Op</a> of a function taking three inputs, by giving its
--   explicit gradient. See documentation for <a>op2'</a> for more details.
op3 :: (a -> b -> c -> (d, d -> (a, b, c))) -> Op '[a, b, c] d

-- | Automatically create an <a>Op</a> of a numerical function taking one
--   argument. Uses <a>diff</a>, and so can take any numerical function
--   polymorphic over the standard numeric types.
--   
--   <pre>
--   &gt;&gt;&gt; gradOp' (op1 (recip . negate)) (5 ::&lt; Ø)
--   (-0.2, 0.04 ::&lt; Ø)
--   </pre>
op1' :: Num a => (forall s. AD s (Forward a) -> AD s (Forward a)) -> Op '[a] a

-- | Automatically create an <a>Op</a> of a numerical function taking two
--   arguments. Uses <a>grad</a>, and so can take any numerical function
--   polymorphic over the standard numeric types.
--   
--   <pre>
--   &gt;&gt;&gt; gradOp' (op2 (\x y -&gt; x * sqrt y)) (3 ::&lt; 4 ::&lt; Ø)
--   (6.0, 2.0 ::&lt; 0.75 ::&lt; Ø)
--   </pre>
op2' :: Num a => (forall s. Reifies s Tape => Reverse s a -> Reverse s a -> Reverse s a) -> Op '[a, a] a

-- | Automatically create an <a>Op</a> of a numerical function taking three
--   arguments. Uses <a>grad</a>, and so can take any numerical function
--   polymorphic over the standard numeric types.
--   
--   <pre>
--   &gt;&gt;&gt; gradOp' (op3 (\x y z -&gt; (x * sqrt y)**z)) (3 ::&lt; 4 ::&lt; 2 ::&lt; Ø)
--   (36.0, 24.0 ::&lt; 9.0 ::&lt; 64.503 ::&lt; Ø)
--   </pre>
op3' :: Num a => (forall s. Reifies s Tape => Reverse s a -> Reverse s a -> Reverse s a -> Reverse s a) -> Op '[a, a, a] a

-- | Automatically create an <a>Op</a> of a numerical function taking
--   multiple arguments. Uses <a>grad</a>, and so can take any numerical
--   function polymorphic over the standard numeric types.
--   
--   <pre>
--   &gt;&gt;&gt; gradOp' (opN (\(x :+ y :+ Ø) -&gt; x * sqrt y)) (3 ::&lt; 4 ::&lt; Ø)
--   (6.0, 2.0 ::&lt; 0.75 ::&lt; Ø)
--   </pre>
opN' :: (Num a, Known Nat n) => (forall s. Reifies s Tape => Vec n (Reverse s a) -> Reverse s a) -> Op (Replicate n a) a

-- | <tt><a>Replicate</a> n a</tt> is a list of <tt>a</tt>s repeated
--   <tt>n</tt> times.
--   
--   <pre>
--   &gt;&gt;&gt; :kind! Replicate N3 Int
--   '[Int, Int, Int]
--   
--   &gt;&gt;&gt; :kind! Replicate N5 Double
--   '[Double, Double, Double, Double, Double]
--   </pre>

-- | An <a>Op</a> that coerces an item into another item whose type has the
--   same runtime representation. Requires the input to be an instance of
--   <a>Num</a>.
--   
--   <pre>
--   &gt;&gt;&gt; gradOp' opCoerce (Identity 5) :: (Int, Identity Int)
--   (5, Identity 1)
--   </pre>
--   
--   <pre>
--   <a>opCoerce</a> = <a>opIso</a> <a>coerced</a>
--   </pre>
opCoerce :: Num a => Coercible a b => Op '[a] b

-- | An <a>Op</a> that takes <tt>as</tt> and returns exactly the input
--   tuple.
--   
--   <pre>
--   &gt;&gt;&gt; gradOp' opTup (1 ::&lt; 2 ::&lt; 3 ::&lt; Ø)
--   (1 ::&lt; 2 ::&lt; 3 ::&lt; Ø, 1 ::&lt; 1 ::&lt; 1 ::&lt; Ø)
--   </pre>
opTup :: (Every Num as, Known Length as) => Op as (Tuple as)

-- | An <a>Op</a> that runs the input value through the isomorphism encoded
--   in the <a>Iso</a>. Requires the input to be an instance of <a>Num</a>.
--   
--   Warning: This is unsafe! It assumes that the isomorphisms themselves
--   have derivative 1, so will break for things like
--   <a>exponentiating</a>. Basically, don't use this for any "numeric"
--   isomorphisms.
opIso :: Iso' a b -> Op '[a] b
opLens :: Num a => Lens' a b -> Op '[a] b

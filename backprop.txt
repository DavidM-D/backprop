-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package backprop
@version 0.1.0.0

module Numeric.Backprop.Iso
type Iso s t a b = forall p f. (Profunctor p, Functor f) => p a (f b) -> p s (f t)
type Iso' s a = Iso s s a a
iso :: (s -> a) -> (b -> t) -> Iso s t a b
review :: Iso s t a b -> b -> t
genProd :: (Generic a, Code a ~ '[as]) => Iso' a (Tuple as)

module Numeric.Backprop
data BP s rs b
type BPOp s rs a = BP s rs (BPRef s rs a)
data BPRef :: Type -> [Type] -> Type -> Type
newBPRef :: Num a => Prod (BPRef s rs) as -> Op as a -> BP s rs (BPRef s rs a)
newBPRef0 :: Num a => Op '[] a -> BP s rs (BPRef s rs a)
newBPRef1 :: Num b => BPRef s rs a -> Op '[a] b -> BP s rs (BPRef s rs b)
newBPRef2 :: Num c => BPRef s rs a -> BPRef s rs b -> Op '[a, b] c -> BP s rs (BPRef s rs c)
newBPRef3 :: Num d => BPRef s rs a -> BPRef s rs b -> BPRef s rs c -> Op '[a, b, c] d -> BP s rs (BPRef s rs d)
backprop :: forall rs a. Every Num rs => (forall s. BPOp s rs a) -> Tuple rs -> (a, Tuple rs)
runBPOp :: Every Num rs => (forall s. BPOp s rs a) -> Tuple rs -> a
refParts :: forall s rs bs b. (Every Num bs, Known Length bs) => Iso' b (Tuple bs) -> BPRef s rs b -> BP s rs (Prod (BPRef s rs) bs)
splitGeneric :: (Every Num bs, Known Length bs, Generic b, Code b ~ '[bs]) => BPRef s rs b -> BP s rs (Prod (BPRef s rs) bs)
splitRefs :: forall s rs as. (Every Num as, Known Length as) => BPRef s rs (Tuple as) -> BP s rs (Prod (BPRef s rs) as)
internally :: forall s rs bs b a. (Every Num bs, Known Length bs, Num a) => Iso' b (Tuple bs) -> BPRef s rs b -> BP s bs (BPRef s bs a) -> BP s rs (BPRef s rs a)
plugBP :: forall s rs as a. (Every Num as, Num a) => Prod (BPRef s rs) as -> BPOp s as a -> BPOp s rs a
newBPRef' :: forall s rs as a. Prod (BPRef s rs) as -> Op as a -> Summer a -> BP s rs (BPRef s rs a)
newBPRef0' :: Op '[] a -> Summer a -> BP s rs (BPRef s rs a)
newBPRef1' :: BPRef s rs a -> Op '[a] b -> Summer b -> BP s rs (BPRef s rs b)
newBPRef2' :: BPRef s rs a -> BPRef s rs b -> Op '[a, b] c -> Summer c -> BP s rs (BPRef s rs c)
newBPRef3' :: BPRef s rs a -> BPRef s rs b -> BPRef s rs c -> Op '[a, b, c] d -> Summer d -> BP s rs (BPRef s rs d)
backprop' :: (forall s. BPOp s rs a) -> Prod (Summer) rs -> Prod (Unity) rs -> Tuple rs -> (a, Tuple rs)
runBPOp' :: (forall s. BPOp s rs a) -> Prod (Summer) rs -> Prod (Unity) rs -> Tuple rs -> a
refParts' :: forall s rs bs b. Prod Summer bs -> Prod Unity bs -> Iso' b (Tuple bs) -> BPRef s rs b -> BP s rs (Prod (BPRef s rs) bs)
splitGeneric' :: (Generic b, Code b ~ '[bs]) => Prod Summer bs -> Prod Unity bs -> BPRef s rs b -> BP s rs (Prod (BPRef s rs) bs)
splitRefs' :: forall s rs as. Prod Summer as -> Prod Unity as -> BPRef s rs (Tuple as) -> BP s rs (Prod (BPRef s rs) as)
internally' :: forall s rs bs b a. Prod Summer bs -> Prod Unity bs -> Summer a -> Iso' b (Tuple bs) -> BPRef s rs b -> BP s bs (BPRef s bs a) -> BP s rs (BPRef s rs a)
plugBP' :: Prod (BPRef s rs) as -> BPOp s as a -> Prod (Summer) as -> Prod (Unity) as -> Summer a -> BPOp s rs a
inpRef :: Index rs a -> BPRef s rs a
inpRefs :: Known Length rs => Prod (BPRef s rs) rs
withInps :: Known Length rs => (Prod (BPRef s rs) rs -> BP s rs a) -> BP s rs a
newtype Op as a
Op :: (Tuple as -> (a, Maybe a -> Tuple as)) -> Op as a
[runOp'] :: Op as a -> Tuple as -> (a, Maybe a -> Tuple as)
newtype Summer a
Summer :: ([a] -> a) -> Summer a
[runSummer] :: Summer a -> [a] -> a
newtype Unity a
Unity :: a -> Unity a
[getUnity] :: Unity a -> a
data Prod k (f :: k -> *) (a :: [k]) :: forall k. (k -> *) -> [k] -> *
[Ø] :: Prod k f ([] k)
[:<] :: Prod k f ((:) k a1 as)

-- | Construct a two element Prod. Since the precedence of (:&gt;) is
--   higher than (:&lt;), we can conveniently write lists like:
--   
--   <pre>
--   &gt;&gt;&gt; a :&lt; b :&gt; c
--   </pre>
--   
--   Which is identical to:
--   
--   <pre>
--   &gt;&gt;&gt; a :&lt; b :&lt; c :&lt; Ø
--   </pre>
infix 6 :>

-- | Build a singleton Prod.
only :: f a -> Prod k f ((:) k a ([] k))

-- | A Prod of simple Haskell types.
type Tuple = Prod * I

-- | Cons onto a Tuple.
infixr 5 ::<

-- | Singleton Tuple.
only_ :: a -> Tuple ((:) * a ([] *))

module Numeric.Backprop.Op
newtype Op as a
Op :: (Tuple as -> (a, Maybe a -> Tuple as)) -> Op as a
[runOp'] :: Op as a -> Tuple as -> (a, Maybe a -> Tuple as)
runOp :: Op as a -> Tuple as -> a
gradOp :: Op as a -> Tuple as -> Tuple as
gradOpWith :: Op as a -> Tuple as -> a -> Tuple as
gradOpWith' :: Op as a -> Tuple as -> Maybe a -> Tuple as
op0 :: a -> Op '[] a
op1 :: Num a => (forall s. AD s (Forward a) -> AD s (Forward a)) -> Op '[a] a
op2 :: Num a => (forall s. Reifies s Tape => Reverse s a -> Reverse s a -> Reverse s a) -> Op '[a, a] a
op3 :: Num a => (forall s. Reifies s Tape => Reverse s a -> Reverse s a -> Reverse s a -> Reverse s a) -> Op '[a, a, a] a
opN :: (Num a, Known Nat n) => (forall s. Reifies s Tape => Vec n (Reverse s a) -> Reverse s a) -> Op (Replicate n a) a
opCoerce :: (Coercible a b, Num a) => Op '[a] b
opTup :: (Every Num as, Known Length as) => Op as (Tuple as)
opIso :: Num a => (a -> b) -> (b -> a) -> Op '[a] b
op1' :: (a -> (b, Maybe b -> a)) -> Op '[a] b
op2' :: (a -> b -> (c, Maybe c -> (a, b))) -> Op '[a, b] c
op3' :: (a -> b -> c -> (d, Maybe d -> (a, b, c))) -> Op '[a, b, c] d
opN' :: (Known Nat n) => (Vec n a -> (b, Maybe b -> Vec n a)) -> Op (Replicate n a) b
opCoerce' :: Coercible a b => Unity a -> Op '[a] b
opTup' :: Prod Unity as -> Op as (Tuple as)
opIso' :: Unity a -> (a -> b) -> (b -> a) -> Op '[a] b

module Numeric.Backprop.Mono
type BP s n a = BP s (Replicate n a)
type BPOp s n a b = BP s n a (BPRef s n a b)
type BPRef s n a = BPRef s (Replicate n a)
newBPRef :: forall s m n a b. Num b => VecT m (BPRef s n a) a -> Op m a b -> BP s n a (BPRef s n a b)
newBPRef0 :: forall s n a b. Num b => Op N0 a b -> BP s n a (BPRef s n a b)
newBPRef1 :: forall s n a b. Num b => BPRef s n a a -> Op N1 a b -> BP s n a (BPRef s n a b)
newBPRef2 :: forall s n a b. Num b => BPRef s n a a -> BPRef s n a a -> Op N2 a b -> BP s n a (BPRef s n a b)
newBPRef3 :: forall s n a b. Num b => BPRef s n a a -> BPRef s n a a -> BPRef s n a a -> Op N3 a b -> BP s n a (BPRef s n a b)
backprop :: forall n a b. Num a => (forall s. BPOp s n a b) -> Vec n a -> (b, Vec n a)
runBPOp :: forall n a b. Num a => (forall s. BPOp s n a b) -> Vec n a -> b
plugBP :: (Num b, Num c) => VecT m (BPRef s n a) b -> BPOp s m b c -> BPOp s n a c
inpRef :: Fin n -> BPRef s n a a
inpRefs :: Known Nat n => VecT n (BPRef s n a) a
withInps :: Known Nat n => (VecT n (BPRef s n a) a -> BP s n a b) -> BP s n a b
type Op n a = Op (Replicate n a)
op0 :: a -> Op N0 r a
op1 :: Num a => (forall s. AD s (Forward a) -> AD s (Forward a)) -> Op N1 a a
op2 :: Num a => (forall s. Reifies s Tape => Reverse s a -> Reverse s a -> Reverse s a) -> Op N2 a a
op3 :: Num a => (forall s. Reifies s Tape => Reverse s a -> Reverse s a -> Reverse s a -> Reverse s a) -> Op N3 a a
opN :: (Num a, Known Nat n) => (forall s. Reifies s Tape => Vec n (Reverse s a) -> Reverse s a) -> Op n a a
runOp' :: Op n a b -> Vec n a -> (b, Maybe b -> Vec n a)
runOp :: Op n a b -> Vec n a -> b
gradOp :: Op n a b -> Vec n a -> Vec n a
gradOpWith :: Op n a b -> Vec n a -> b -> Vec n a
gradOpWith' :: Op n a b -> Vec n a -> Maybe b -> Vec n a

-- | Convenient aliases for low-value Peano numbers.
type N0 = Z
type N1 = S N0
type N2 = S N1
type N3 = S N2
type N4 = S N3
type N5 = S N4
type N6 = S N5
type N7 = S N6
type N8 = S N7
type N9 = S N8
type N10 = S N9
data VecT k (n :: N) (f :: k -> *) (a :: k) :: forall k. N -> (k -> *) -> k -> *
[ØV] :: VecT k Z f a
[:*] :: VecT k (S n1) f a
type Vec (n :: N) = VecT * n I
infixr 4 :+
(*:) :: f a -> f a -> VecT k (S (S Z)) f a
infix 5 *:
(+:) :: a -> a -> Vec (S (S Z)) a
infix 5 +:

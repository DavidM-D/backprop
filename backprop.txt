-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package backprop
@version 0.1.0.0

module Numeric.Backprop
data BP s f rs b
data BPRef :: Type -> (k -> Type) -> [k] -> k -> Type
newBPRef :: Num (f a) => Prod (BPRef s f rs) as -> Op f as a -> BP s f rs (BPRef s f rs a)
newBPRef0 :: Num (f a) => Op f '[] a -> BP s f rs (BPRef s f rs a)
newBPRef1 :: Num (f b) => BPRef s f rs a -> Op f '[a] b -> BP s f rs (BPRef s f rs b)
newBPRef2 :: Num (f c) => BPRef s f rs a -> BPRef s f rs b -> Op f '[a, b] c -> BP s f rs (BPRef s f rs c)
newBPRef3 :: Num (f d) => BPRef s f rs a -> BPRef s f rs b -> BPRef s f rs c -> Op f '[a, b, c] d -> BP s f rs (BPRef s f rs d)
backprop :: forall f rs a. Every Num (f <$> rs) => (forall s. BP s f rs (BPRef s f rs a)) -> Prod f rs -> (f a, Prod f rs)
plugBP :: forall s f rs as a. (Every Num (f <$> as), Num (f a)) => Prod (BPRef s f rs) as -> BP s f as (BPRef s f as a) -> BP s f rs (BPRef s f rs a)
newBPRef' :: forall s f rs as a. Prod (BPRef s f rs) as -> Op f as a -> Summer f a -> BP s f rs (BPRef s f rs a)
newBPRef0' :: Op f '[] a -> Summer f a -> BP s f rs (BPRef s f rs a)
newBPRef1' :: BPRef s f rs a -> Op f '[a] b -> Summer f b -> BP s f rs (BPRef s f rs b)
newBPRef2' :: BPRef s f rs a -> BPRef s f rs b -> Op f '[a, b] c -> Summer f c -> BP s f rs (BPRef s f rs c)
newBPRef3' :: BPRef s f rs a -> BPRef s f rs b -> BPRef s f rs c -> Op f '[a, b, c] d -> Summer f d -> BP s f rs (BPRef s f rs d)
backprop' :: (forall s. BP s f rs (BPRef s f rs a)) -> Prod (Summer f) rs -> Prod (Unity f) rs -> Prod f rs -> (f a, Prod f rs)
plugBP' :: Prod (BPRef s f rs) as -> BP s f as (BPRef s f as a) -> Prod (Summer f) as -> Prod (Unity f) as -> Summer f a -> BP s f rs (BPRef s f rs a)
inpRef :: Index rs a -> BPRef s f rs a
inpRefs :: Known Length rs => Prod (BPRef s f rs) rs
withInps :: Known Length rs => (Prod (BPRef s f rs) rs -> BP s f rs a) -> BP s f rs a
newtype Op f as a
Op :: (Prod f as -> (f a, Maybe (f a) -> Prod f as)) -> Op f as a
[runOp'] :: Op f as a -> Prod f as -> (f a, Maybe (f a) -> Prod f as)
newtype Summer :: (k -> Type) -> k -> Type
[Summer] :: {runSummer :: [f a] -> f a} -> Summer f a
newtype Unity :: (k -> Type) -> k -> Type
[Unity] :: {getUnity :: f a} -> Unity f a
data Prod k (f :: k -> *) (a :: [k]) :: forall k. (k -> *) -> [k] -> *
[Ø] :: Prod k f ([] k)
[:<] :: Prod k f ((:) k a1 as)

-- | Construct a two element Prod. Since the precedence of (:&gt;) is
--   higher than (:&lt;), we can conveniently write lists like:
--   
--   <pre>
--   &gt;&gt;&gt; a :&lt; b :&gt; c
--   </pre>
--   
--   Which is identical to:
--   
--   <pre>
--   &gt;&gt;&gt; a :&lt; b :&lt; c :&lt; Ø
--   </pre>
infix 6 :>

-- | Build a singleton Prod.
only :: f a -> Prod k f ((:) k a ([] k))

-- | A Prod of simple Haskell types.
type Tuple = Prod * I

-- | Cons onto a Tuple.
infixr 5 ::<

-- | Singleton Tuple.
only_ :: a -> Tuple ((:) * a ([] *))

module Numeric.Backprop.Op
newtype Op f as a
Op :: (Prod f as -> (f a, Maybe (f a) -> Prod f as)) -> Op f as a
[runOp'] :: Op f as a -> Prod f as -> (f a, Maybe (f a) -> Prod f as)
runOp :: Op f as a -> Prod f as -> f a
gradOp :: Op f as a -> Prod f as -> Prod f as
gradOpWith :: Op f as a -> Prod f as -> f a -> Prod f as
gradOpWith' :: Op f as a -> Prod f as -> Maybe (f a) -> Prod f as
op0 :: f a -> Op f '[] a
op1 :: Num (f a) => (forall s. AD s (Forward (f a)) -> AD s (Forward (f a))) -> Op f '[a] a
op2 :: Num (f a) => (forall s. Reifies s Tape => Reverse s (f a) -> Reverse s (f a) -> Reverse s (f a)) -> Op f '[a, a] a
op3 :: Num (f a) => (forall s. Reifies s Tape => Reverse s (f a) -> Reverse s (f a) -> Reverse s (f a) -> Reverse s (f a)) -> Op f '[a, a, a] a
opN :: (Num (f a), Known Nat n) => (forall s. Reifies s Tape => Vec n (Reverse s (f a)) -> Reverse s (f a)) -> Op f (Replicate n a) a
op1' :: (f a -> (f b, Maybe (f b) -> f a)) -> Op f '[a] b
op2' :: (f a -> f b -> (f c, Maybe (f c) -> (f a, f b))) -> Op f '[a, b] c
op3' :: (f a -> f b -> f c -> (f d, Maybe (f d) -> (f a, f b, f c))) -> Op f '[a, b, c] d
opN' :: (Num (f a), Known Nat n) => (Vec n (f a) -> (f b, Maybe (f b) -> Vec n (f a))) -> Op f (Replicate n a) b

module Numeric.Backprop.Mono
type BP s n a = BP s I (Replicate n a)
type BPRef s n a = BPRef s I (Replicate n a)
newBPRef :: forall s m n a b. Num b => VecT m (BPRef s n a) a -> Op m a b -> BP s n a (BPRef s n a b)
newBPRef0 :: forall s n a b. Num b => Op N0 a b -> BP s n a (BPRef s n a b)
newBPRef1 :: forall s n a b. Num b => BPRef s n a a -> Op N1 a b -> BP s n a (BPRef s n a b)
newBPRef2 :: forall s n a b. Num b => BPRef s n a a -> BPRef s n a a -> Op N2 a b -> BP s n a (BPRef s n a b)
newBPRef3 :: forall s n a b. Num b => BPRef s n a a -> BPRef s n a a -> BPRef s n a a -> Op N3 a b -> BP s n a (BPRef s n a b)
backprop :: forall n a b. Num a => (forall s. BP s n a (BPRef s n a b)) -> Vec n a -> (b, Vec n a)
plugBP :: (Num b, Num c) => VecT m (BPRef s n a) b -> BP s m b (BPRef s m b c) -> BP s n a (BPRef s n a c)
inpRef :: Fin n -> BPRef s n a a
inpRefs :: Known Nat n => VecT n (BPRef s n a) a
withInps :: Known Nat n => (VecT n (BPRef s n a) a -> BP s n a b) -> BP s n a b
type Op n a = Op I (Replicate n a)
op0 :: a -> Op N0 r a
op1 :: Num a => (forall s. AD s (Forward (I a)) -> AD s (Forward (I a))) -> Op N1 a a
op2 :: Num a => (forall s. Reifies s Tape => Reverse s (I a) -> Reverse s (I a) -> Reverse s (I a)) -> Op N2 a a
op3 :: Num a => (forall s. Reifies s Tape => Reverse s (I a) -> Reverse s (I a) -> Reverse s (I a) -> Reverse s (I a)) -> Op N3 a a
opN :: (Num a, Known Nat n) => (forall s. Reifies s Tape => Vec n (Reverse s (I a)) -> Reverse s (I a)) -> Op n a a
runOp' :: Op n a b -> Vec n a -> (b, Maybe b -> Vec n a)
runOp :: Op n a b -> Vec n a -> b
gradOp :: Op n a b -> Vec n a -> Vec n a
gradOpWith :: Op n a b -> Vec n a -> b -> Vec n a
gradOpWith' :: Op n a b -> Vec n a -> Maybe b -> Vec n a

-- | Convenient aliases for low-value Peano numbers.
type N0 = Z
type N1 = S N0
type N2 = S N1
type N3 = S N2
type N4 = S N3
type N5 = S N4
type N6 = S N5
type N7 = S N6
type N8 = S N7
type N9 = S N8
type N10 = S N9
data VecT k (n :: N) (f :: k -> *) (a :: k) :: forall k. N -> (k -> *) -> k -> *
[ØV] :: VecT k Z f a
[:*] :: VecT k (S n1) f a
type Vec (n :: N) = VecT * n I
infixr 4 :+
(*:) :: f a -> f a -> VecT k (S (S Z)) f a
infix 5 *:
(+:) :: a -> a -> Vec (S (S Z)) a
infix 5 +:

-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Graph-based, heterogeneous, type-safe backpropagation in
--   Haskell
--   
--   See README.md
@package backprop
@version 0.1.0.0

module Numeric.Backprop.Iso
type Iso s t a b = forall p f. (Profunctor p, Functor f) => p a (f b) -> p s (f t)
type Iso' s a = Iso s s a a
iso :: (s -> a) -> (b -> t) -> Iso s t a b
re :: Iso' s a -> Iso' a s
review :: Iso s t a b -> b -> t
coercible :: Coercible s a => Iso' s a
gTuple :: (Generic a, Code a ~ '[as]) => Iso' a (Tuple as)
gSOP :: Generic a => Iso' a (Sum Tuple (Code a))
sum1 :: Iso' (Sum f '[a]) (f a)
resum1 :: Iso' (f a) (Sum f '[a])


-- | Provides the <a>Op</a> (and <a>OpM</a>) type and combinators, which
--   represent differentiable functions/operations on values, and are used
--   by the library to perform backpropagation.
module Numeric.Backprop.Op

-- | An <tt><a>Op</a> as a</tt> is a type synonym over <a>OpM</a> that
--   describes a differentiable function from <tt>as</tt> to <tt>a</tt>.
--   
--   For example, an
--   
--   <pre>
--   <a>Op</a> '[Int, Bool] Double
--   </pre>
--   
--   is a function from an <a>Int</a> and a <a>Bool</a>, returning a
--   <a>Double</a>. It can be differentiated to give a <i>gradient</i> of
--   an <a>Int</a> and a <a>Bool</a> if given a total derivative for
--   <tt>a</tt>.
--   
--   See <a>runOp</a>, <a>gradOp</a>, and <a>gradOpWith</a> for examples on
--   how to run it, and <a>Op</a> for instructions on creating it.
--   
--   This type is abstracted over using the pattern synonym with
--   constructor <a>Op</a>, so you can create one from scratch with it.
--   However, it's simplest to create it using <a>op2'</a>, <a>op1'</a>,
--   <a>op2'</a>, <a>op3'</a>, and <a>opN'</a> helper smart constructors
--   And, if your function is a numeric function, they can even be created
--   automatically using <a>op1</a>, <a>op2</a>, <a>op3</a>, and <a>opN</a>
--   with a little help from <a>Numeric.AD</a> from the <i>ad</i> library.
--   
--   Note that this type is a subset/subtype of <a>OpM</a>. So, if a
--   function ever expects an <tt><a>OpM</a> m as a</tt>, you can always
--   provide an <tt><a>Op</a> as a</tt> instead.
--   
--   Many functions in this library will expect an <tt><a>OpM</a> m as
--   a</tt> (or an <tt><a>OpB</a> s as a</tt>), and in all of these cases,
--   you can provide an <tt><a>Op</a> as a</tt>.
type Op as a = forall m. Monad m => OpM m as a

-- | An <tt><a>OpM</a> m as a</tt> represents a <i>differentiable</i>
--   (monadic) function from <tt>as</tt> to <tt>a</tt>, in the context of a
--   <a>Monad</a> <tt>m</tt>.
--   
--   For example, an
--   
--   <pre>
--   <a>OpM</a> IO '[Int, Bool] Double
--   </pre>
--   
--   would be a function that takes an <a>Int</a> and a <a>Bool</a> and
--   returns a <a>Double</a> (in <a>IO</a>). It can be differentiated to
--   give a <i>gradient</i> of an <a>Int</a> and a <a>Bool</a> (in
--   <a>IO</a>) if given the total derivative for <tt>a</tt>.
--   
--   See <a>runOpM</a>, <tt>gradOpM</tt>, and <a>gradOpWithM</a> for
--   examples on how to run it.
newtype OpM m as a

-- | Create an <a>OpM</a> by giving a function creating the result, and
--   also a continuation on how to create the gradient, given the total
--   derivative of <tt>a</tt>.
--   
--   See the module documentation for <a>Numeric.Backprop.Op</a> for more
--   details on the function that this constructor and <a>Op</a> expect.
OpM :: (Tuple as -> m (a, Maybe a -> m (Tuple as))) -> OpM m as a

-- | A combination of <a>runOpM</a> and <a>gradOpWithM'</a>. Given an
--   <a>OpM</a> and inputs, returns the result of the <a>Op</a> and a
--   continuation that gives its gradient.
--   
--   The continuation takes the total derivative of the result as input.
--   See documenation for <a>gradOpWithM'</a> and module documentation for
--   <a>Numeric.Backprop.Op</a> for more information.
[runOpM'] :: OpM m as a -> Tuple as -> m (a, Maybe a -> m (Tuple as))

-- | <a>Run</a> the function that an <a>Op</a> encodes, to get the result.
--   
--   <pre>
--   &gt;&gt;&gt; runOp (op2 (*)) (3 ::&lt; 5 ::&lt; Ø)
--   15
--   </pre>
runOp :: Op as a -> Tuple as -> a

-- | Run the function that an <a>Op</a> encodes, and get its gradient with
--   respect to the result.
--   
--   <pre>
--   &gt;&gt;&gt; gradOp (op2 (*)) (3 ::&lt; 5 ::&lt; Ø)
--   5 ::&lt; 3 ::&lt; Ø
--   -- the gradient of x*y is (y, x)
--   </pre>
gradOp :: Op as a -> Tuple as -> Tuple as

-- | Run the function that an <a>Op</a> encodes, and get its gradient with
--   respect to the total derivative of the result.
--   
--   See <a>gradOp</a> and the module documentaiton for
--   <a>Numeric.Backprop.Op</a> for more information.
gradOpWith :: Op as a -> Tuple as -> a -> Tuple as

-- | A combination of <a>gradOp</a> and <a>gradOpWith</a>. The third
--   argument is (optionally) the total derivative the result. Give
--   <a>Nothing</a> and it is assumed that the result is the final result
--   (and the total derivative is 1), and this behaves the same as
--   <a>gradOp</a>. Give <tt><a>Just</a> d</tt> and it uses the <tt>d</tt>
--   as the total derivative of the result, and this behaves like
--   <a>gradOpWith</a>.
--   
--   See <a>gradOp</a> and the module documentaiton for
--   <a>Numeric.Backprop.Op</a> for more information.
gradOpWith' :: Op as a -> Tuple as -> Maybe a -> Tuple as
runOp' :: Op as a -> Tuple as -> (a, Maybe a -> Tuple as)

-- | The monadic version of <a>runOp</a>, for <a>OpM</a>s.
--   
--   <pre>
--   &gt;&gt;&gt; runOpM (op2 (*)) (3 ::&lt; 5 ::&lt; Ø) :: IO Int
--   15
--   </pre>
runOpM :: Functor m => OpM m as a -> Tuple as -> m a

-- | The monadic version of <a>gradOpWith</a>, for <a>OpM</a>s.
gradOpWithM :: Monad m => OpM m as a -> Tuple as -> a -> m (Tuple as)

-- | The monadic version of <a>gradOpWith'</a>, for <a>OpM</a>s.
gradOpWithM' :: Monad m => OpM m as a -> Tuple as -> Maybe a -> m (Tuple as)

-- | Compose <a>OpM</a>s together, similar to <a>.</a>. But, because all
--   <a>OpM</a>s are &lt;math&gt;, this is more like <a>sequence</a> for
--   functions, or <tt>liftAN</tt>.
--   
--   That is, given an <tt><a>OpM</a> m as b1</tt>, an <tt><a>OpM</a> m as
--   b2</tt>, and an <tt><a>OpM</a> m as b3</tt>, it can compose them with
--   an <tt><a>OpM</a> m '[b1,b2,b3] c</tt> to create an <tt><a>OpM</a> as
--   c</tt>.
composeOp :: (Monad m, Known Length as, Every Num as) => Prod (OpM m as) bs -> OpM m bs c -> OpM m as c

-- | <a>composeOp</a>, but taking explicit <a>Summer</a>s, for the
--   situation where the <tt>as</tt> are not instance of <a>Num</a>.
composeOp' :: Monad m => Prod Summer as -> Prod (OpM m as) bs -> OpM m bs c -> OpM m as c
op0 :: a -> Op '[] a
op1 :: Num a => (forall s. AD s (Forward a) -> AD s (Forward a)) -> Op '[a] a
op2 :: Num a => (forall s. Reifies s Tape => Reverse s a -> Reverse s a -> Reverse s a) -> Op '[a, a] a
op3 :: Num a => (forall s. Reifies s Tape => Reverse s a -> Reverse s a -> Reverse s a -> Reverse s a) -> Op '[a, a, a] a
opN :: (Num a, Known Nat n) => (forall s. Reifies s Tape => Vec n (Reverse s a) -> Reverse s a) -> Op (Replicate n a) a
opCoerce :: (Coercible a b, Num a) => Op '[a] b
opTup :: (Every Num as, Known Length as) => Op as (Tuple as)
opIso :: Num a => Iso' a b -> Op '[a] b
op1' :: (a -> (b, Maybe b -> a)) -> Op '[a] b
op2' :: (a -> b -> (c, Maybe c -> (a, b))) -> Op '[a, b] c
op3' :: (a -> b -> c -> (d, Maybe d -> (a, b, c))) -> Op '[a, b, c] d
opN' :: (Known Nat n) => (Vec n a -> (b, Maybe b -> Vec n a)) -> Op (Replicate n a) b
opCoerce' :: Coercible a b => Unity a -> Op '[a] b
opTup' :: Prod Unity as -> Op as (Tuple as)
opIso' :: Unity a -> Iso' a b -> Op '[a] b
data Prod k (f :: k -> *) (a :: [k]) :: forall k. (k -> *) -> [k] -> *
[Ø] :: Prod k f ([] k)
[:<] :: Prod k f ((:) k a1 as)

-- | Construct a two element Prod. Since the precedence of (:&gt;) is
--   higher than (:&lt;), we can conveniently write lists like:
--   
--   <pre>
--   &gt;&gt;&gt; a :&lt; b :&gt; c
--   </pre>
--   
--   Which is identical to:
--   
--   <pre>
--   &gt;&gt;&gt; a :&lt; b :&lt; c :&lt; Ø
--   </pre>
infix 6 :>

-- | Build a singleton Prod.
only :: f a -> Prod k f ((:) k a ([] k))
head' :: Prod k f ((:<) k a as) -> f a

-- | A Prod of simple Haskell types.
type Tuple = Prod * I

-- | Cons onto a Tuple.
infixr 5 ::<

-- | Singleton Tuple.
only_ :: a -> Tuple ((:) * a ([] *))
instance (GHC.Base.Monad m, Type.Class.Known.Known Data.Type.Length.Length as, Data.Type.Index.Every GHC.Num.Num as, GHC.Num.Num a) => GHC.Num.Num (Numeric.Backprop.Op.OpM m as a)
instance (GHC.Base.Monad m, Type.Class.Known.Known Data.Type.Length.Length as, Data.Type.Index.Every GHC.Real.Fractional as, Data.Type.Index.Every GHC.Num.Num as, GHC.Real.Fractional a) => GHC.Real.Fractional (Numeric.Backprop.Op.OpM m as a)
instance (GHC.Base.Monad m, Type.Class.Known.Known Data.Type.Length.Length as, Data.Type.Index.Every GHC.Float.Floating as, Data.Type.Index.Every GHC.Real.Fractional as, Data.Type.Index.Every GHC.Num.Num as, GHC.Float.Floating a) => GHC.Float.Floating (Numeric.Backprop.Op.OpM m as a)

module Numeric.Backprop

-- | A Monad allowing you to explicitly build hetereogeneous data
--   dependency graphs and that the library can perform backpropagation on.
--   
--   A <tt><a>BP</a> s rs b</tt> is a <a>BP</a> action that uses an
--   environment of <tt>rs</tt> returning a <tt>b</tt>. When "run", it will
--   compute a gradient that is a tuple of <tt>rs</tt>. (The phantom
--   parameter <tt>s</tt> is used to ensure that any <a>BVar</a>s aren't
--   leaked out of the monad)
--   
--   Note that you can only "run" a <tt><a>BP</a> s rs</tt> that produces a
--   <a>BVar</a> -- that is, things of the form
--   
--   <pre>
--   <a>BP</a> s rs (<a>BVar</a> rs a)
--   </pre>
--   
--   The above is a <a>BP</a> action that returns a <a>BVar</a> containing
--   an <tt>a</tt>. When this is run, it'll produce a result of type
--   <tt>a</tt> and a gradient of that is a tuple of <tt>rs</tt>. (This
--   form has a type synonym, <a>BPOp</a>, for convenience)
--   
--   For example, a <tt><a>BP</a> s '[ Int, Double, Double ]</tt> is a
--   monad that represents a computation with an <a>Int</a>, <a>Double</a>,
--   and <a>Double</a> as inputs. And, if you ran a
--   
--   <pre>
--   <a>BP</a> s '[ Int, Double, Double ] (<a>BVar</a> '[ Int, Double, Double ] Double)
--   </pre>
--   
--   Or, using the <tt>BPOp</tt> type synonym:
--   
--   <pre>
--   <a>BPOp</a> s '[ Int, Double, Double ] (<a>BVar</a> rs Double)
--   </pre>
--   
--   with <a>backprop</a> or <a>gradBPOp</a>, it'll return a gradient on
--   the inputs (<a>Int</a>, <a>Double</a>, and <a>Double</a>) and produce
--   a value of type <a>Double</a>.
data BP s rs b

-- | A handy type synonym representing a <a>BP</a> action that returns a
--   <a>BVar</a>. This is handy because this is the form of <a>BP</a>
--   actions that <a>backprop</a> and <a>gradBPOp</a> (etc.) expects.
--   
--   A value of type:
--   
--   <pre>
--   <a>BPOp</a> s rs a
--   </pre>
--   
--   is an action that takes an input environment of <tt>rs</tt> and
--   produces a <a>BVar</a> containing a value of type <tt>a</tt>. Because
--   it returns a <a>BVar</a>, the library can track the data dependencies
--   between the <a>BVar</a> and the input environment and perform
--   backpropagation.
--   
--   See documentation for <a>BP</a> for an explanation of the phantom type
--   parameter <tt>s</tt>.
type BPOp s rs a = BP s rs (BVar s rs a)

-- | An "implicit" operation on <a>BVar</a>s that can be backpropagated. A
--   value of type:
--   
--   <pre>
--   <a>BPOpI</a> s rs a
--   </pre>
--   
--   takes a bunch of <a>BVar</a>s containg <tt>rs</tt> and uses them to
--   (purely) produce a <a>BVar</a> containing an <tt>a</tt>.
--   
--   If you are exclusively doing implicit backpropagation by combining
--   <a>BVar</a>s and using <a>BPOpI</a>s, you are probably better off just
--   importing <a>Numeric.Backprop.Implicit</a>, which provides better
--   tools. This type synonym exists in <a>Numeric.Backprop</a> just for
--   the <a>implicitly</a> function, which can convert "implicit" backprop
--   functions like a <tt><a>BPOpI</a> s rs a</tt> into an "explicit" graph
--   backprop function, a <tt><a>BPOp</a> s rs a</tt>.
type BPOpI s rs a = Prod (BVar s rs) rs -> BVar s rs a

-- | The basic unit of manipulation inside <a>BP</a>. Instead of directly
--   working with values, you work with <a>BVar</a>s contating those
--   values. When you work with a <a>BVar</a>, the <i>backprop</i> library
--   can keep track of what values refer to which other values, and so can
--   perform backpropagation to compute gradients.
--   
--   A <tt><a>BVar</a> s rs a</tt> refers to a value of type <tt>a</tt>,
--   with an environment of values of the types <tt>rs</tt>. The phantom
--   parameter <tt>s</tt> is used to ensure that stray <a>BVar</a>s don't
--   leak outside of the backprop process.
--   
--   (That is, if you're using implicit backprop, it ensures that you
--   interact with <a>BVar</a>s in a polymorphic way. And, if you're using
--   implicit backprop, it ensures that a <tt><a>BVar</a> s rs a</tt> never
--   leaves the <tt><a>BP</a> s rs</tt> that it was created in.)
--   
--   <a>BVar</a>s have <a>Num</a>, <a>Fractional</a>, <a>Floating</a>, etc.
--   instances, so they can be manipulated using polymorphic functions and
--   numeric functions in Haskell. You can add them, subtract them, etc.,
--   in "implicit" backprop style.
--   
--   (However, note that if you directly manipulate <a>BVar</a>s using
--   those instances or using <tt>liftR</tt>, it delays evaluation, so
--   every usage site has to re-compute the result/create a new node. If
--   you want to re-use a <a>BVar</a> you created using '(+)' or '(-)' or
--   <tt>liftR</tt>, use <tt>bindRef</tt> to force it first.)
data BVar :: Type -> [Type] -> Type -> Type

-- | An <tt><a>Op</a> as a</tt> is a type synonym over <a>OpM</a> that
--   describes a differentiable function from <tt>as</tt> to <tt>a</tt>.
--   
--   For example, an
--   
--   <pre>
--   <a>Op</a> '[Int, Bool] Double
--   </pre>
--   
--   is a function from an <a>Int</a> and a <a>Bool</a>, returning a
--   <a>Double</a>. It can be differentiated to give a <i>gradient</i> of
--   an <a>Int</a> and a <a>Bool</a> if given a total derivative for
--   <tt>a</tt>.
--   
--   See <a>runOp</a>, <a>gradOp</a>, and <a>gradOpWith</a> for examples on
--   how to run it, and <a>Op</a> for instructions on creating it.
--   
--   This type is abstracted over using the pattern synonym with
--   constructor <a>Op</a>, so you can create one from scratch with it.
--   However, it's simplest to create it using <a>op2'</a>, <a>op1'</a>,
--   <a>op2'</a>, <a>op3'</a>, and <a>opN'</a> helper smart constructors
--   And, if your function is a numeric function, they can even be created
--   automatically using <a>op1</a>, <a>op2</a>, <a>op3</a>, and <a>opN</a>
--   with a little help from <a>Numeric.AD</a> from the <i>ad</i> library.
--   
--   Note that this type is a subset/subtype of <a>OpM</a>. So, if a
--   function ever expects an <tt><a>OpM</a> m as a</tt>, you can always
--   provide an <tt><a>Op</a> as a</tt> instead.
--   
--   Many functions in this library will expect an <tt><a>OpM</a> m as
--   a</tt> (or an <tt><a>OpB</a> s as a</tt>), and in all of these cases,
--   you can provide an <tt><a>Op</a> as a</tt>.
type Op as a = forall m. Monad m => OpM m as a

-- | A type synonym for <a>OpM</a> specialized to what the <i>backprop</i>
--   library uses to perform backpropagation.
--   
--   An
--   
--   <pre>
--   <a>OpB</a> s rs a
--   </pre>
--   
--   represents a differentiable function that takes a tuple of <tt>rs</tt>
--   and produces an a <tt>a</tt>, which can be run on <tt><a>BVar</a>
--   s</tt> and also inside <tt><a>BP</a> s</tt>s. For example, an
--   <tt><a>OpB</a> s '[ Int, Double ] Bool</tt> takes an <a>Int</a> and a
--   <a>Double</a> and produces a <a>Bool</a>, and does it in a
--   differentiable way.
--   
--   Note that <a>OpB</a> is a <i>superset</i> of <a>Op</a>, so, if you see
--   any function that expects an <a>OpB</a> (like <a>opRef'</a> and
--   <a>~$</a>, for example), you can give them an <a>Op</a>, as well.
--   
--   You can think of <a>OpB</a> as a superclass/parent class of <a>Op</a>
--   in this sense, and of <a>Op</a> as a subclass of <a>OpB</a>.
type OpB s as a = OpM (ST s) as a
backprop :: forall rs a. Every Num rs => (forall s. BPOp s rs a) -> Tuple rs -> (a, Tuple rs)
evalBPOp :: Every Num rs => (forall s. BPOp s rs a) -> Tuple rs -> a
gradBPOp :: Every Num rs => (forall s. BPOp s rs a) -> Tuple rs -> Tuple rs
bpOp :: (Every Num as, Known Length as) => BPOp s as a -> OpB s as a
backprop' :: Prod Summer rs -> Prod Unity rs -> (forall s. BPOp s rs a) -> Tuple rs -> (a, Tuple rs)
evalBPOp' :: Prod Summer rs -> Prod Unity rs -> (forall s. BPOp s rs a) -> Tuple rs -> a
gradBPOp' :: Prod Summer rs -> Prod Unity rs -> (forall s. BPOp s rs a) -> Tuple rs -> Tuple rs
bpOp' :: Prod Summer as -> Prod Unity as -> BPOp s as a -> OpB s as a
withInps :: Known Length rs => (Prod (BVar s rs) rs -> BP s rs a) -> BP s rs a
implicitly :: Known Length rs => BPOpI s rs a -> BPOp s rs a
withInps' :: Length rs -> (Prod (BVar s rs) rs -> BP s rs a) -> BP s rs a
implicitly' :: Length rs -> BPOpI s rs a -> BPOp s rs a
constRef :: a -> BVar s rs a
inpRef :: Index rs a -> BVar s rs a
inpRefs :: Known Length rs => Prod (BVar s rs) rs
bindRef :: Num a => BVar s rs a -> BP s rs (BVar s rs a)
inpRefs' :: Length rs -> Prod (BVar s rs) rs
bindRef' :: Summer a -> BVar s rs a -> BP s rs (BVar s rs a)
opRef :: Num a => Prod (BVar s rs) as -> OpB s as a -> BP s rs (BVar s rs a)
(~$) :: Num a => OpB s as a -> Prod (BVar s rs) as -> BP s rs (BVar s rs a)
infixr 1 ~$
opRef1 :: Num b => BVar s rs a -> OpB s '[a] b -> BP s rs (BVar s rs b)
opRef2 :: Num c => BVar s rs a -> BVar s rs b -> OpB s '[a, b] c -> BP s rs (BVar s rs c)
opRef3 :: Num d => BVar s rs a -> BVar s rs b -> BVar s rs c -> OpB s '[a, b, c] d -> BP s rs (BVar s rs d)
(-$) :: (Every Num as, Known Length as, Num a) => BPOp s as a -> Prod (BVar s rs) as -> BPOp s rs a
infixr 1 -$
opRef' :: forall s rs as a. Summer a -> Prod (BVar s rs) as -> OpB s as a -> BP s rs (BVar s rs a)
opRef1' :: Summer b -> BVar s rs a -> OpB s '[a] b -> BP s rs (BVar s rs b)
opRef2' :: Summer c -> BVar s rs a -> BVar s rs b -> OpB s '[a, b] c -> BP s rs (BVar s rs c)
opRef3' :: Summer d -> BVar s rs a -> BVar s rs b -> BVar s rs c -> OpB s '[a, b, c] d -> BP s rs (BVar s rs d)
partsRef :: forall s rs bs b. (Every Num bs, Known Length bs) => Iso' b (Tuple bs) -> BVar s rs b -> BP s rs (Prod (BVar s rs) bs)
(#<~) :: (Every Num bs, Known Length bs) => Iso' b (Tuple bs) -> BVar s rs b -> BP s rs (Prod (BVar s rs) bs)
infixr 1 #<~
withParts :: (Every Num bs, Known Length bs) => Iso' b (Tuple bs) -> BVar s rs b -> (Prod (BVar s rs) bs -> BP s rs a) -> BP s rs a
splitRefs :: forall s rs as. (Every Num as, Known Length as) => BVar s rs (Tuple as) -> BP s rs (Prod (BVar s rs) as)
gSplit :: (Every Num bs, Known Length bs, Generic b, Code b ~ '[bs]) => BVar s rs b -> BP s rs (Prod (BVar s rs) bs)
partsRef' :: forall s rs bs b. Prod Summer bs -> Prod Unity bs -> Iso' b (Tuple bs) -> BVar s rs b -> BP s rs (Prod (BVar s rs) bs)
withParts' :: Prod Summer bs -> Prod Unity bs -> Iso' b (Tuple bs) -> BVar s rs b -> (Prod (BVar s rs) bs -> BP s rs a) -> BP s rs a
splitRefs' :: forall s rs as. Prod Summer as -> Prod Unity as -> BVar s rs (Tuple as) -> BP s rs (Prod (BVar s rs) as)
gSplit' :: (Generic b, Code b ~ '[bs]) => Prod Summer bs -> Prod Unity bs -> BVar s rs b -> BP s rs (Prod (BVar s rs) bs)
choicesRef :: forall s rs bs b. (Every Num bs, Known Length bs) => Iso' b (Sum I bs) -> BVar s rs b -> BP s rs (Sum (BVar s rs) bs)
choicesRef' :: forall s rs bs b. Prod Summer bs -> Prod Unity bs -> Iso' b (Sum I bs) -> BVar s rs b -> BP s rs (Sum (BVar s rs) bs)
sopRef :: forall s rs bss b. (Known Length bss, Every (Every Num ∧ Known Length) bss) => Iso' b (Sum Tuple bss) -> BVar s rs b -> BP s rs (Sum (Prod (BVar s rs)) bss)
gSplits :: forall s rs b. (Generic b, Known Length (Code b), Every (Every Num ∧ Known Length) (Code b)) => BVar s rs b -> BP s rs (Sum (Prod (BVar s rs)) (Code b))
sopRef' :: forall s rs bss b. Prod (Prod Summer) bss -> Prod (Prod Unity) bss -> Iso' b (Sum Tuple bss) -> BVar s rs b -> BP s rs (Sum (Prod (BVar s rs)) bss)
gSplits' :: forall s rs b. Generic b => Prod (Prod Summer) (Code b) -> Prod (Prod Unity) (Code b) -> BVar s rs b -> BP s rs (Sum (Prod (BVar s rs)) (Code b))
internally :: forall s rs bs b a. (Every Num bs, Known Length bs, Num a) => Iso' b (Tuple bs) -> BVar s rs b -> BP s bs (BVar s bs a) -> BP s rs (BVar s rs a)
generically :: forall s rs bs b a. (Num a, Every Num bs, Known Length bs, Generic b, Code b ~ '[bs]) => BVar s rs b -> BP s bs (BVar s bs a) -> BP s rs (BVar s rs a)
internally' :: forall s rs bs b a. Prod Summer bs -> Prod Unity bs -> Summer a -> Iso' b (Tuple bs) -> BVar s rs b -> BP s bs (BVar s bs a) -> BP s rs (BVar s rs a)
generically' :: forall s rs bs b a. (Generic b, Code b ~ '[bs]) => Prod Summer bs -> Prod Unity bs -> Summer a -> BVar s rs b -> BP s bs (BVar s bs a) -> BP s rs (BVar s rs a)
liftR :: OpB s as a -> Prod (BVar s rs) as -> BVar s rs a
liftR1 :: OpB s '[a] b -> BVar s rs a -> BVar s rs b
liftR2 :: OpB s '[a, b] c -> BVar s rs a -> BVar s rs b -> BVar s rs c
liftR3 :: OpB s '[a, b, c] d -> BVar s rs a -> BVar s rs b -> BVar s rs c -> BVar s rs d
op1 :: Num a => (forall s. AD s (Forward a) -> AD s (Forward a)) -> Op '[a] a
op2 :: Num a => (forall s. Reifies s Tape => Reverse s a -> Reverse s a -> Reverse s a) -> Op '[a, a] a
op3 :: Num a => (forall s. Reifies s Tape => Reverse s a -> Reverse s a -> Reverse s a -> Reverse s a) -> Op '[a, a, a] a
opN :: (Num a, Known Nat n) => (forall s. Reifies s Tape => Vec n (Reverse s a) -> Reverse s a) -> Op (Replicate n a) a
op1' :: (a -> (b, Maybe b -> a)) -> Op '[a] b
op2' :: (a -> b -> (c, Maybe c -> (a, b))) -> Op '[a, b] c
op3' :: (a -> b -> c -> (d, Maybe d -> (a, b, c))) -> Op '[a, b, c] d
opN' :: (Known Nat n) => (Vec n a -> (b, Maybe b -> Vec n a)) -> Op (Replicate n a) b
data Prod k (f :: k -> *) (a :: [k]) :: forall k. (k -> *) -> [k] -> *
[Ø] :: Prod k f ([] k)
[:<] :: Prod k f ((:) k a1 as)

-- | Construct a two element Prod. Since the precedence of (:&gt;) is
--   higher than (:&lt;), we can conveniently write lists like:
--   
--   <pre>
--   &gt;&gt;&gt; a :&lt; b :&gt; c
--   </pre>
--   
--   Which is identical to:
--   
--   <pre>
--   &gt;&gt;&gt; a :&lt; b :&lt; c :&lt; Ø
--   </pre>
infix 6 :>

-- | Build a singleton Prod.
only :: f a -> Prod k f ((:) k a ([] k))
head' :: Prod k f ((:<) k a as) -> f a

-- | A Prod of simple Haskell types.
type Tuple = Prod * I

-- | Cons onto a Tuple.
infixr 5 ::<

-- | Singleton Tuple.
only_ :: a -> Tuple ((:) * a ([] *))

-- | Instructions on how to "sum" a list of values of a given type.
--   Basically used as an explicit witness for a <a>Num</a> instance.
--   
--   For most types, the only meaningful value of type <tt><a>Summer</a>
--   a</tt> is <tt><a>Summer</a> <a>sum</a></tt>. However, using
--   <a>Summer</a> lets us use <tt>BP</tt> with types that are <i>not</i>
--   instances of <a>Num</a>. Any type can be used, as long as you provide
--   a way to "sum" it!
--   
--   For most of the functions in this library, you can completely ignore
--   this, as they will be generated automatically. You only need to work
--   with this directly if you want to use custom types that <i>aren't</i>
--   instances of <a>Num</a> with this library.
--   
--   If 'Num a' is satisfied, one can create the canonical <a>Summer</a>
--   using <tt><a>known</a> :: <a>Num</a> a =&gt; <a>Summer</a> a</tt>.
newtype Summer a
Summer :: ([a] -> a) -> Summer a
[runSummer] :: Summer a -> [a] -> a

-- | If all the types in <tt>as</tt> are instances of <a>Num</a>, generate
--   a <tt><a>Prod</a> <a>Summer</a> as</tt>, or a tuple of <a>Summer</a>s
--   for every type in <tt>as</tt>.
summers :: (Every Num as, Known Length as) => Prod Summer as

-- | Like <a>summers</a>, but requiring an explicit witness for the number
--   of types in the list <tt>as</tt>.
summers' :: Every Num as => Length as -> Prod Summer as

-- | A canonical "unity" (the multiplicative identity) for a given type.
--   Basically used as an explicit witness for a <a>Num</a> instance.
--   
--   For most types, the only meaningful value of type <tt><a>Unity</a>
--   a</tt> is <tt><a>Unity</a> 1'</tt>. However, using <a>Unity</a> lets
--   us use <tt>BP</tt> with types that are <i>not</i> instances of
--   <a>Num</a>. Any type can be used, as long as you provide a way to get
--   a multiplicative identity in it!
--   
--   For most of the functions in this library, you can completely ignore
--   this, as they will be generated automatically. You only need to work
--   with this directly if you want to use custom types that <i>aren't</i>
--   instances of <a>Num</a> with this library.
--   
--   If 'Num a' is satisfied, one can create the canonical <a>Unity</a>
--   using <tt><a>known</a> :: <a>Num</a> a =&gt; <a>Unity</a> a</tt>.
newtype Unity a
Unity :: a -> Unity a
[getUnity] :: Unity a -> a

-- | If all the types in <tt>as</tt> are instances of <a>Num</a>, generate
--   a <tt><a>Prod</a> <a>Unity</a> as</tt>, or a tuple of <a>Unity</a>s
--   for every type in <tt>as</tt>.
unities :: (Every Num as, Known Length as) => Prod Unity as

-- | Like <a>unities</a>, but requiring an explicit witness for the number
--   of types in the list <tt>as</tt>.
unities' :: Every Num as => Length as -> Prod Unity as

module Numeric.Backprop.Implicit

-- | The basic unit of manipulation inside <a>BP</a>. Instead of directly
--   working with values, you work with <a>BVar</a>s contating those
--   values. When you work with a <a>BVar</a>, the <i>backprop</i> library
--   can keep track of what values refer to which other values, and so can
--   perform backpropagation to compute gradients.
--   
--   A <tt><a>BVar</a> s rs a</tt> refers to a value of type <tt>a</tt>,
--   with an environment of values of the types <tt>rs</tt>. The phantom
--   parameter <tt>s</tt> is used to ensure that stray <a>BVar</a>s don't
--   leak outside of the backprop process.
--   
--   (That is, if you're using implicit backprop, it ensures that you
--   interact with <a>BVar</a>s in a polymorphic way. And, if you're using
--   implicit backprop, it ensures that a <tt><a>BVar</a> s rs a</tt> never
--   leaves the <tt><a>BP</a> s rs</tt> that it was created in.)
--   
--   <a>BVar</a>s have <a>Num</a>, <a>Fractional</a>, <a>Floating</a>, etc.
--   instances, so they can be manipulated using polymorphic functions and
--   numeric functions in Haskell. You can add them, subtract them, etc.,
--   in "implicit" backprop style.
--   
--   (However, note that if you directly manipulate <a>BVar</a>s using
--   those instances or using <tt>liftR</tt>, it delays evaluation, so
--   every usage site has to re-compute the result/create a new node. If
--   you want to re-use a <a>BVar</a> you created using '(+)' or '(-)' or
--   <tt>liftR</tt>, use <tt>bindRef</tt> to force it first.)
data BVar :: Type -> [Type] -> Type -> Type
type BPOp rs a = forall s. Prod (BVar s rs) rs -> BVar s rs a

-- | An <tt><a>Op</a> as a</tt> is a type synonym over <a>OpM</a> that
--   describes a differentiable function from <tt>as</tt> to <tt>a</tt>.
--   
--   For example, an
--   
--   <pre>
--   <a>Op</a> '[Int, Bool] Double
--   </pre>
--   
--   is a function from an <a>Int</a> and a <a>Bool</a>, returning a
--   <a>Double</a>. It can be differentiated to give a <i>gradient</i> of
--   an <a>Int</a> and a <a>Bool</a> if given a total derivative for
--   <tt>a</tt>.
--   
--   See <a>runOp</a>, <a>gradOp</a>, and <a>gradOpWith</a> for examples on
--   how to run it, and <a>Op</a> for instructions on creating it.
--   
--   This type is abstracted over using the pattern synonym with
--   constructor <a>Op</a>, so you can create one from scratch with it.
--   However, it's simplest to create it using <a>op2'</a>, <a>op1'</a>,
--   <a>op2'</a>, <a>op3'</a>, and <a>opN'</a> helper smart constructors
--   And, if your function is a numeric function, they can even be created
--   automatically using <a>op1</a>, <a>op2</a>, <a>op3</a>, and <a>opN</a>
--   with a little help from <a>Numeric.AD</a> from the <i>ad</i> library.
--   
--   Note that this type is a subset/subtype of <a>OpM</a>. So, if a
--   function ever expects an <tt><a>OpM</a> m as a</tt>, you can always
--   provide an <tt><a>Op</a> as a</tt> instead.
--   
--   Many functions in this library will expect an <tt><a>OpM</a> m as
--   a</tt> (or an <tt><a>OpB</a> s as a</tt>), and in all of these cases,
--   you can provide an <tt><a>Op</a> as a</tt>.
type Op as a = forall m. Monad m => OpM m as a

-- | A type synonym for <a>OpM</a> specialized to what the <i>backprop</i>
--   library uses to perform backpropagation.
--   
--   An
--   
--   <pre>
--   <a>OpB</a> s rs a
--   </pre>
--   
--   represents a differentiable function that takes a tuple of <tt>rs</tt>
--   and produces an a <tt>a</tt>, which can be run on <tt><a>BVar</a>
--   s</tt> and also inside <tt><a>BP</a> s</tt>s. For example, an
--   <tt><a>OpB</a> s '[ Int, Double ] Bool</tt> takes an <a>Int</a> and a
--   <a>Double</a> and produces a <a>Bool</a>, and does it in a
--   differentiable way.
--   
--   Note that <a>OpB</a> is a <i>superset</i> of <a>Op</a>, so, if you see
--   any function that expects an <a>OpB</a> (like <a>opRef'</a> and
--   <a>~$</a>, for example), you can give them an <a>Op</a>, as well.
--   
--   You can think of <a>OpB</a> as a superclass/parent class of <a>Op</a>
--   in this sense, and of <a>Op</a> as a subclass of <a>OpB</a>.
type OpB s as a = OpM (ST s) as a
backprop :: (Known Length rs, Every Num rs) => BPOp rs a -> Tuple rs -> (a, Tuple rs)
grad :: (Known Length rs, Every Num rs) => BPOp rs a -> Tuple rs -> Tuple rs
eval :: (Known Length rs, Every Num rs) => BPOp rs a -> Tuple rs -> a
backprop' :: Prod Summer rs -> Prod Unity rs -> BPOp rs a -> Tuple rs -> (a, Tuple rs)
grad' :: Prod Summer rs -> Prod Unity rs -> BPOp rs a -> Tuple rs -> Tuple rs
eval' :: Prod Summer rs -> Prod Unity rs -> BPOp rs a -> Tuple rs -> a
constRef :: a -> BVar s rs a
liftR :: OpB s as a -> Prod (BVar s rs) as -> BVar s rs a
liftR1 :: OpB s '[a] b -> BVar s rs a -> BVar s rs b
liftR2 :: OpB s '[a, b] c -> BVar s rs a -> BVar s rs b -> BVar s rs c
liftR3 :: OpB s '[a, b, c] d -> BVar s rs a -> BVar s rs b -> BVar s rs c -> BVar s rs d
partsRef :: forall s rs bs a. (Known Length bs, Every Num bs) => Iso' a (Tuple bs) -> BVar s rs a -> Prod (BVar s rs) bs
withParts :: forall s rs bs a r. (Known Length bs, Every Num bs) => Iso' a (Tuple bs) -> BVar s rs a -> (Prod (BVar s rs) bs -> r) -> r
splitRefs :: forall s rs as. (Known Length as, Every Num as) => BVar s rs (Tuple as) -> Prod (BVar s rs) as
gSplit :: forall s rs as a. (Generic a, Code a ~ '[as], Known Length as, Every Num as) => BVar s rs a -> Prod (BVar s rs) as
partsRef' :: forall s rs bs a. Prod Summer bs -> Prod Unity bs -> Iso' a (Tuple bs) -> BVar s rs a -> Prod (BVar s rs) bs
withParts' :: forall s rs bs a r. Prod Summer bs -> Prod Unity bs -> Iso' a (Tuple bs) -> BVar s rs a -> (Prod (BVar s rs) bs -> r) -> r
splitRefs' :: forall s rs as. Prod Summer as -> Prod Unity as -> BVar s rs (Tuple as) -> Prod (BVar s rs) as
gSplit' :: forall s rs as a. (Generic a, Code a ~ '[as]) => Prod Summer as -> Prod Unity as -> BVar s rs a -> Prod (BVar s rs) as
op1 :: Num a => (forall s. AD s (Forward a) -> AD s (Forward a)) -> Op '[a] a
op2 :: Num a => (forall s. Reifies s Tape => Reverse s a -> Reverse s a -> Reverse s a) -> Op '[a, a] a
op3 :: Num a => (forall s. Reifies s Tape => Reverse s a -> Reverse s a -> Reverse s a -> Reverse s a) -> Op '[a, a, a] a
opN :: (Num a, Known Nat n) => (forall s. Reifies s Tape => Vec n (Reverse s a) -> Reverse s a) -> Op (Replicate n a) a
op1' :: (a -> (b, Maybe b -> a)) -> Op '[a] b
op2' :: (a -> b -> (c, Maybe c -> (a, b))) -> Op '[a, b] c
op3' :: (a -> b -> c -> (d, Maybe d -> (a, b, c))) -> Op '[a, b, c] d
opN' :: (Known Nat n) => (Vec n a -> (b, Maybe b -> Vec n a)) -> Op (Replicate n a) b
data Prod k (f :: k -> *) (a :: [k]) :: forall k. (k -> *) -> [k] -> *
[Ø] :: Prod k f ([] k)
[:<] :: Prod k f ((:) k a1 as)

-- | Construct a two element Prod. Since the precedence of (:&gt;) is
--   higher than (:&lt;), we can conveniently write lists like:
--   
--   <pre>
--   &gt;&gt;&gt; a :&lt; b :&gt; c
--   </pre>
--   
--   Which is identical to:
--   
--   <pre>
--   &gt;&gt;&gt; a :&lt; b :&lt; c :&lt; Ø
--   </pre>
infix 6 :>

-- | Build a singleton Prod.
only :: f a -> Prod k f ((:) k a ([] k))
head' :: Prod k f ((:<) k a as) -> f a

-- | A Prod of simple Haskell types.
type Tuple = Prod * I

-- | Cons onto a Tuple.
infixr 5 ::<

-- | Singleton Tuple.
only_ :: a -> Tuple ((:) * a ([] *))

-- | Instructions on how to "sum" a list of values of a given type.
--   Basically used as an explicit witness for a <a>Num</a> instance.
--   
--   For most types, the only meaningful value of type <tt><a>Summer</a>
--   a</tt> is <tt><a>Summer</a> <a>sum</a></tt>. However, using
--   <a>Summer</a> lets us use <tt>BP</tt> with types that are <i>not</i>
--   instances of <a>Num</a>. Any type can be used, as long as you provide
--   a way to "sum" it!
--   
--   For most of the functions in this library, you can completely ignore
--   this, as they will be generated automatically. You only need to work
--   with this directly if you want to use custom types that <i>aren't</i>
--   instances of <a>Num</a> with this library.
--   
--   If 'Num a' is satisfied, one can create the canonical <a>Summer</a>
--   using <tt><a>known</a> :: <a>Num</a> a =&gt; <a>Summer</a> a</tt>.
newtype Summer a
Summer :: ([a] -> a) -> Summer a
[runSummer] :: Summer a -> [a] -> a

-- | A canonical "unity" (the multiplicative identity) for a given type.
--   Basically used as an explicit witness for a <a>Num</a> instance.
--   
--   For most types, the only meaningful value of type <tt><a>Unity</a>
--   a</tt> is <tt><a>Unity</a> 1'</tt>. However, using <a>Unity</a> lets
--   us use <tt>BP</tt> with types that are <i>not</i> instances of
--   <a>Num</a>. Any type can be used, as long as you provide a way to get
--   a multiplicative identity in it!
--   
--   For most of the functions in this library, you can completely ignore
--   this, as they will be generated automatically. You only need to work
--   with this directly if you want to use custom types that <i>aren't</i>
--   instances of <a>Num</a> with this library.
--   
--   If 'Num a' is satisfied, one can create the canonical <a>Unity</a>
--   using <tt><a>known</a> :: <a>Num</a> a =&gt; <a>Unity</a> a</tt>.
newtype Unity a
Unity :: a -> Unity a
[getUnity] :: Unity a -> a

-- | If all the types in <tt>as</tt> are instances of <a>Num</a>, generate
--   a <tt><a>Prod</a> <a>Summer</a> as</tt>, or a tuple of <a>Summer</a>s
--   for every type in <tt>as</tt>.
summers :: (Every Num as, Known Length as) => Prod Summer as

-- | If all the types in <tt>as</tt> are instances of <a>Num</a>, generate
--   a <tt><a>Prod</a> <a>Unity</a> as</tt>, or a tuple of <a>Unity</a>s
--   for every type in <tt>as</tt>.
unities :: (Every Num as, Known Length as) => Prod Unity as

-- | Like <a>summers</a>, but requiring an explicit witness for the number
--   of types in the list <tt>as</tt>.
summers' :: Every Num as => Length as -> Prod Summer as

-- | Like <a>unities</a>, but requiring an explicit witness for the number
--   of types in the list <tt>as</tt>.
unities' :: Every Num as => Length as -> Prod Unity as

module Numeric.Backprop.Op.Mono
type Op n a b = Op (Replicate n a) b
runOp' :: Op n a b -> Vec n a -> (b, Maybe b -> Vec n a)
runOp :: Op n a b -> Vec n a -> b
gradOp :: Op n a b -> Vec n a -> Vec n a
gradOpWith :: Op n a b -> Vec n a -> b -> Vec n a
gradOpWith' :: Op n a b -> Vec n a -> Maybe b -> Vec n a
op1 :: Num a => (forall s. AD s (Forward a) -> AD s (Forward a)) -> Op N1 a a
op2 :: Num a => (forall s. Reifies s Tape => Reverse s a -> Reverse s a -> Reverse s a) -> Op N2 a a
op3 :: Num a => (forall s. Reifies s Tape => Reverse s a -> Reverse s a -> Reverse s a -> Reverse s a) -> Op N3 a a
opN :: (Num a, Known Nat n) => (forall s. Reifies s Tape => Vec n (Reverse s a) -> Reverse s a) -> Op n a a

-- | Convenient aliases for low-value Peano numbers.
type N0 = Z
type N1 = S N0
type N2 = S N1
type N3 = S N2
type N4 = S N3
type N5 = S N4
type N6 = S N5
type N7 = S N6
type N8 = S N7
type N9 = S N8
type N10 = S N9
data VecT k (n :: N) (f :: k -> *) (a :: k) :: forall k. N -> (k -> *) -> k -> *
[ØV] :: VecT k Z f a
[:*] :: VecT k (S n1) f a
type Vec (n :: N) = VecT * n I
infixr 4 :+
(*:) :: f a -> f a -> VecT k (S (S Z)) f a
infix 5 *:
(+:) :: a -> a -> Vec (S (S Z)) a
infix 5 +:
head' :: VecT k (S n) f a -> f a

module Numeric.Backprop.Mono
type BP s n a = BP s (Replicate n a)
type BPOp s n a b = BP s n a (BVar s n a b)
type BVar s n a = BVar s (Replicate n a)
type Op n a b = Op (Replicate n a) b
backprop :: forall n a b. Num a => (forall s. BPOp s n a b) -> Vec n a -> (b, Vec n a)
evalBPOp :: forall n a b. Num a => (forall s. BPOp s n a b) -> Vec n a -> b
gradBPOp :: forall n a b. Num a => (forall s. BPOp s n a b) -> Vec n a -> Vec n a
bpOp :: forall s n a b. BPOp s n a b -> OpB s n a b
withInps :: Known Nat n => (VecT n (BVar s n a) a -> BP s n a b) -> BP s n a b
implicitly :: Known Nat n => BPOpI s n a b -> BPOp s n a b
constRef :: b -> BVar s n a b
inpRef :: Fin n -> BVar s n a a
inpRefs :: Known Nat n => VecT n (BVar s n a) a
opRef :: forall s m n a b. Num b => VecT m (BVar s n a) a -> OpB s m a b -> BP s n a (BVar s n a b)
(~$) :: Num b => OpB s m a b -> VecT m (BVar s n a) a -> BP s n a (BVar s n a b)
infixr 1 ~$
opRef1 :: forall s n a b. Num b => BVar s n a a -> OpB s N1 a b -> BP s n a (BVar s n a b)
opRef2 :: forall s n a b. Num b => BVar s n a a -> BVar s n a a -> OpB s N2 a b -> BP s n a (BVar s n a b)
opRef3 :: forall s n a b. Num b => BVar s n a a -> BVar s n a a -> BVar s n a a -> OpB s N3 a b -> BP s n a (BVar s n a b)
(-$) :: forall s m n a b. Num b => BPOp s m a b -> VecT m (BVar s n a) a -> BP s n a (BVar s n a b)
infixr 1 -$
liftR :: OpB s m a b -> VecT m (BVar s n r) a -> BVar s n r b
liftR1 :: OpB s N1 a a -> BVar s n r a -> BVar s n r a
liftR2 :: OpB s N2 a a -> BVar s n r a -> BVar s n r a -> BVar s n r a
liftR3 :: OpB s N3 a a -> BVar s n r a -> BVar s n r a -> BVar s n r a -> BVar s n r a
op1 :: Num a => (forall s. AD s (Forward a) -> AD s (Forward a)) -> Op N1 a a
op2 :: Num a => (forall s. Reifies s Tape => Reverse s a -> Reverse s a -> Reverse s a) -> Op N2 a a
op3 :: Num a => (forall s. Reifies s Tape => Reverse s a -> Reverse s a -> Reverse s a -> Reverse s a) -> Op N3 a a
opN :: (Num a, Known Nat n) => (forall s. Reifies s Tape => Vec n (Reverse s a) -> Reverse s a) -> Op n a a

-- | Convenient aliases for low-value Peano numbers.
type N0 = Z
type N1 = S N0
type N2 = S N1
type N3 = S N2
type N4 = S N3
type N5 = S N4
type N6 = S N5
type N7 = S N6
type N8 = S N7
type N9 = S N8
type N10 = S N9
data VecT k (n :: N) (f :: k -> *) (a :: k) :: forall k. N -> (k -> *) -> k -> *
[ØV] :: VecT k Z f a
[:*] :: VecT k (S n1) f a
type Vec (n :: N) = VecT * n I
infixr 4 :+
(*:) :: f a -> f a -> VecT k (S (S Z)) f a
infix 5 *:
(+:) :: a -> a -> Vec (S (S Z)) a
infix 5 +:
head' :: VecT k (S n) f a -> f a

module Numeric.Backprop.Mono.Implicit
type BVar s n a = BVar s (Replicate n a)
type BPOp n a b = forall s. VecT n (BVar s n a) a -> BVar s n a b
type Op n a b = Op (Replicate n a) b
backprop :: forall n a b. (Num a, Known Nat n) => BPOp n a b -> Vec n a -> (b, Vec n a)
grad :: forall n a b. (Num a, Known Nat n) => BPOp n a b -> Vec n a -> Vec n a
eval :: forall n a b. (Num a, Known Nat n) => BPOp n a b -> Vec n a -> b
constRef :: b -> BVar s n a b
liftR :: OpB s m a b -> VecT m (BVar s n r) a -> BVar s n r b
liftR1 :: OpB s N1 a a -> BVar s n r a -> BVar s n r a
liftR2 :: OpB s N2 a a -> BVar s n r a -> BVar s n r a -> BVar s n r a
liftR3 :: OpB s N3 a a -> BVar s n r a -> BVar s n r a -> BVar s n r a -> BVar s n r a
op1 :: Num a => (forall s. AD s (Forward a) -> AD s (Forward a)) -> Op N1 a a
op2 :: Num a => (forall s. Reifies s Tape => Reverse s a -> Reverse s a -> Reverse s a) -> Op N2 a a
op3 :: Num a => (forall s. Reifies s Tape => Reverse s a -> Reverse s a -> Reverse s a -> Reverse s a) -> Op N3 a a
opN :: (Num a, Known Nat n) => (forall s. Reifies s Tape => Vec n (Reverse s a) -> Reverse s a) -> Op n a a

-- | Convenient aliases for low-value Peano numbers.
type N0 = Z
type N1 = S N0
type N2 = S N1
type N3 = S N2
type N4 = S N3
type N5 = S N4
type N6 = S N5
type N7 = S N6
type N8 = S N7
type N9 = S N8
type N10 = S N9
data VecT k (n :: N) (f :: k -> *) (a :: k) :: forall k. N -> (k -> *) -> k -> *
[ØV] :: VecT k Z f a
[:*] :: VecT k (S n1) f a
type Vec (n :: N) = VecT * n I
infixr 4 :+
(*:) :: f a -> f a -> VecT k (S (S Z)) f a
infix 5 *:
(+:) :: a -> a -> Vec (S (S Z)) a
infix 5 +:
head' :: VecT k (S n) f a -> f a

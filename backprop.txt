-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package backprop
@version 0.1.0.0

module Numeric.Backprop.Iso
type Iso s t a b = forall p f. (Profunctor p, Functor f) => p a (f b) -> p s (f t)
type Iso' s a = Iso s s a a
iso :: (s -> a) -> (b -> t) -> Iso s t a b
re :: Iso' s a -> Iso' a s
review :: Iso s t a b -> b -> t
coercible :: Coercible s a => Iso' s a
gTuple :: (Generic a, Code a ~ '[as]) => Iso' a (Tuple as)
gSOP :: Generic a => Iso' a (Sum Tuple (Code a))
sum1 :: Iso' (Sum f '[a]) (f a)
resum1 :: Iso' (f a) (Sum f '[a])

module Numeric.Backprop.Op
newtype Op as a
Op :: (Tuple as -> (a, Maybe a -> Tuple as)) -> Op as a
[runOp'] :: Op as a -> Tuple as -> (a, Maybe a -> Tuple as)
runOp :: Op as a -> Tuple as -> a
gradOp :: Op as a -> Tuple as -> Tuple as
gradOpWith :: Op as a -> Tuple as -> a -> Tuple as
gradOpWith' :: Op as a -> Tuple as -> Maybe a -> Tuple as
composeOp :: Prod Summer as -> Prod (Op as) bs -> Op bs c -> Op as c
op0 :: a -> Op '[] a
op1 :: Num a => (forall s. AD s (Forward a) -> AD s (Forward a)) -> Op '[a] a
op2 :: Num a => (forall s. Reifies s Tape => Reverse s a -> Reverse s a -> Reverse s a) -> Op '[a, a] a
op3 :: Num a => (forall s. Reifies s Tape => Reverse s a -> Reverse s a -> Reverse s a -> Reverse s a) -> Op '[a, a, a] a
opN :: (Num a, Known Nat n) => (forall s. Reifies s Tape => Vec n (Reverse s a) -> Reverse s a) -> Op (Replicate n a) a
opCoerce :: (Coercible a b, Num a) => Op '[a] b
opTup :: (Every Num as, Known Length as) => Op as (Tuple as)
opIso :: Num a => Iso' a b -> Op '[a] b
op1' :: (a -> (b, Maybe b -> a)) -> Op '[a] b
op2' :: (a -> b -> (c, Maybe c -> (a, b))) -> Op '[a, b] c
op3' :: (a -> b -> c -> (d, Maybe d -> (a, b, c))) -> Op '[a, b, c] d
opN' :: (Known Nat n) => (Vec n a -> (b, Maybe b -> Vec n a)) -> Op (Replicate n a) b
opCoerce' :: Coercible a b => Unity a -> Op '[a] b
opTup' :: Prod Unity as -> Op as (Tuple as)
opIso' :: Unity a -> Iso' a b -> Op '[a] b

module Numeric.Backprop
data BP s rs b
type BPOp s rs a = BP s rs (BPRef s rs a)
data BPRef :: Type -> [Type] -> Type -> Type
newtype Op as a
Op :: (Tuple as -> (a, Maybe a -> Tuple as)) -> Op as a
[runOp'] :: Op as a -> Tuple as -> (a, Maybe a -> Tuple as)
newtype Summer a
Summer :: ([a] -> a) -> Summer a
[runSummer] :: Summer a -> [a] -> a
newtype Unity a
Unity :: a -> Unity a
[getUnity] :: Unity a -> a
backprop :: forall rs a. Every Num rs => (forall s. BPOp s rs a) -> Tuple rs -> (a, Tuple rs)
evalBPOp :: Every Num rs => (forall s. BPOp s rs a) -> Tuple rs -> a
gradBPOp :: Every Num rs => (forall s. BPOp s rs a) -> Tuple rs -> Tuple rs
backprop' :: Prod Summer rs -> Prod Unity rs -> (forall s. BPOp s rs a) -> Tuple rs -> (a, Tuple rs)
evalBPOp' :: Prod Summer rs -> Prod Unity rs -> (forall s. BPOp s rs a) -> Tuple rs -> a
gradBPOp' :: Prod Summer rs -> Prod Unity rs -> (forall s. BPOp s rs a) -> Tuple rs -> Tuple rs
withInps :: Known Length rs => (Prod (BPRef s rs) rs -> BP s rs a) -> BP s rs a
plugBP :: forall s rs as a. (Every Num as, Num a) => Prod (BPRef s rs) as -> BPOp s as a -> BPOp s rs a
(~$) :: (Every Num as, Num a) => BPOp s as a -> Prod (BPRef s rs) as -> BPOp s rs a
infixr 1 ~$
($~) :: (Every Num as, Num a) => Prod (BPRef s rs) as -> (Prod (BPRef s as) as -> BPOp s as a) -> BPOp s rs a
infixr 1 $~
withInps' :: Length rs -> (Prod (BPRef s rs) rs -> BP s rs a) -> BP s rs a
plugBP' :: Prod (BPRef s rs) as -> Prod Summer as -> Prod Unity as -> Summer a -> BPOp s as a -> BPOp s rs a
constRef :: a -> BPRef s rs a
inpRef :: Index rs a -> BPRef s rs a
inpRefs :: Known Length rs => Prod (BPRef s rs) rs
bindRef :: Num a => BPRef s rs a -> BP s rs (BPRef s rs a)
inpRefs' :: Length rs -> Prod (BPRef s rs) rs
bindRef' :: Summer a -> BPRef s rs a -> BP s rs (BPRef s rs a)
opRef :: Num a => Prod (BPRef s rs) as -> Op as a -> BP s rs (BPRef s rs a)
(-$) :: Num a => Op as a -> Prod (BPRef s rs) as -> BP s rs (BPRef s rs a)
infixr 1 -$
opRef1 :: Num b => BPRef s rs a -> Op '[a] b -> BP s rs (BPRef s rs b)
opRef2 :: Num c => BPRef s rs a -> BPRef s rs b -> Op '[a, b] c -> BP s rs (BPRef s rs c)
opRef3 :: Num d => BPRef s rs a -> BPRef s rs b -> BPRef s rs c -> Op '[a, b, c] d -> BP s rs (BPRef s rs d)
opRef' :: forall s rs as a. Summer a -> Prod (BPRef s rs) as -> Op as a -> BP s rs (BPRef s rs a)
opRef1' :: Summer b -> BPRef s rs a -> Op '[a] b -> BP s rs (BPRef s rs b)
opRef2' :: Summer c -> BPRef s rs a -> BPRef s rs b -> Op '[a, b] c -> BP s rs (BPRef s rs c)
opRef3' :: Summer d -> BPRef s rs a -> BPRef s rs b -> BPRef s rs c -> Op '[a, b, c] d -> BP s rs (BPRef s rs d)
partsRef :: forall s rs bs b. (Every Num bs, Known Length bs) => Iso' b (Tuple bs) -> BPRef s rs b -> BP s rs (Prod (BPRef s rs) bs)
(#<~) :: (Every Num bs, Known Length bs) => Iso' b (Tuple bs) -> BPRef s rs b -> BP s rs (Prod (BPRef s rs) bs)
infixr 1 #<~
withParts :: (Every Num bs, Known Length bs) => Iso' b (Tuple bs) -> BPRef s rs b -> (Prod (BPRef s rs) bs -> BP s rs a) -> BP s rs a
splitRefs :: forall s rs as. (Every Num as, Known Length as) => BPRef s rs (Tuple as) -> BP s rs (Prod (BPRef s rs) as)
gSplit :: (Every Num bs, Known Length bs, Generic b, Code b ~ '[bs]) => BPRef s rs b -> BP s rs (Prod (BPRef s rs) bs)
partsRef' :: forall s rs bs b. Prod Summer bs -> Prod Unity bs -> Iso' b (Tuple bs) -> BPRef s rs b -> BP s rs (Prod (BPRef s rs) bs)
withParts' :: Prod Summer bs -> Prod Unity bs -> Iso' b (Tuple bs) -> BPRef s rs b -> (Prod (BPRef s rs) bs -> BP s rs a) -> BP s rs a
splitRefs' :: forall s rs as. Prod Summer as -> Prod Unity as -> BPRef s rs (Tuple as) -> BP s rs (Prod (BPRef s rs) as)
gSplit' :: (Generic b, Code b ~ '[bs]) => Prod Summer bs -> Prod Unity bs -> BPRef s rs b -> BP s rs (Prod (BPRef s rs) bs)
choicesRef :: forall s rs bs b. (Every Num bs, Known Length bs) => Iso' b (Sum I bs) -> BPRef s rs b -> BP s rs (Sum (BPRef s rs) bs)
choicesRef' :: forall s rs bs b. Prod Summer bs -> Prod Unity bs -> Iso' b (Sum I bs) -> BPRef s rs b -> BP s rs (Sum (BPRef s rs) bs)
sopRef :: forall s rs bss b. (Known Length bss, Every (Every Num ∧ Known Length) bss) => Iso' b (Sum Tuple bss) -> BPRef s rs b -> BP s rs (Sum (Prod (BPRef s rs)) bss)
gSplits :: forall s rs b. (Generic b, Known Length (Code b), Every (Every Num ∧ Known Length) (Code b)) => BPRef s rs b -> BP s rs (Sum (Prod (BPRef s rs)) (Code b))
sopRef' :: forall s rs bss b. Prod (Prod Summer) bss -> Prod (Prod Unity) bss -> Iso' b (Sum Tuple bss) -> BPRef s rs b -> BP s rs (Sum (Prod (BPRef s rs)) bss)
gSplits' :: forall s rs b. Generic b => Prod (Prod Summer) (Code b) -> Prod (Prod Unity) (Code b) -> BPRef s rs b -> BP s rs (Sum (Prod (BPRef s rs)) (Code b))
internally :: forall s rs bs b a. (Every Num bs, Known Length bs, Num a) => Iso' b (Tuple bs) -> BPRef s rs b -> BP s bs (BPRef s bs a) -> BP s rs (BPRef s rs a)
generically :: forall s rs bs b a. (Num a, Every Num bs, Known Length bs, Generic b, Code b ~ '[bs]) => BPRef s rs b -> BP s bs (BPRef s bs a) -> BP s rs (BPRef s rs a)
internally' :: forall s rs bs b a. Prod Summer bs -> Prod Unity bs -> Summer a -> Iso' b (Tuple bs) -> BPRef s rs b -> BP s bs (BPRef s bs a) -> BP s rs (BPRef s rs a)
generically' :: forall s rs bs b a. (Generic b, Code b ~ '[bs]) => Prod Summer bs -> Prod Unity bs -> Summer a -> BPRef s rs b -> BP s bs (BPRef s bs a) -> BP s rs (BPRef s rs a)
liftR :: Op as a -> Prod (BPRef s rs) as -> BPRef s rs a
liftR1 :: Op '[a] b -> BPRef s rs a -> BPRef s rs b
liftR2 :: Op '[a, b] c -> BPRef s rs a -> BPRef s rs b -> BPRef s rs c
liftR3 :: Op '[a, b, c] d -> BPRef s rs a -> BPRef s rs b -> BPRef s rs c -> BPRef s rs d
op1 :: Num a => (forall s. AD s (Forward a) -> AD s (Forward a)) -> Op '[a] a
op2 :: Num a => (forall s. Reifies s Tape => Reverse s a -> Reverse s a -> Reverse s a) -> Op '[a, a] a
op3 :: Num a => (forall s. Reifies s Tape => Reverse s a -> Reverse s a -> Reverse s a -> Reverse s a) -> Op '[a, a, a] a
opN :: (Num a, Known Nat n) => (forall s. Reifies s Tape => Vec n (Reverse s a) -> Reverse s a) -> Op (Replicate n a) a
op1' :: (a -> (b, Maybe b -> a)) -> Op '[a] b
op2' :: (a -> b -> (c, Maybe c -> (a, b))) -> Op '[a, b] c
op3' :: (a -> b -> c -> (d, Maybe d -> (a, b, c))) -> Op '[a, b, c] d
opN' :: (Known Nat n) => (Vec n a -> (b, Maybe b -> Vec n a)) -> Op (Replicate n a) b
data Prod k (f :: k -> *) (a :: [k]) :: forall k. (k -> *) -> [k] -> *
[Ø] :: Prod k f ([] k)
[:<] :: Prod k f ((:) k a1 as)

-- | Construct a two element Prod. Since the precedence of (:&gt;) is
--   higher than (:&lt;), we can conveniently write lists like:
--   
--   <pre>
--   &gt;&gt;&gt; a :&lt; b :&gt; c
--   </pre>
--   
--   Which is identical to:
--   
--   <pre>
--   &gt;&gt;&gt; a :&lt; b :&lt; c :&lt; Ø
--   </pre>
infix 6 :>

-- | Build a singleton Prod.
only :: f a -> Prod k f ((:) k a ([] k))

-- | A Prod of simple Haskell types.
type Tuple = Prod * I

-- | Cons onto a Tuple.
infixr 5 ::<

-- | Singleton Tuple.
only_ :: a -> Tuple ((:) * a ([] *))

module Numeric.Backprop.Implicit
data BPRef :: Type -> [Type] -> Type -> Type
data Op as a
newtype Summer a
Summer :: ([a] -> a) -> Summer a
[runSummer] :: Summer a -> [a] -> a
newtype Unity a
Unity :: a -> Unity a
[getUnity] :: Unity a -> a
backprop :: (Known Length rs, Every Num rs) => (forall s. Prod (BPRef s rs) rs -> BPRef s rs a) -> Tuple rs -> (a, Tuple rs)
grad :: (Known Length rs, Every Num rs) => (forall s. Prod (BPRef s rs) rs -> BPRef s rs a) -> Tuple rs -> Tuple rs
eval :: (Known Length rs, Every Num rs) => (forall s. Prod (BPRef s rs) rs -> BPRef s rs a) -> Tuple rs -> a
backprop' :: Prod Summer rs -> Prod Unity rs -> (forall s. Prod (BPRef s rs) rs -> BPRef s rs a) -> Tuple rs -> (a, Tuple rs)
grad' :: Prod Summer rs -> Prod Unity rs -> (forall s. Prod (BPRef s rs) rs -> BPRef s rs a) -> Tuple rs -> Tuple rs
eval' :: Prod Summer rs -> Prod Unity rs -> (forall s. Prod (BPRef s rs) rs -> BPRef s rs a) -> Tuple rs -> a
constRef :: a -> BPRef s rs a
liftR :: Op as a -> Prod (BPRef s rs) as -> BPRef s rs a
liftR1 :: Op '[a] b -> BPRef s rs a -> BPRef s rs b
liftR2 :: Op '[a, b] c -> BPRef s rs a -> BPRef s rs b -> BPRef s rs c
liftR3 :: Op '[a, b, c] d -> BPRef s rs a -> BPRef s rs b -> BPRef s rs c -> BPRef s rs d
op1 :: Num a => (forall s. AD s (Forward a) -> AD s (Forward a)) -> Op '[a] a
op2 :: Num a => (forall s. Reifies s Tape => Reverse s a -> Reverse s a -> Reverse s a) -> Op '[a, a] a
op3 :: Num a => (forall s. Reifies s Tape => Reverse s a -> Reverse s a -> Reverse s a -> Reverse s a) -> Op '[a, a, a] a
opN :: (Num a, Known Nat n) => (forall s. Reifies s Tape => Vec n (Reverse s a) -> Reverse s a) -> Op (Replicate n a) a
op1' :: (a -> (b, Maybe b -> a)) -> Op '[a] b
op2' :: (a -> b -> (c, Maybe c -> (a, b))) -> Op '[a, b] c
op3' :: (a -> b -> c -> (d, Maybe d -> (a, b, c))) -> Op '[a, b, c] d
opN' :: (Known Nat n) => (Vec n a -> (b, Maybe b -> Vec n a)) -> Op (Replicate n a) b
data Prod k (f :: k -> *) (a :: [k]) :: forall k. (k -> *) -> [k] -> *
[Ø] :: Prod k f ([] k)
[:<] :: Prod k f ((:) k a1 as)

-- | Construct a two element Prod. Since the precedence of (:&gt;) is
--   higher than (:&lt;), we can conveniently write lists like:
--   
--   <pre>
--   &gt;&gt;&gt; a :&lt; b :&gt; c
--   </pre>
--   
--   Which is identical to:
--   
--   <pre>
--   &gt;&gt;&gt; a :&lt; b :&lt; c :&lt; Ø
--   </pre>
infix 6 :>

-- | Build a singleton Prod.
only :: f a -> Prod k f ((:) k a ([] k))

-- | A Prod of simple Haskell types.
type Tuple = Prod * I

-- | Cons onto a Tuple.
infixr 5 ::<

-- | Singleton Tuple.
only_ :: a -> Tuple ((:) * a ([] *))

module Numeric.Backprop.Mono
type BP s n a = BP s (Replicate n a)
type BPOp s n a b = BP s n a (BPRef s n a b)
type BPRef s n a = BPRef s (Replicate n a)
type Op n a = Op (Replicate n a)
backprop :: forall n a b. Num a => (forall s. BPOp s n a b) -> Vec n a -> (b, Vec n a)
evalBPOp :: forall n a b. Num a => (forall s. BPOp s n a b) -> Vec n a -> b
gradBPOp :: forall n a b. Num a => (forall s. BPOp s n a b) -> Vec n a -> Vec n a
withInps :: Known Nat n => (VecT n (BPRef s n a) a -> BP s n a b) -> BP s n a b
constRef :: b -> BPRef s n a b
inpRef :: Fin n -> BPRef s n a a
inpRefs :: Known Nat n => VecT n (BPRef s n a) a
opRef :: forall s m n a b. Num b => VecT m (BPRef s n a) a -> Op m a b -> BP s n a (BPRef s n a b)
(-$) :: Num b => Op m a b -> VecT m (BPRef s n a) a -> BP s n a (BPRef s n a b)
infixr 1 -$
opRef1 :: forall s n a b. Num b => BPRef s n a a -> Op N1 a b -> BP s n a (BPRef s n a b)
opRef2 :: forall s n a b. Num b => BPRef s n a a -> BPRef s n a a -> Op N2 a b -> BP s n a (BPRef s n a b)
opRef3 :: forall s n a b. Num b => BPRef s n a a -> BPRef s n a a -> BPRef s n a a -> Op N3 a b -> BP s n a (BPRef s n a b)
plugBP :: (Num b, Num c) => VecT m (BPRef s n a) b -> BPOp s m b c -> BPOp s n a c
liftR :: Op m a b -> VecT m (BPRef s n r) a -> BPRef s n r b
liftR1 :: Op N1 a a -> BPRef s n r a -> BPRef s n r a
liftR2 :: Op N2 a a -> BPRef s n r a -> BPRef s n r a -> BPRef s n r a
liftR3 :: Op N3 a a -> BPRef s n r a -> BPRef s n r a -> BPRef s n r a -> BPRef s n r a
op1 :: Num a => (forall s. AD s (Forward a) -> AD s (Forward a)) -> Op N1 a a
op2 :: Num a => (forall s. Reifies s Tape => Reverse s a -> Reverse s a -> Reverse s a) -> Op N2 a a
op3 :: Num a => (forall s. Reifies s Tape => Reverse s a -> Reverse s a -> Reverse s a -> Reverse s a) -> Op N3 a a
opN :: (Num a, Known Nat n) => (forall s. Reifies s Tape => Vec n (Reverse s a) -> Reverse s a) -> Op n a a
runOp' :: Op n a b -> Vec n a -> (b, Maybe b -> Vec n a)
runOp :: Op n a b -> Vec n a -> b
gradOp :: Op n a b -> Vec n a -> Vec n a
gradOpWith :: Op n a b -> Vec n a -> b -> Vec n a
gradOpWith' :: Op n a b -> Vec n a -> Maybe b -> Vec n a

-- | Convenient aliases for low-value Peano numbers.
type N0 = Z
type N1 = S N0
type N2 = S N1
type N3 = S N2
type N4 = S N3
type N5 = S N4
type N6 = S N5
type N7 = S N6
type N8 = S N7
type N9 = S N8
type N10 = S N9
data VecT k (n :: N) (f :: k -> *) (a :: k) :: forall k. N -> (k -> *) -> k -> *
[ØV] :: VecT k Z f a
[:*] :: VecT k (S n1) f a
type Vec (n :: N) = VecT * n I
infixr 4 :+
(*:) :: f a -> f a -> VecT k (S (S Z)) f a
infix 5 *:
(+:) :: a -> a -> Vec (S (S Z)) a
infix 5 +:

module Numeric.Backprop.Mono.Implicit
backprop :: forall n a b. (Num a, Known Nat n) => (forall s. VecT n (BPRef s n a) a -> BPRef s n a b) -> Vec n a -> (b, Vec n a)
grad :: forall n a b. (Num a, Known Nat n) => (forall s. VecT n (BPRef s n a) a -> BPRef s n a b) -> Vec n a -> Vec n a
eval :: forall n a b. (Num a, Known Nat n) => (forall s. VecT n (BPRef s n a) a -> BPRef s n a b) -> Vec n a -> b

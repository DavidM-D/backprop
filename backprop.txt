-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package backprop
@version 0.1.0.0

module Numeric.Backprop.Iso
type Iso s t a b = forall p f. (Profunctor p, Functor f) => p a (f b) -> p s (f t)
type Iso' s a = Iso s s a a
iso :: (s -> a) -> (b -> t) -> Iso s t a b
re :: Iso' s a -> Iso' a s
review :: Iso s t a b -> b -> t
coercible :: Coercible s a => Iso' s a
gTuple :: (Generic a, Code a ~ '[as]) => Iso' a (Tuple as)
gSOP :: Generic a => Iso' a (Sum Tuple (Code a))
sum1 :: Iso' (Sum f '[a]) (f a)
resum1 :: Iso' (f a) (Sum f '[a])

module Numeric.Backprop.Op
newtype Op as a
Op :: (Tuple as -> (a, Maybe a -> Tuple as)) -> Op as a
[runOp'] :: Op as a -> Tuple as -> (a, Maybe a -> Tuple as)
runOp :: Op as a -> Tuple as -> a
gradOp :: Op as a -> Tuple as -> Tuple as
gradOpWith :: Op as a -> Tuple as -> a -> Tuple as
gradOpWith' :: Op as a -> Tuple as -> Maybe a -> Tuple as
composeOp :: Prod Summer as -> Prod (Op as) bs -> Op bs c -> Op as c
op0 :: a -> Op '[] a
op1 :: Num a => (forall s. AD s (Forward a) -> AD s (Forward a)) -> Op '[a] a
op2 :: Num a => (forall s. Reifies s Tape => Reverse s a -> Reverse s a -> Reverse s a) -> Op '[a, a] a
op3 :: Num a => (forall s. Reifies s Tape => Reverse s a -> Reverse s a -> Reverse s a -> Reverse s a) -> Op '[a, a, a] a
opN :: (Num a, Known Nat n) => (forall s. Reifies s Tape => Vec n (Reverse s a) -> Reverse s a) -> Op (Replicate n a) a
opCoerce :: (Coercible a b, Num a) => Op '[a] b
opTup :: (Every Num as, Known Length as) => Op as (Tuple as)
opIso :: Num a => Iso' a b -> Op '[a] b
op1' :: (a -> (b, Maybe b -> a)) -> Op '[a] b
op2' :: (a -> b -> (c, Maybe c -> (a, b))) -> Op '[a, b] c
op3' :: (a -> b -> c -> (d, Maybe d -> (a, b, c))) -> Op '[a, b, c] d
opN' :: (Known Nat n) => (Vec n a -> (b, Maybe b -> Vec n a)) -> Op (Replicate n a) b
opCoerce' :: Coercible a b => Unity a -> Op '[a] b
opTup' :: Prod Unity as -> Op as (Tuple as)
opIso' :: Unity a -> Iso' a b -> Op '[a] b
data Prod k (f :: k -> *) (a :: [k]) :: forall k. (k -> *) -> [k] -> *
[Ø] :: Prod k f ([] k)
[:<] :: Prod k f ((:) k a1 as)

-- | Construct a two element Prod. Since the precedence of (:&gt;) is
--   higher than (:&lt;), we can conveniently write lists like:
--   
--   <pre>
--   &gt;&gt;&gt; a :&lt; b :&gt; c
--   </pre>
--   
--   Which is identical to:
--   
--   <pre>
--   &gt;&gt;&gt; a :&lt; b :&lt; c :&lt; Ø
--   </pre>
infix 6 :>

-- | Build a singleton Prod.
only :: f a -> Prod k f ((:) k a ([] k))
head' :: Prod k f ((:<) k a as) -> f a

-- | A Prod of simple Haskell types.
type Tuple = Prod * I

-- | Cons onto a Tuple.
infixr 5 ::<

-- | Singleton Tuple.
only_ :: a -> Tuple ((:) * a ([] *))
instance (Type.Class.Known.Known Data.Type.Length.Length as, Data.Type.Index.Every GHC.Num.Num as, GHC.Num.Num a) => GHC.Num.Num (Numeric.Backprop.Op.Op as a)
instance (Type.Class.Known.Known Data.Type.Length.Length as, Data.Type.Index.Every GHC.Real.Fractional as, Data.Type.Index.Every GHC.Num.Num as, GHC.Real.Fractional a) => GHC.Real.Fractional (Numeric.Backprop.Op.Op as a)
instance (Type.Class.Known.Known Data.Type.Length.Length as, Data.Type.Index.Every GHC.Float.Floating as, Data.Type.Index.Every GHC.Real.Fractional as, Data.Type.Index.Every GHC.Num.Num as, GHC.Float.Floating a) => GHC.Float.Floating (Numeric.Backprop.Op.Op as a)

module Numeric.Backprop

-- | A Monad allowing you to explicitly build hetereogeneous data
--   dependency graphs and that the library can perform backpropagation on.
--   
--   A <tt><a>BP</a> s rs b</tt> is a <a>BP</a> action that uses an
--   environment of <tt>rs</tt> returning a <tt>b</tt>. The <tt>s</tt>
--   parameter is used the same way that <a>ST</a> uses it, basically to
--   enforce that nothing important "leaks" out of the monad. When "run",
--   it will compute a gradient that is a tuple of <tt>rs</tt>.
--   
--   For example, a <tt><a>BP</a> s '[ Int, Double, Double ]</tt> is a
--   monad that represents a computation with an <a>Int</a>, <a>Double</a>,
--   and <a>Double</a> as inputs.
--   
--   When run with <tt>backprop</tt> or <tt>gradBPOp</tt>, it would return
--   a <i>gradient</i> on the inputs. So in the above example, the gradient
--   would be a tuple of an <a>Int</a>, <a>Double</a>, and <a>Double</a>.
data BP s rs b
type BPOp s rs a = BP s rs (BRef s rs a)
type BPOpI s rs a = Prod (BRef s rs) rs -> BRef s rs a

-- | The basic unit of manipulation inside <a>BP</a>. Instead of directly
--   working with values, you work with <i>references</i> to those values.
--   When you work with a <a>BRef</a>, the <i>backprop</i> library can keep
--   track of what values refer to which other values, and so can perform
--   backpropagation to compute gradients.
--   
--   A <tt><a>BRef</a> s rs a</tt> lives inside a <tt><a>BP</a> s rs</tt>
--   monad, and refers to a value of type <tt>a</tt>. (The <tt>rs</tt>
--   refers to the environment of the <a>BP</a> action that the
--   <tt>BPRef</tt> lives inside.)
--   
--   <tt>BPRef</tt>s have <a>Num</a>, <a>Fractional</a>, <a>Floating</a>,
--   etc. instances, so they can be manipulated using polymorphic functions
--   and numeric functions in Haskell. You can add them, subtract them,
--   etc., in "implicit" backprop style.
--   
--   (However, note that if you directly manipulate <tt>BPRef</tt>s using
--   those instances or using <tt>liftR</tt>, it delays evaluation, so
--   every usage site has to re-compute the result/create a new node. If
--   you want to re-use a <tt>BPRef</tt> you created using '(+)' or '(-)'
--   or <tt>liftR</tt>, use <tt>bindRef</tt> to force it first.)
data BRef :: Type -> [Type] -> Type -> Type
newtype Op as a
Op :: (Tuple as -> (a, Maybe a -> Tuple as)) -> Op as a
[runOp'] :: Op as a -> Tuple as -> (a, Maybe a -> Tuple as)
backprop :: forall rs a. Every Num rs => (forall s. BPOp s rs a) -> Tuple rs -> (a, Tuple rs)
evalBPOp :: Every Num rs => (forall s. BPOp s rs a) -> Tuple rs -> a
gradBPOp :: Every Num rs => (forall s. BPOp s rs a) -> Tuple rs -> Tuple rs
backprop' :: Prod Summer rs -> Prod Unity rs -> (forall s. BPOp s rs a) -> Tuple rs -> (a, Tuple rs)
evalBPOp' :: Prod Summer rs -> Prod Unity rs -> (forall s. BPOp s rs a) -> Tuple rs -> a
gradBPOp' :: Prod Summer rs -> Prod Unity rs -> (forall s. BPOp s rs a) -> Tuple rs -> Tuple rs
withInps :: Known Length rs => (Prod (BRef s rs) rs -> BP s rs a) -> BP s rs a
implicitly :: Known Length rs => BPOpI s rs a -> BPOp s rs a
plugBP :: forall s rs as a. (Every Num as, Num a) => Prod (BRef s rs) as -> BPOp s as a -> BPOp s rs a
(~$) :: (Every Num as, Num a) => BPOp s as a -> Prod (BRef s rs) as -> BPOp s rs a
infixr 1 ~$
($~) :: (Every Num as, Num a) => Prod (BRef s rs) as -> (Prod (BRef s as) as -> BPOp s as a) -> BPOp s rs a
infixr 1 $~
withInps' :: Length rs -> (Prod (BRef s rs) rs -> BP s rs a) -> BP s rs a
implicitly' :: Length rs -> BPOpI s rs a -> BPOp s rs a
plugBP' :: Prod (BRef s rs) as -> Prod Summer as -> Prod Unity as -> Summer a -> BPOp s as a -> BPOp s rs a
constRef :: a -> BRef s rs a
inpRef :: Index rs a -> BRef s rs a
inpRefs :: Known Length rs => Prod (BRef s rs) rs
bindRef :: Num a => BRef s rs a -> BP s rs (BRef s rs a)
inpRefs' :: Length rs -> Prod (BRef s rs) rs
bindRef' :: Summer a -> BRef s rs a -> BP s rs (BRef s rs a)
opRef :: Num a => Prod (BRef s rs) as -> Op as a -> BP s rs (BRef s rs a)
(-$) :: Num a => Op as a -> Prod (BRef s rs) as -> BP s rs (BRef s rs a)
infixr 1 -$
opRef1 :: Num b => BRef s rs a -> Op '[a] b -> BP s rs (BRef s rs b)
opRef2 :: Num c => BRef s rs a -> BRef s rs b -> Op '[a, b] c -> BP s rs (BRef s rs c)
opRef3 :: Num d => BRef s rs a -> BRef s rs b -> BRef s rs c -> Op '[a, b, c] d -> BP s rs (BRef s rs d)
opRef' :: forall s rs as a. Summer a -> Prod (BRef s rs) as -> Op as a -> BP s rs (BRef s rs a)
opRef1' :: Summer b -> BRef s rs a -> Op '[a] b -> BP s rs (BRef s rs b)
opRef2' :: Summer c -> BRef s rs a -> BRef s rs b -> Op '[a, b] c -> BP s rs (BRef s rs c)
opRef3' :: Summer d -> BRef s rs a -> BRef s rs b -> BRef s rs c -> Op '[a, b, c] d -> BP s rs (BRef s rs d)
partsRef :: forall s rs bs b. (Every Num bs, Known Length bs) => Iso' b (Tuple bs) -> BRef s rs b -> BP s rs (Prod (BRef s rs) bs)
(#<~) :: (Every Num bs, Known Length bs) => Iso' b (Tuple bs) -> BRef s rs b -> BP s rs (Prod (BRef s rs) bs)
infixr 1 #<~
withParts :: (Every Num bs, Known Length bs) => Iso' b (Tuple bs) -> BRef s rs b -> (Prod (BRef s rs) bs -> BP s rs a) -> BP s rs a
splitRefs :: forall s rs as. (Every Num as, Known Length as) => BRef s rs (Tuple as) -> BP s rs (Prod (BRef s rs) as)
gSplit :: (Every Num bs, Known Length bs, Generic b, Code b ~ '[bs]) => BRef s rs b -> BP s rs (Prod (BRef s rs) bs)
partsRef' :: forall s rs bs b. Prod Summer bs -> Prod Unity bs -> Iso' b (Tuple bs) -> BRef s rs b -> BP s rs (Prod (BRef s rs) bs)
withParts' :: Prod Summer bs -> Prod Unity bs -> Iso' b (Tuple bs) -> BRef s rs b -> (Prod (BRef s rs) bs -> BP s rs a) -> BP s rs a
splitRefs' :: forall s rs as. Prod Summer as -> Prod Unity as -> BRef s rs (Tuple as) -> BP s rs (Prod (BRef s rs) as)
gSplit' :: (Generic b, Code b ~ '[bs]) => Prod Summer bs -> Prod Unity bs -> BRef s rs b -> BP s rs (Prod (BRef s rs) bs)
choicesRef :: forall s rs bs b. (Every Num bs, Known Length bs) => Iso' b (Sum I bs) -> BRef s rs b -> BP s rs (Sum (BRef s rs) bs)
choicesRef' :: forall s rs bs b. Prod Summer bs -> Prod Unity bs -> Iso' b (Sum I bs) -> BRef s rs b -> BP s rs (Sum (BRef s rs) bs)
sopRef :: forall s rs bss b. (Known Length bss, Every (Every Num ∧ Known Length) bss) => Iso' b (Sum Tuple bss) -> BRef s rs b -> BP s rs (Sum (Prod (BRef s rs)) bss)
gSplits :: forall s rs b. (Generic b, Known Length (Code b), Every (Every Num ∧ Known Length) (Code b)) => BRef s rs b -> BP s rs (Sum (Prod (BRef s rs)) (Code b))
sopRef' :: forall s rs bss b. Prod (Prod Summer) bss -> Prod (Prod Unity) bss -> Iso' b (Sum Tuple bss) -> BRef s rs b -> BP s rs (Sum (Prod (BRef s rs)) bss)
gSplits' :: forall s rs b. Generic b => Prod (Prod Summer) (Code b) -> Prod (Prod Unity) (Code b) -> BRef s rs b -> BP s rs (Sum (Prod (BRef s rs)) (Code b))
internally :: forall s rs bs b a. (Every Num bs, Known Length bs, Num a) => Iso' b (Tuple bs) -> BRef s rs b -> BP s bs (BRef s bs a) -> BP s rs (BRef s rs a)
generically :: forall s rs bs b a. (Num a, Every Num bs, Known Length bs, Generic b, Code b ~ '[bs]) => BRef s rs b -> BP s bs (BRef s bs a) -> BP s rs (BRef s rs a)
internally' :: forall s rs bs b a. Prod Summer bs -> Prod Unity bs -> Summer a -> Iso' b (Tuple bs) -> BRef s rs b -> BP s bs (BRef s bs a) -> BP s rs (BRef s rs a)
generically' :: forall s rs bs b a. (Generic b, Code b ~ '[bs]) => Prod Summer bs -> Prod Unity bs -> Summer a -> BRef s rs b -> BP s bs (BRef s bs a) -> BP s rs (BRef s rs a)
liftR :: Op as a -> Prod (BRef s rs) as -> BRef s rs a
liftR1 :: Op '[a] b -> BRef s rs a -> BRef s rs b
liftR2 :: Op '[a, b] c -> BRef s rs a -> BRef s rs b -> BRef s rs c
liftR3 :: Op '[a, b, c] d -> BRef s rs a -> BRef s rs b -> BRef s rs c -> BRef s rs d
op1 :: Num a => (forall s. AD s (Forward a) -> AD s (Forward a)) -> Op '[a] a
op2 :: Num a => (forall s. Reifies s Tape => Reverse s a -> Reverse s a -> Reverse s a) -> Op '[a, a] a
op3 :: Num a => (forall s. Reifies s Tape => Reverse s a -> Reverse s a -> Reverse s a -> Reverse s a) -> Op '[a, a, a] a
opN :: (Num a, Known Nat n) => (forall s. Reifies s Tape => Vec n (Reverse s a) -> Reverse s a) -> Op (Replicate n a) a
op1' :: (a -> (b, Maybe b -> a)) -> Op '[a] b
op2' :: (a -> b -> (c, Maybe c -> (a, b))) -> Op '[a, b] c
op3' :: (a -> b -> c -> (d, Maybe d -> (a, b, c))) -> Op '[a, b, c] d
opN' :: (Known Nat n) => (Vec n a -> (b, Maybe b -> Vec n a)) -> Op (Replicate n a) b

-- | Instructions on how to "sum" a list of values of a given type.
--   Basically used as an explicit witness for a <a>Num</a> instance.
--   
--   For most types, the only meaningful value of type <tt><a>Summer</a>
--   a</tt> is <tt><a>Summer</a> <a>sum</a></tt>. However, using
--   <a>Summer</a> lets us use <tt>BP</tt> with types that are <i>not</i>
--   instances of <a>Num</a>. Any type can be used, as long as you provide
--   a way to "sum" it!
--   
--   For most of the functions in this library, you can completely ignore
--   this, as they will be generated automatically. You only need to work
--   with this directly if you want to use custom types that <i>aren't</i>
--   instances of <a>Num</a> with this library.
--   
--   If 'Num a' is satisfied, one can create the canonical <a>Summer</a>
--   using <tt><a>known</a> :: <a>Num</a> a =&gt; <a>Summer</a> a</tt>.
newtype Summer a
Summer :: ([a] -> a) -> Summer a
[runSummer] :: Summer a -> [a] -> a

-- | If all the types in <tt>as</tt> are instances of <a>Num</a>, generate
--   a <tt><a>Prod</a> <a>Summer</a> as</tt>, or a tuple of <a>Summer</a>s
--   for every type in <tt>as</tt>.
summers :: (Every Num as, Known Length as) => Prod Summer as

-- | Like <a>summers</a>, but requiring an explicit witness for the number
--   of types in the list <tt>as</tt>.
summers' :: Every Num as => Length as -> Prod Summer as

-- | A canonical "unity" (the multiplicative identity) for a given type.
--   Basically used as an explicit witness for a <a>Num</a> instance.
--   
--   For most types, the only meaningful value of type <tt><a>Unity</a>
--   a</tt> is <tt><a>Unity</a> 1'</tt>. However, using <a>Unity</a> lets
--   us use <tt>BP</tt> with types that are <i>not</i> instances of
--   <a>Num</a>. Any type can be used, as long as you provide a way to get
--   a multiplicative identity in it!
--   
--   For most of the functions in this library, you can completely ignore
--   this, as they will be generated automatically. You only need to work
--   with this directly if you want to use custom types that <i>aren't</i>
--   instances of <a>Num</a> with this library.
--   
--   If 'Num a' is satisfied, one can create the canonical <a>Unity</a>
--   using <tt><a>known</a> :: <a>Num</a> a =&gt; <a>Unity</a> a</tt>.
newtype Unity a
Unity :: a -> Unity a
[getUnity] :: Unity a -> a

-- | If all the types in <tt>as</tt> are instances of <a>Num</a>, generate
--   a <tt><a>Prod</a> <a>Unity</a> as</tt>, or a tuple of <a>Unity</a>s
--   for every type in <tt>as</tt>.
unities :: (Every Num as, Known Length as) => Prod Unity as

-- | Like <a>unities</a>, but requiring an explicit witness for the number
--   of types in the list <tt>as</tt>.
unities' :: Every Num as => Length as -> Prod Unity as
data Prod k (f :: k -> *) (a :: [k]) :: forall k. (k -> *) -> [k] -> *
[Ø] :: Prod k f ([] k)
[:<] :: Prod k f ((:) k a1 as)

-- | Construct a two element Prod. Since the precedence of (:&gt;) is
--   higher than (:&lt;), we can conveniently write lists like:
--   
--   <pre>
--   &gt;&gt;&gt; a :&lt; b :&gt; c
--   </pre>
--   
--   Which is identical to:
--   
--   <pre>
--   &gt;&gt;&gt; a :&lt; b :&lt; c :&lt; Ø
--   </pre>
infix 6 :>

-- | Build a singleton Prod.
only :: f a -> Prod k f ((:) k a ([] k))
head' :: Prod k f ((:<) k a as) -> f a

-- | A Prod of simple Haskell types.
type Tuple = Prod * I

-- | Cons onto a Tuple.
infixr 5 ::<

-- | Singleton Tuple.
only_ :: a -> Tuple ((:) * a ([] *))

module Numeric.Backprop.Implicit

-- | The basic unit of manipulation inside <a>BP</a>. Instead of directly
--   working with values, you work with <i>references</i> to those values.
--   When you work with a <a>BRef</a>, the <i>backprop</i> library can keep
--   track of what values refer to which other values, and so can perform
--   backpropagation to compute gradients.
--   
--   A <tt><a>BRef</a> s rs a</tt> lives inside a <tt><a>BP</a> s rs</tt>
--   monad, and refers to a value of type <tt>a</tt>. (The <tt>rs</tt>
--   refers to the environment of the <a>BP</a> action that the
--   <tt>BPRef</tt> lives inside.)
--   
--   <tt>BPRef</tt>s have <a>Num</a>, <a>Fractional</a>, <a>Floating</a>,
--   etc. instances, so they can be manipulated using polymorphic functions
--   and numeric functions in Haskell. You can add them, subtract them,
--   etc., in "implicit" backprop style.
--   
--   (However, note that if you directly manipulate <tt>BPRef</tt>s using
--   those instances or using <tt>liftR</tt>, it delays evaluation, so
--   every usage site has to re-compute the result/create a new node. If
--   you want to re-use a <tt>BPRef</tt> you created using '(+)' or '(-)'
--   or <tt>liftR</tt>, use <tt>bindRef</tt> to force it first.)
data BRef :: Type -> [Type] -> Type -> Type
type BPOp rs a = forall s. Prod (BRef s rs) rs -> BRef s rs a
newtype Op as a
Op :: (Tuple as -> (a, Maybe a -> Tuple as)) -> Op as a
[runOp'] :: Op as a -> Tuple as -> (a, Maybe a -> Tuple as)

-- | Instructions on how to "sum" a list of values of a given type.
--   Basically used as an explicit witness for a <a>Num</a> instance.
--   
--   For most types, the only meaningful value of type <tt><a>Summer</a>
--   a</tt> is <tt><a>Summer</a> <a>sum</a></tt>. However, using
--   <a>Summer</a> lets us use <tt>BP</tt> with types that are <i>not</i>
--   instances of <a>Num</a>. Any type can be used, as long as you provide
--   a way to "sum" it!
--   
--   For most of the functions in this library, you can completely ignore
--   this, as they will be generated automatically. You only need to work
--   with this directly if you want to use custom types that <i>aren't</i>
--   instances of <a>Num</a> with this library.
--   
--   If 'Num a' is satisfied, one can create the canonical <a>Summer</a>
--   using <tt><a>known</a> :: <a>Num</a> a =&gt; <a>Summer</a> a</tt>.
newtype Summer a
Summer :: ([a] -> a) -> Summer a
[runSummer] :: Summer a -> [a] -> a

-- | A canonical "unity" (the multiplicative identity) for a given type.
--   Basically used as an explicit witness for a <a>Num</a> instance.
--   
--   For most types, the only meaningful value of type <tt><a>Unity</a>
--   a</tt> is <tt><a>Unity</a> 1'</tt>. However, using <a>Unity</a> lets
--   us use <tt>BP</tt> with types that are <i>not</i> instances of
--   <a>Num</a>. Any type can be used, as long as you provide a way to get
--   a multiplicative identity in it!
--   
--   For most of the functions in this library, you can completely ignore
--   this, as they will be generated automatically. You only need to work
--   with this directly if you want to use custom types that <i>aren't</i>
--   instances of <a>Num</a> with this library.
--   
--   If 'Num a' is satisfied, one can create the canonical <a>Unity</a>
--   using <tt><a>known</a> :: <a>Num</a> a =&gt; <a>Unity</a> a</tt>.
newtype Unity a
Unity :: a -> Unity a
[getUnity] :: Unity a -> a
backprop :: (Known Length rs, Every Num rs) => BPOp rs a -> Tuple rs -> (a, Tuple rs)
grad :: (Known Length rs, Every Num rs) => BPOp rs a -> Tuple rs -> Tuple rs
eval :: (Known Length rs, Every Num rs) => BPOp rs a -> Tuple rs -> a
backprop' :: Prod Summer rs -> Prod Unity rs -> BPOp rs a -> Tuple rs -> (a, Tuple rs)
grad' :: Prod Summer rs -> Prod Unity rs -> BPOp rs a -> Tuple rs -> Tuple rs
eval' :: Prod Summer rs -> Prod Unity rs -> BPOp rs a -> Tuple rs -> a
constRef :: a -> BRef s rs a
liftR :: Op as a -> Prod (BRef s rs) as -> BRef s rs a
liftR1 :: Op '[a] b -> BRef s rs a -> BRef s rs b
liftR2 :: Op '[a, b] c -> BRef s rs a -> BRef s rs b -> BRef s rs c
liftR3 :: Op '[a, b, c] d -> BRef s rs a -> BRef s rs b -> BRef s rs c -> BRef s rs d
partsRef :: forall s rs bs a. (Known Length bs, Every Num bs) => Iso' a (Tuple bs) -> BRef s rs a -> Prod (BRef s rs) bs
withParts :: forall s rs bs a r. (Known Length bs, Every Num bs) => Iso' a (Tuple bs) -> BRef s rs a -> (Prod (BRef s rs) bs -> r) -> r
splitRefs :: forall s rs as. (Known Length as, Every Num as) => BRef s rs (Tuple as) -> Prod (BRef s rs) as
gSplit :: forall s rs as a. (Generic a, Code a ~ '[as], Known Length as, Every Num as) => BRef s rs a -> Prod (BRef s rs) as
partsRef' :: forall s rs bs a. Prod Summer bs -> Prod Unity bs -> Iso' a (Tuple bs) -> BRef s rs a -> Prod (BRef s rs) bs
withParts' :: forall s rs bs a r. Prod Summer bs -> Prod Unity bs -> Iso' a (Tuple bs) -> BRef s rs a -> (Prod (BRef s rs) bs -> r) -> r
splitRefs' :: forall s rs as. Prod Summer as -> Prod Unity as -> BRef s rs (Tuple as) -> Prod (BRef s rs) as
gSplit' :: forall s rs as a. (Generic a, Code a ~ '[as]) => Prod Summer as -> Prod Unity as -> BRef s rs a -> Prod (BRef s rs) as
op1 :: Num a => (forall s. AD s (Forward a) -> AD s (Forward a)) -> Op '[a] a
op2 :: Num a => (forall s. Reifies s Tape => Reverse s a -> Reverse s a -> Reverse s a) -> Op '[a, a] a
op3 :: Num a => (forall s. Reifies s Tape => Reverse s a -> Reverse s a -> Reverse s a -> Reverse s a) -> Op '[a, a, a] a
opN :: (Num a, Known Nat n) => (forall s. Reifies s Tape => Vec n (Reverse s a) -> Reverse s a) -> Op (Replicate n a) a
op1' :: (a -> (b, Maybe b -> a)) -> Op '[a] b
op2' :: (a -> b -> (c, Maybe c -> (a, b))) -> Op '[a, b] c
op3' :: (a -> b -> c -> (d, Maybe d -> (a, b, c))) -> Op '[a, b, c] d
opN' :: (Known Nat n) => (Vec n a -> (b, Maybe b -> Vec n a)) -> Op (Replicate n a) b

-- | If all the types in <tt>as</tt> are instances of <a>Num</a>, generate
--   a <tt><a>Prod</a> <a>Summer</a> as</tt>, or a tuple of <a>Summer</a>s
--   for every type in <tt>as</tt>.
summers :: (Every Num as, Known Length as) => Prod Summer as

-- | If all the types in <tt>as</tt> are instances of <a>Num</a>, generate
--   a <tt><a>Prod</a> <a>Unity</a> as</tt>, or a tuple of <a>Unity</a>s
--   for every type in <tt>as</tt>.
unities :: (Every Num as, Known Length as) => Prod Unity as
data Prod k (f :: k -> *) (a :: [k]) :: forall k. (k -> *) -> [k] -> *
[Ø] :: Prod k f ([] k)
[:<] :: Prod k f ((:) k a1 as)

-- | Construct a two element Prod. Since the precedence of (:&gt;) is
--   higher than (:&lt;), we can conveniently write lists like:
--   
--   <pre>
--   &gt;&gt;&gt; a :&lt; b :&gt; c
--   </pre>
--   
--   Which is identical to:
--   
--   <pre>
--   &gt;&gt;&gt; a :&lt; b :&lt; c :&lt; Ø
--   </pre>
infix 6 :>

-- | Build a singleton Prod.
only :: f a -> Prod k f ((:) k a ([] k))
head' :: Prod k f ((:<) k a as) -> f a

-- | A Prod of simple Haskell types.
type Tuple = Prod * I

-- | Cons onto a Tuple.
infixr 5 ::<

-- | Singleton Tuple.
only_ :: a -> Tuple ((:) * a ([] *))

module Numeric.Backprop.Op.Mono
type Op n a = Op (Replicate n a)
runOp' :: Op n a b -> Vec n a -> (b, Maybe b -> Vec n a)
runOp :: Op n a b -> Vec n a -> b
gradOp :: Op n a b -> Vec n a -> Vec n a
gradOpWith :: Op n a b -> Vec n a -> b -> Vec n a
gradOpWith' :: Op n a b -> Vec n a -> Maybe b -> Vec n a
op1 :: Num a => (forall s. AD s (Forward a) -> AD s (Forward a)) -> Op N1 a a
op2 :: Num a => (forall s. Reifies s Tape => Reverse s a -> Reverse s a -> Reverse s a) -> Op N2 a a
op3 :: Num a => (forall s. Reifies s Tape => Reverse s a -> Reverse s a -> Reverse s a -> Reverse s a) -> Op N3 a a
opN :: (Num a, Known Nat n) => (forall s. Reifies s Tape => Vec n (Reverse s a) -> Reverse s a) -> Op n a a

-- | Convenient aliases for low-value Peano numbers.
type N0 = Z
type N1 = S N0
type N2 = S N1
type N3 = S N2
type N4 = S N3
type N5 = S N4
type N6 = S N5
type N7 = S N6
type N8 = S N7
type N9 = S N8
type N10 = S N9
data VecT k (n :: N) (f :: k -> *) (a :: k) :: forall k. N -> (k -> *) -> k -> *
[ØV] :: VecT k Z f a
[:*] :: VecT k (S n1) f a
type Vec (n :: N) = VecT * n I
infixr 4 :+
(*:) :: f a -> f a -> VecT k (S (S Z)) f a
infix 5 *:
(+:) :: a -> a -> Vec (S (S Z)) a
infix 5 +:
head' :: VecT k (S n) f a -> f a

module Numeric.Backprop.Mono
type BP s n a = BP s (Replicate n a)
type BPOp s n a b = BP s n a (BRef s n a b)
type BRef s n a = BRef s (Replicate n a)
type Op n a = Op (Replicate n a)
backprop :: forall n a b. Num a => (forall s. BPOp s n a b) -> Vec n a -> (b, Vec n a)
evalBPOp :: forall n a b. Num a => (forall s. BPOp s n a b) -> Vec n a -> b
gradBPOp :: forall n a b. Num a => (forall s. BPOp s n a b) -> Vec n a -> Vec n a
withInps :: Known Nat n => (VecT n (BRef s n a) a -> BP s n a b) -> BP s n a b
implicitly :: Known Nat n => BPOpI s n a b -> BPOp s n a b
constRef :: b -> BRef s n a b
inpRef :: Fin n -> BRef s n a a
inpRefs :: Known Nat n => VecT n (BRef s n a) a
opRef :: forall s m n a b. Num b => VecT m (BRef s n a) a -> Op m a b -> BP s n a (BRef s n a b)
(-$) :: Num b => Op m a b -> VecT m (BRef s n a) a -> BP s n a (BRef s n a b)
infixr 1 -$
opRef1 :: forall s n a b. Num b => BRef s n a a -> Op N1 a b -> BP s n a (BRef s n a b)
opRef2 :: forall s n a b. Num b => BRef s n a a -> BRef s n a a -> Op N2 a b -> BP s n a (BRef s n a b)
opRef3 :: forall s n a b. Num b => BRef s n a a -> BRef s n a a -> BRef s n a a -> Op N3 a b -> BP s n a (BRef s n a b)
plugBP :: (Num b, Num c) => VecT m (BRef s n a) b -> BPOp s m b c -> BPOp s n a c
liftR :: Op m a b -> VecT m (BRef s n r) a -> BRef s n r b
liftR1 :: Op N1 a a -> BRef s n r a -> BRef s n r a
liftR2 :: Op N2 a a -> BRef s n r a -> BRef s n r a -> BRef s n r a
liftR3 :: Op N3 a a -> BRef s n r a -> BRef s n r a -> BRef s n r a -> BRef s n r a
op1 :: Num a => (forall s. AD s (Forward a) -> AD s (Forward a)) -> Op N1 a a
op2 :: Num a => (forall s. Reifies s Tape => Reverse s a -> Reverse s a -> Reverse s a) -> Op N2 a a
op3 :: Num a => (forall s. Reifies s Tape => Reverse s a -> Reverse s a -> Reverse s a -> Reverse s a) -> Op N3 a a
opN :: (Num a, Known Nat n) => (forall s. Reifies s Tape => Vec n (Reverse s a) -> Reverse s a) -> Op n a a

-- | Convenient aliases for low-value Peano numbers.
type N0 = Z
type N1 = S N0
type N2 = S N1
type N3 = S N2
type N4 = S N3
type N5 = S N4
type N6 = S N5
type N7 = S N6
type N8 = S N7
type N9 = S N8
type N10 = S N9
data VecT k (n :: N) (f :: k -> *) (a :: k) :: forall k. N -> (k -> *) -> k -> *
[ØV] :: VecT k Z f a
[:*] :: VecT k (S n1) f a
type Vec (n :: N) = VecT * n I
infixr 4 :+
(*:) :: f a -> f a -> VecT k (S (S Z)) f a
infix 5 *:
(+:) :: a -> a -> Vec (S (S Z)) a
infix 5 +:
head' :: VecT k (S n) f a -> f a

module Numeric.Backprop.Mono.Implicit
type BRef s n a = BRef s (Replicate n a)
type BPOp n a b = forall s. VecT n (BRef s n a) a -> BRef s n a b
type Op n a = Op (Replicate n a)
backprop :: forall n a b. (Num a, Known Nat n) => BPOp n a b -> Vec n a -> (b, Vec n a)
grad :: forall n a b. (Num a, Known Nat n) => BPOp n a b -> Vec n a -> Vec n a
eval :: forall n a b. (Num a, Known Nat n) => BPOp n a b -> Vec n a -> b
constRef :: b -> BRef s n a b
liftR :: Op m a b -> VecT m (BRef s n r) a -> BRef s n r b
liftR1 :: Op N1 a a -> BRef s n r a -> BRef s n r a
liftR2 :: Op N2 a a -> BRef s n r a -> BRef s n r a -> BRef s n r a
liftR3 :: Op N3 a a -> BRef s n r a -> BRef s n r a -> BRef s n r a -> BRef s n r a
op1 :: Num a => (forall s. AD s (Forward a) -> AD s (Forward a)) -> Op N1 a a
op2 :: Num a => (forall s. Reifies s Tape => Reverse s a -> Reverse s a -> Reverse s a) -> Op N2 a a
op3 :: Num a => (forall s. Reifies s Tape => Reverse s a -> Reverse s a -> Reverse s a -> Reverse s a) -> Op N3 a a
opN :: (Num a, Known Nat n) => (forall s. Reifies s Tape => Vec n (Reverse s a) -> Reverse s a) -> Op n a a

-- | Convenient aliases for low-value Peano numbers.
type N0 = Z
type N1 = S N0
type N2 = S N1
type N3 = S N2
type N4 = S N3
type N5 = S N4
type N6 = S N5
type N7 = S N6
type N8 = S N7
type N9 = S N8
type N10 = S N9
data VecT k (n :: N) (f :: k -> *) (a :: k) :: forall k. N -> (k -> *) -> k -> *
[ØV] :: VecT k Z f a
[:*] :: VecT k (S n1) f a
type Vec (n :: N) = VecT * n I
infixr 4 :+
(*:) :: f a -> f a -> VecT k (S (S Z)) f a
infix 5 *:
(+:) :: a -> a -> Vec (S (S Z)) a
infix 5 +:
head' :: VecT k (S n) f a -> f a

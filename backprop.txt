-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package backprop
@version 0.1.0.0

module Numeric.Backprop.Op
newtype Op as a
Op :: (Tuple as -> (a, Maybe a -> Tuple as)) -> Op as a
[runOp'] :: Op as a -> Tuple as -> (a, Maybe a -> Tuple as)
runOp :: Op as a -> Tuple as -> a
gradOp :: Op as a -> Tuple as -> Tuple as
gradOpWith :: Op as a -> Tuple as -> a -> Tuple as
newtype Summer a
Summer :: ([a] -> a) -> Summer a
[runSummer] :: Summer a -> [a] -> a
op0 :: a -> Op '[] a
op1 :: (a -> (b, Maybe b -> a)) -> Op '[a] b
op1' :: Num a => (forall s. AD s (Forward a) -> AD s (Forward a)) -> Op '[a] a
op2 :: (a -> b -> (c, Maybe c -> (a, b))) -> Op '[a, b] c
op2' :: Num a => (forall s. Reifies s Tape => Reverse s a -> Reverse s a -> Reverse s a) -> Op '[a, a] a
op3 :: (a -> b -> c -> (d, Maybe d -> (a, b, c))) -> Op '[a, b, c] d
op3' :: Num a => (forall s. Reifies s Tape => Reverse s a -> Reverse s a -> Reverse s a -> Reverse s a) -> Op '[a, a, a] a

module Numeric.Backprop
data BP s as b
data BPRef :: Type -> [Type] -> Type -> Type
newBPRef :: forall s as a bs. Prod (BPRef s bs) as -> Op as a -> Summer a -> BP s bs (BPRef s bs a)
newBPRef' :: Num a => Prod (BPRef s bs) as -> Op as a -> BP s bs (BPRef s bs a)
newBPRef0 :: Op '[] a -> Summer a -> BP s as (BPRef s as a)
newBPRef1 :: BPRef s as a -> Op '[a] b -> Summer b -> BP s as (BPRef s as b)
newBPRef1' :: Num b => BPRef s as a -> Op '[a] b -> BP s as (BPRef s as b)
newBPRef2 :: BPRef s bs a -> BPRef s bs b -> Op '[a, b] c -> Summer c -> BP s bs (BPRef s bs c)
newBPRef2' :: Num c => BPRef s bs a -> BPRef s bs b -> Op '[a, b] c -> BP s bs (BPRef s bs c)
newBPRef3 :: BPRef s bs a -> BPRef s bs b -> BPRef s bs c -> Op '[a, b, c] d -> Summer d -> BP s bs (BPRef s bs d)
newBPRef3' :: Num d => BPRef s bs a -> BPRef s bs b -> BPRef s bs c -> Op '[a, b, c] d -> BP s bs (BPRef s bs d)
backprop :: (forall s. BP s as (BPRef s as a)) -> Prod Summer as -> Prod Unity as -> Tuple as -> (a, Tuple as)
backprop' :: forall as a. Every Num as => (forall s. BP s as (BPRef s as a)) -> Tuple as -> (a, Tuple as)
inpRef :: Index as a -> BPRef s as a
inpRefs :: Known Length as => Prod (BPRef s as) as
withInps :: Known Length as => (Prod (BPRef s as) as -> BP s as a) -> BP s as a
newtype Op as a
Op :: (Tuple as -> (a, Maybe a -> Tuple as)) -> Op as a
[runOp'] :: Op as a -> Tuple as -> (a, Maybe a -> Tuple as)
newtype Summer a
Summer :: ([a] -> a) -> Summer a
[runSummer] :: Summer a -> [a] -> a
newtype Unity a
Unity :: a -> Unity a
[getUnity] :: Unity a -> a

module Numeric.Backprop.Mono
type BP s n a = BP s (Rep n a)
type BPRef s n a = BPRef s (Rep n a)
newBPRef :: forall s m n a b. Num b => VecT m (BPRef s n a) a -> Op m a b -> BP s n a (BPRef s n a b)
newBPRef0 :: forall s n a b. Num b => Op N0 a b -> BP s n a (BPRef s n a b)
newBPRef1 :: forall s n a b. Num b => BPRef s n a a -> Op N1 a b -> BP s n a (BPRef s n a b)
newBPRef2 :: forall s n a b. Num b => BPRef s n a a -> BPRef s n a a -> Op N2 a b -> BP s n a (BPRef s n a b)
newBPRef3 :: forall s n a b. Num b => BPRef s n a a -> BPRef s n a a -> BPRef s n a a -> Op N3 a b -> BP s n a (BPRef s n a b)
backprop :: forall n a b. Num a => (forall s. BP s n a (BPRef s n a b)) -> Vec n a -> (b, Vec n a)
inpRef :: Fin n -> BPRef s n a a
inpRefs :: Known Nat n => VecT n (BPRef s n a) a
withInps :: Known Nat n => (VecT n (BPRef s n a) a -> BP s n a b) -> BP s n a b
type Op n a = Op (Rep n a)
runOp' :: Op as a -> Tuple as -> (a, Maybe a -> Tuple as)
runOp :: Op as a -> Tuple as -> a
gradOp :: Op as a -> Tuple as -> Tuple as

-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Graph-based, heterogeneous, type-safe backpropagation in
--   Haskell
--   
--   See README.md
@package backprop
@version 0.1.0.0


-- | A poor substitute for the <a>Control.Lens.Iso</a> module in
--   <i>lens</i>, providing the <a>Iso</a> type synonym and some sample
--   useful <a>Iso</a>s for usage with <i>backprop</i>, without incuring a
--   lens dependency.
--   
--   If you also import lens, you should only use this module for the
--   <a>Iso</a>s it exports, and not import the redefined <a>Iso</a> type
--   synonym or <a>from</a> <i> <a>iso</a> </i> <a>review</a>.
module Numeric.Backprop.Iso

-- | A family of isomorphisms. See <a>Iso'</a>.
type Iso s t a b = forall p f. (Profunctor p, Functor f) => p a (f b) -> p s (f t)

-- | An <tt><a>Iso'</a> s a</tt> encodes an isomorphism between an
--   <tt>s</tt> and an <tt>a</tt>. It basically lets you go from <tt>s
--   -&gt; a</tt> and back (from <tt>a -&gt; s</tt>) while preserving
--   structure. You can basically imagine an <tt><a>Iso'</a> s a</tt> to be
--   an <tt>(s -&gt; a, a -&gt; s)</tt> tuple.
--   
--   You can get the "forward" direction of an <a>Iso'</a> with
--   <a>view</a>:
--   
--   <pre>
--   <a>view</a> :: Iso'' s a -&gt; (s -&gt; a)
--   </pre>
--   
--   And the "backwards" direction with <a>review</a>:
--   
--   <pre>
--   <a>review</a> :: Iso'' s a -&gt; (a -&gt; s)
--   </pre>
--   
--   You can construct an <a>Iso'</a> using <a>iso</a>, giving the forward
--   and backwards functions:
--   
--   <pre>
--   &gt;&gt;&gt; myIso :: Iso' (Identity a) a
--       myIso = iso runIdentity Identity
--   
--   &gt;&gt;&gt; view myIso (Identity "hello")
--   "hello"
--   
--   &gt;&gt;&gt; review myIso "hello"
--   Identity "hello"
--   </pre>
--   
--   One powerful thing about <a>Iso'</a>s is that they're
--   <i>composable</i> using <a>.</a>:
--   
--   <pre>
--   (<a>.</a>) :: <a>Iso'</a> c b -&gt; <a>Iso'</a> b a -&gt; <a>Iso'</a> c a
--   </pre>
--   
--   This is basically provided here so that this package doesn't incurr a
--   <i>lens</i> dependecy, but if you already depend on <i>lens</i>, you
--   should use the version from <a>Control.Lens.Iso</a> instead.
type Iso' s a = Iso s s a a

-- | Construct an <a>Iso</a> by giving the "forward" and "backward"
--   direction functions:
--   
--   <pre>
--   &gt;&gt;&gt; myIso :: Iso' (Identity a) a
--       myIso = iso runIdentity Identity
--   
--   &gt;&gt;&gt; view myIso (Identity "hello")
--   "hello"
--   
--   &gt;&gt;&gt; review myIso "hello"
--   Identity "hello"
--   </pre>
--   
--   This is basically provided here so that this package doesn't incurr a
--   <i>lens</i> dependecy, but if you already depend on <i>lens</i>, you
--   should use the version from <a>Control.Lens.Iso</a> instead.
iso :: (s -> a) -> (b -> t) -> Iso s t a b

-- | Reverse an <a>Iso'</a>. The forward function becomes the backwards
--   function, and the backwards function becomes the forward function.
--   
--   This is basically provided here so that this package doesn't incurr a
--   <i>lens</i> dependecy, but if you already depend on <i>lens</i>, you
--   should use the version from <a>Control.Lens.Review</a> instead.
from :: Iso' s a -> Iso' a s

-- | Get the "reverse" direction function from an <a>Iso</a>.
--   
--   This is basically provided here so that this package doesn't incurr a
--   <i>lens</i> dependecy, but if you already depend on <i>lens</i>, you
--   should use the version from <a>Control.Lens.Review</a> instead.
review :: Iso s t a b -> b -> t

-- | <a>view</a> is a synonym for (<a>^.</a>):
--   
--   <pre>
--   &gt;&gt;&gt; view _1 (1, 2)
--   1
--   </pre>
--   
--   The reason it's not in <a>Lens.Micro</a> is that <tt>view</tt> in lens
--   has a more general signature:
--   
--   <pre>
--   view :: MonadReader s m =&gt; Getting a s a -&gt; m a
--   </pre>
--   
--   So, you would be able to use this <a>view</a> with functions, but not
--   in various reader monads. For most people this shouldn't be an issue;
--   if it is for you, use <tt>view</tt> from <a>microlens-mtl</a>.
view :: Getting a s a -> s -> a

-- | A useful <a>Iso</a> between two types with the same runtime
--   representation.
coerced :: Coercible s a => Iso' s a

-- | An <a>Iso</a> between a type that is a product type, and a tuple that
--   contains all of its components. Uses <a>Generics.SOP</a> and the
--   <a>Generic</a> typeclass.
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Generics.SOP as SOP
--   
--   &gt;&gt;&gt; data Foo = A Int Bool      deriving Generic
--   
--   &gt;&gt;&gt; instance SOP.Generic Foo
--   
--   &gt;&gt;&gt; view gTuple (A 10 True)
--   10 ::&lt; True ::&lt; Ø
--   
--   &gt;&gt;&gt; review gTuple (15 ::&lt; False ::&lt; Ø)
--   A 15 False
--   </pre>
gTuple :: (Generic a, Code a ~ '[as]) => Iso' a (Tuple as)

-- | An <a>Iso</a> between a sum type whose constructors are products, and
--   a sum (<a>Sum</a>) of products (<a>Tuple</a>). Uses
--   <a>Generics.SOP</a> and the <a>Generic</a> typeclass.
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Generics.SOP as SOP
--   
--   &gt;&gt;&gt; data Bar = A Int Bool | B String Double
--   
--   &gt;&gt;&gt; instance SOP.Generic Bar
--   
--   &gt;&gt;&gt; 'view' 'gSOP' (A 10 True)
--   'InL' (10 ::&lt; True ::&lt; Ø)
--   
--   &gt;&gt;&gt; 'view' 'gSOP' (B "hello" 3.4)
--   'InR' ('InL' ("hello" ::&lt; 3.4 ::&lt; Ø))
--   
--   &gt;&gt;&gt; 'review' 'gTuple' ('InL' (15 ::&lt; False ::&lt; Ø))
--   A 15 False
--   
--   &gt;&gt;&gt; 'review' 'gTuple' ('InR' ('InL' ("bye" ::&lt; 9.8 ::&lt; Ø)))
--   B "bye" 9.8
--   </pre>
gSOP :: Generic a => Iso' a (Sum Tuple (Code a))

-- | An iso between a single-type <a>Sum</a> and the single type.
sum1 :: Iso' (Sum f '[a]) (f a)

-- | An iso between a single type and a single-type <a>Sum</a>.
resum1 :: Iso' (f a) (Sum f '[a])


-- | Provides the <a>Op</a> (and <a>OpM</a>) type and combinators, which
--   represent differentiable functions/operations on values, and are used
--   by the library to perform backpropagation.
--   
--   Note that <a>Op</a> is a <i>subset</i> or <i>subtype</i> of
--   <a>OpM</a>, and so, any function that expects an <tt><a>OpM</a> m as
--   a</tt> (or an <tt><a>OpB</a> s as a</tt>) can be given an
--   <tt><a>Op</a> as a</tt> and it'll work just fine.
module Numeric.Backprop.Op

-- | An <tt><a>Op</a> as a</tt> is a type synonym over <a>OpM</a> that
--   describes a differentiable function from <tt>as</tt> to <tt>a</tt>.
--   
--   For example, an
--   
--   <pre>
--   <a>Op</a> '[Int, Bool] Double
--   </pre>
--   
--   is a function from an <a>Int</a> and a <a>Bool</a>, returning a
--   <a>Double</a>. It can be differentiated to give a <i>gradient</i> of
--   an <a>Int</a> and a <a>Bool</a> if given a total derivative for
--   <tt>a</tt>.
--   
--   See <a>runOp</a>, <a>gradOp</a>, and <a>gradOpWith</a> for examples on
--   how to run it, and <a>Op</a> for instructions on creating it.
--   
--   This type is abstracted over using the pattern synonym with
--   constructor <a>Op</a>, so you can create one from scratch with it.
--   However, it's simplest to create it using <a>op2'</a>, <a>op1'</a>,
--   <a>op2'</a>, and <a>op3'</a> helper smart constructors And, if your
--   function is a numeric function, they can even be created automatically
--   using <a>op1</a>, <a>op2</a>, <a>op3</a>, and <a>opN</a> with a little
--   help from <a>Numeric.AD</a> from the <i>ad</i> library.
--   
--   Note that this type is a <i>subset</i> or <i>subtype</i> of
--   <a>OpM</a>. So, if a function ever expects an <tt><a>OpM</a> m as
--   a</tt>, you can always provide an <tt><a>Op</a> as a</tt> instead.
--   
--   Many functions in this library will expect an <tt><a>OpM</a> m as
--   a</tt> (or an <tt><a>OpB</a> s as a</tt>), and in all of these cases,
--   you can provide an <tt><a>Op</a> as a</tt>.
type Op as a = forall m. Monad m => OpM m as a

-- | Construct an <a>Op</a> by giving a function creating the result, and
--   also a continuation on how to create the gradient, given the total
--   derivative of <tt>a</tt>.
--   
--   See the module documentation for <a>Numeric.Backprop.Op</a> for more
--   details on the function that this constructor and <a>OpM</a> expect.

-- | An <tt><a>OpM</a> m as a</tt> represents a <i>differentiable</i>
--   (monadic) function from <tt>as</tt> to <tt>a</tt>, in the context of a
--   <a>Monad</a> <tt>m</tt>.
--   
--   For example, an
--   
--   <pre>
--   <a>OpM</a> IO '[Int, Bool] Double
--   </pre>
--   
--   would be a function that takes an <a>Int</a> and a <a>Bool</a> and
--   returns a <a>Double</a> (in <a>IO</a>). It can be differentiated to
--   give a <i>gradient</i> of an <a>Int</a> and a <a>Bool</a> (in
--   <a>IO</a>) if given the total derivative for <tt>a</tt>.
--   
--   Note that an <a>OpM</a> is a <i>superclass</i> of <a>Op</a>, so any
--   function that expects an <tt><a>OpM</a> m as a</tt> can also accept an
--   <tt><a>Op</a> as a</tt>.
--   
--   See <a>runOpM</a>, <a>gradOpM</a>, and <a>gradOpWithM</a> for examples
--   on how to run it.
newtype OpM m as a

-- | Construct an <a>OpM</a> by giving a function creating the result, and
--   also a continuation on how to create the gradient, given the total
--   derivative of <tt>a</tt>.
--   
--   See the module documentation for <a>Numeric.Backprop.Op</a> for more
--   details on the function that this constructor and <a>Op</a> expect.
OpM :: (Tuple as -> m (a, Maybe a -> m (Tuple as))) -> OpM m as a
data Prod k (f :: k -> *) (a :: [k]) :: forall k. (k -> *) -> [k] -> *
[Ø] :: Prod k f ([] k)
[:<] :: Prod k f ((:) k a1 as)

-- | A Prod of simple Haskell types.
type Tuple = Prod * I

-- | Run the function that an <a>Op</a> encodes, to get the result.
--   
--   <pre>
--   &gt;&gt;&gt; runOp (op2 (*)) (3 ::&lt; 5 ::&lt; Ø)
--   15
--   </pre>
runOp :: Op as a -> Tuple as -> a

-- | Run the function that an <a>Op</a> encodes, and get the gradient of
--   the output with respect to the inputs.
--   
--   <pre>
--   &gt;&gt;&gt; gradOp (op2 (*)) (3 ::&lt; 5 ::&lt; Ø)
--   5 ::&lt; 3 ::&lt; Ø
--   -- the gradient of x*y is (y, x)
--   </pre>
gradOp :: Op as a -> Tuple as -> Tuple as

-- | Run the function that an <a>Op</a> encodes, to get the resulting
--   output and also its gradient with respect to the inputs.
--   
--   <pre>
--   &gt;&gt;&gt; gradOpM' (op2 (*)) (3 ::&lt; 5 ::&lt; Ø) :: IO (Int, Tuple '[Int, Int])
--   (15, 5 ::&lt; 3 ::&lt; Ø)
--   </pre>
gradOp' :: Op as a -> Tuple as -> (a, Tuple as)

-- | Run the function that an <a>Op</a> encodes, and get the gradient of a
--   "final result" with respect to the inputs, given the total derivative
--   of the output with the final result.
--   
--   See <a>gradOp</a> and the module documentaiton for
--   <a>Numeric.Backprop.Op</a> for more information.
gradOpWith :: Op as a -> Tuple as -> a -> Tuple as

-- | A combination of <a>gradOp</a> and <a>gradOpWith</a>. The third
--   argument is (optionally) the total derivative the result. Give
--   <a>Nothing</a> and it is assumed that the result is the final result
--   (and the total derivative is 1), and this behaves the same as
--   <a>gradOp</a>. Give <tt><a>Just</a> d</tt> and it uses the <tt>d</tt>
--   as the total derivative of the result, and this behaves like
--   <a>gradOpWith</a>.
--   
--   See <a>gradOp</a> and the module documentaiton for
--   <a>Numeric.Backprop.Op</a> for more information.
gradOpWith' :: Op as a -> Tuple as -> Maybe a -> Tuple as

-- | A combination of <a>runOp</a> and <a>gradOpWith'</a>. Given an
--   <a>Op</a> and inputs, returns the result of the <a>Op</a> and a
--   continuation that gives its gradient.
--   
--   The continuation takes the total derivative of the result as input.
--   See documenation for <a>gradOpWith'</a> and module documentation for
--   <a>Numeric.Backprop.Op</a> for more information.
runOp' :: Op as a -> Tuple as -> (a, Maybe a -> Tuple as)

-- | The monadic version of <a>runOp</a>, for <a>OpM</a>s.
--   
--   <pre>
--   &gt;&gt;&gt; runOpM (op2 (*)) (3 ::&lt; 5 ::&lt; Ø) :: IO Int
--   15
--   </pre>
runOpM :: Functor m => OpM m as a -> Tuple as -> m a

-- | The monadic version of <a>gradOp</a>, for <a>OpM</a>s.
gradOpM :: Monad m => OpM m as a -> Tuple as -> m (Tuple as)

-- | The monadic version of <a>gradOp'</a>, for <a>OpM</a>s.
gradOpM' :: Monad m => OpM m as a -> Tuple as -> m (a, Tuple as)

-- | The monadic version of <a>gradOpWith</a>, for <a>OpM</a>s.
gradOpWithM :: Monad m => OpM m as a -> Tuple as -> a -> m (Tuple as)

-- | The monadic version of <a>gradOpWith'</a>, for <a>OpM</a>s.
gradOpWithM' :: Monad m => OpM m as a -> Tuple as -> Maybe a -> m (Tuple as)

-- | A combination of <a>runOpM</a> and <a>gradOpWithM'</a>. Given an
--   <a>OpM</a> and inputs, returns the result of the <a>OpM</a> and a
--   continuation that gives its gradient.
--   
--   The continuation takes the total derivative of the result as input.
--   See documenation for <a>gradOpWithM'</a> and module documentation for
--   <a>Numeric.Backprop.Op</a> for more information.
runOpM' :: OpM m as a -> Tuple as -> m (a, Maybe a -> m (Tuple as))

-- | Compose <a>OpM</a>s together, similar to <a>.</a>. But, because all
--   <a>OpM</a>s are &lt;math&gt;, this is more like <a>sequence</a> for
--   functions, or <tt>liftAN</tt>.
--   
--   That is, given an <tt><a>OpM</a> m as b1</tt>, an <tt><a>OpM</a> m as
--   b2</tt>, and an <tt><a>OpM</a> m as b3</tt>, it can compose them with
--   an <tt><a>OpM</a> m '[b1,b2,b3] c</tt> to create an <tt><a>OpM</a> as
--   c</tt>.
composeOp :: (Monad m, Known Length as, Every Num as) => Prod (OpM m as) bs -> OpM m bs c -> OpM m as c

-- | <a>composeOp</a>, but taking explicit <a>Summer</a>s, for the
--   situation where the <tt>as</tt> are not instance of <a>Num</a>.
composeOp' :: Monad m => Prod Summer as -> Prod (OpM m as) bs -> OpM m bs c -> OpM m as c

-- | Create an <a>Op</a> that takes no inputs and always returns the given
--   value.
--   
--   There is no gradient, of course (using <a>gradOp</a> will give you an
--   empty tuple), because there is no input to have a gradient of.
--   
--   <pre>
--   &gt;&gt;&gt; gradOp' (op0 10) Ø
--   (10, Ø)
--   </pre>
--   
--   For a constant <a>Op</a> that takes input and ignores it, see
--   <a>opConst</a> and <a>opConst'</a>.
--   
--   Note that because this returns an <a>Op</a>, it can be used with any
--   function that expects an <a>OpM</a>, as well.
op0 :: a -> Op '[] a

-- | An <a>Op</a> that ignores all of its inputs and returns a given
--   constant value.
--   
--   <pre>
--   &gt;&gt;&gt; gradOp' (opConst 10) (1 ::&lt; 2 ::&lt; 3 ::&lt; Ø)
--   (10, 0 ::&lt; 0 ::&lt; 0 ::&lt; Ø)
--   </pre>
opConst :: (Every Num as, Known Length as) => a -> Op as a

-- | A version of <a>opConst</a> that takes explicit <a>Summer</a>s, so can
--   be run on values of types that aren't <a>Num</a> instances.
opConst' :: Prod Summer as -> a -> Op as a

-- | Create an <a>Op</a> of a function taking one input, by giving its
--   explicit derivative. The function should return a tuple containing the
--   result of the function, and also a function taking the derivative of
--   the result and return the derivative of the input.
--   
--   If we have
--   
--   &lt;math&gt;
--   
--   Then the derivative &lt;math&gt;, it would be:
--   
--   &lt;math&gt;
--   
--   If our <a>Op</a> represents &lt;math&gt;, then the second item in the
--   resulting tuple should be a function that takes &lt;math&gt; and
--   returns &lt;math&gt;.
--   
--   If the input is <a>Nothing</a>, then &lt;math&gt; should be taken to
--   be &lt;math&gt;.
--   
--   As an example, here is an <a>Op</a> that squares its input:
--   
--   <pre>
--   square :: Num a =&gt; <a>Op</a> '[a] a
--   square = <a>op1'</a> $ \x -&gt; (x*x, \case Nothing -&gt; 2 * x
--                                     Just d  -&gt; 2 * d * x
--                         )
--   </pre>
--   
--   Remember that, generally, end users shouldn't directly construct
--   <a>Op</a>s; they should be provided by libraries or generated
--   automatically.
--   
--   For numeric functions, single-input <a>Op</a>s can be generated
--   automatically using <a>op1</a>.
op1' :: (a -> (b, Maybe b -> a)) -> Op '[a] b

-- | Create an <a>Op</a> of a function taking two inputs, by giving its
--   explicit gradient. The function should return a tuple containing the
--   result of the function, and also a function taking the derivative of
--   the result and return the derivative of the input.
--   
--   If we have
--   
--   &lt;math&gt;
--   
--   Then the gradient &lt;math&gt; would be:
--   
--   &lt;math&gt;
--   
--   If our <a>Op</a> represents &lt;math&gt;, then the second item in the
--   resulting tuple should be a function that takes &lt;math&gt; and
--   returns &lt;math&gt;.
--   
--   If the input is <a>Nothing</a>, then &lt;math&gt; should be taken to
--   be &lt;math&gt;.
--   
--   As an example, here is an <a>Op</a> that multiplies its inputs:
--   
--   <pre>
--   mul :: Num a =&gt; <a>Op</a> '[a, a] a
--   mul = <a>op2'</a> $ \x y -&gt; (x*y, \case Nothing -&gt; (y  , x  )
--                                    Just d  -&gt; (d*y, x*d)
--                        )
--   </pre>
--   
--   Remember that, generally, end users shouldn't directly construct
--   <a>Op</a>s; they should be provided by libraries or generated
--   automatically.
--   
--   For numeric functions, two-input <a>Op</a>s can be generated
--   automatically using <a>op2</a>.
op2' :: (a -> b -> (c, Maybe c -> (a, b))) -> Op '[a, b] c

-- | Create an <a>Op</a> of a function taking three inputs, by giving its
--   explicit gradient. See documentation for <a>op2'</a> for more details.
op3' :: (a -> b -> c -> (d, Maybe d -> (a, b, c))) -> Op '[a, b, c] d

-- | Automatically create an <a>Op</a> of a numerical function taking one
--   argument. Uses <a>diff</a>, and so can take any numerical function
--   polymorphic over the standard numeric types.
--   
--   <pre>
--   &gt;&gt;&gt; gradOp' (op1 (recip . negate)) (5 ::&lt; Ø)
--   (-0.2, 0.04 ::&lt; Ø)
--   </pre>
op1 :: Num a => (forall s. AD s (Forward a) -> AD s (Forward a)) -> Op '[a] a

-- | Automatically create an <a>Op</a> of a numerical function taking two
--   arguments. Uses <a>grad</a>, and so can take any numerical function
--   polymorphic over the standard numeric types.
--   
--   <pre>
--   &gt;&gt;&gt; gradOp' (op2 (\x y -&gt; x * sqrt y)) (3 ::&lt; 4 ::&lt; Ø)
--   (6.0, 2.0 ::&lt; 0.75 ::&lt; Ø)
--   </pre>
op2 :: Num a => (forall s. Reifies s Tape => Reverse s a -> Reverse s a -> Reverse s a) -> Op '[a, a] a

-- | Automatically create an <a>Op</a> of a numerical function taking three
--   arguments. Uses <a>grad</a>, and so can take any numerical function
--   polymorphic over the standard numeric types.
--   
--   <pre>
--   &gt;&gt;&gt; gradOp' (op3 (\x y z -&gt; (x * sqrt y)**z)) (3 ::&lt; 4 ::&lt; 2 ::&lt; Ø)
--   (36.0, 24.0 ::&lt; 9.0 ::&lt; 64.503 ::&lt; Ø)
--   </pre>
op3 :: Num a => (forall s. Reifies s Tape => Reverse s a -> Reverse s a -> Reverse s a -> Reverse s a) -> Op '[a, a, a] a

-- | Automatically create an <a>Op</a> of a numerical function taking
--   multiple arguments. Uses <a>grad</a>, and so can take any numerical
--   function polymorphic over the standard numeric types.
--   
--   <pre>
--   &gt;&gt;&gt; gradOp' (opN (\(x :+ y :+ Ø) -&gt; x * sqrt y)) (3 ::&lt; 4 ::&lt; Ø)
--   (6.0, 2.0 ::&lt; 0.75 ::&lt; Ø)
--   </pre>
opN :: (Num a, Known Nat n) => (forall s. Reifies s Tape => Vec n (Reverse s a) -> Reverse s a) -> Op (Replicate n a) a

-- | An <a>Op</a> that coerces an item into another item whose type has the
--   same runtime representation. Requires the input to be an instance of
--   <a>Num</a>.
--   
--   <pre>
--   &gt;&gt;&gt; gradOp' opCoerce (Identity 5) :: (Int, Identity Int)
--   (5, Identity 1)
--   </pre>
--   
--   <pre>
--   <a>opCoerce</a> = <a>opIso</a> <a>coerced</a>
--   </pre>
opCoerce :: (Coercible a b, Num a) => Op '[a] b

-- | An <a>Op</a> that takes <tt>as</tt> and returns exactly the input
--   tuple.
--   
--   <pre>
--   &gt;&gt;&gt; gradOp' opTup (1 ::&lt; 2 ::&lt; 3 ::&lt; Ø)
--   (1 ::&lt; 2 ::&lt; 3 ::&lt; Ø, 1 ::&lt; 1 ::&lt; 1 ::&lt; Ø)
--   </pre>
opTup :: (Every Num as, Known Length as) => Op as (Tuple as)

-- | An <a>Op</a> that runs the input value through the isomorphism encoded
--   in the <a>Iso</a>. Requires the input to be an instance of <a>Num</a>.
--   
--   Warning: This is unsafe! It assumes that the isomorphisms themselves
--   have derivative 1, so will break for things like
--   <a>exponentiating</a>. Basically, don't use this for any "numeric"
--   isomorphisms.
opIso :: Num a => Iso' a b -> Op '[a] b

-- | A version of <a>opCoerce</a> that takes an explicit <a>Unity</a>, so
--   can be run on values that aren't <a>Num</a> instances.
opCoerce' :: Coercible a b => Unity a -> Op '[a] b

-- | A version of <a>opTup</a> that takes explicit <a>Unity</a>s, so can be
--   run on values of types that aren't <a>Num</a> instances.
opTup' :: Prod Unity as -> Op as (Tuple as)

-- | A version of <a>opIso</a> that takes an explicit <a>Unity</a>, so can
--   be run on values of types that aren't <a>Num</a> instances.
opIso' :: Unity a -> Iso' a b -> Op '[a] b

-- | Construct a two element Prod. Since the precedence of (:&gt;) is
--   higher than (:&lt;), we can conveniently write lists like:
--   
--   <pre>
--   &gt;&gt;&gt; a :&lt; b :&gt; c
--   </pre>
--   
--   Which is identical to:
--   
--   <pre>
--   &gt;&gt;&gt; a :&lt; b :&lt; c :&lt; Ø
--   </pre>
infix 6 :>

-- | Build a singleton Prod.
only :: f a -> Prod k f ((:) k a ([] k))
head' :: Prod k f ((:<) k a as) -> f a

-- | Cons onto a Tuple.
infixr 5 ::<

-- | Singleton Tuple.
only_ :: a -> Tuple ((:) * a ([] *))
instance (GHC.Base.Monad m, Type.Class.Known.Known Data.Type.Length.Length as, Data.Type.Index.Every GHC.Num.Num as, GHC.Num.Num a) => GHC.Num.Num (Numeric.Backprop.Op.OpM m as a)
instance (GHC.Base.Monad m, Type.Class.Known.Known Data.Type.Length.Length as, Data.Type.Index.Every GHC.Real.Fractional as, Data.Type.Index.Every GHC.Num.Num as, GHC.Real.Fractional a) => GHC.Real.Fractional (Numeric.Backprop.Op.OpM m as a)
instance (GHC.Base.Monad m, Type.Class.Known.Known Data.Type.Length.Length as, Data.Type.Index.Every GHC.Float.Floating as, Data.Type.Index.Every GHC.Real.Fractional as, Data.Type.Index.Every GHC.Num.Num as, GHC.Float.Floating a) => GHC.Float.Floating (Numeric.Backprop.Op.OpM m as a)

module Numeric.Backprop

-- | A Monad allowing you to explicitly build hetereogeneous data
--   dependency graphs and that the library can perform backpropagation on.
--   
--   A <tt><a>BP</a> s rs b</tt> is a <a>BP</a> action that uses an
--   environment of <tt>rs</tt> returning a <tt>b</tt>. When "run", it will
--   compute a gradient that is a tuple of <tt>rs</tt>. (The phantom
--   parameter <tt>s</tt> is used to ensure that any <a>BVar</a>s aren't
--   leaked out of the monad)
--   
--   Note that you can only "run" a <tt><a>BP</a> s rs</tt> that produces a
--   <a>BVar</a> -- that is, things of the form
--   
--   <pre>
--   <a>BP</a> s rs (<a>BVar</a> rs a)
--   </pre>
--   
--   The above is a <a>BP</a> action that returns a <a>BVar</a> containing
--   an <tt>a</tt>. When this is run, it'll produce a result of type
--   <tt>a</tt> and a gradient of that is a tuple of <tt>rs</tt>. (This
--   form has a type synonym, <a>BPOp</a>, for convenience)
--   
--   For example, a <tt><a>BP</a> s '[ Int, Double, Double ]</tt> is a
--   monad that represents a computation with an <a>Int</a>, <a>Double</a>,
--   and <a>Double</a> as inputs. And, if you ran a
--   
--   <pre>
--   <a>BP</a> s '[ Int, Double, Double ] (<a>BVar</a> '[ Int, Double, Double ] Double)
--   </pre>
--   
--   Or, using the <tt>BPOp</tt> type synonym:
--   
--   <pre>
--   <a>BPOp</a> s '[ Int, Double, Double ] (<a>BVar</a> rs Double)
--   </pre>
--   
--   with <a>backprop</a> or <a>gradBPOp</a>, it'll return a gradient on
--   the inputs (<a>Int</a>, <a>Double</a>, and <a>Double</a>) and produce
--   a value of type <a>Double</a>.
data BP s rs b

-- | A handy type synonym representing a <a>BP</a> action that returns a
--   <a>BVar</a>. This is handy because this is the form of <a>BP</a>
--   actions that <a>backprop</a> and <a>gradBPOp</a> (etc.) expects.
--   
--   A value of type:
--   
--   <pre>
--   <a>BPOp</a> s rs a
--   </pre>
--   
--   is an action that takes an input environment of <tt>rs</tt> and
--   produces a <a>BVar</a> containing a value of type <tt>a</tt>. Because
--   it returns a <a>BVar</a>, the library can track the data dependencies
--   between the <a>BVar</a> and the input environment and perform
--   backpropagation.
--   
--   See documentation for <a>BP</a> for an explanation of the phantom type
--   parameter <tt>s</tt>.
type BPOp s rs a = BP s rs (BVar s rs a)

-- | An "implicit" operation on <a>BVar</a>s that can be backpropagated. A
--   value of type:
--   
--   <pre>
--   <a>BPOpI</a> s rs a
--   </pre>
--   
--   takes a bunch of <a>BVar</a>s containg <tt>rs</tt> and uses them to
--   (purely) produce a <a>BVar</a> containing an <tt>a</tt>.
--   
--   <pre>
--   foo :: BPOpI s '[ Double, Double ] Float
--   foo (x :&lt; y :&lt; Ø) = x + sqrt y
--   </pre>
--   
--   If you are exclusively doing implicit backpropagation by combining
--   <a>BVar</a>s and using <a>BPOpI</a>s, you are probably better off just
--   importing <a>Numeric.Backprop.Implicit</a>, which provides better
--   tools. This type synonym exists in <a>Numeric.Backprop</a> just for
--   the <a>implicitly</a> function, which can convert "implicit" backprop
--   functions like a <tt><a>BPOpI</a> s rs a</tt> into an "explicit" graph
--   backprop function, a <tt><a>BPOp</a> s rs a</tt>.
type BPOpI s rs a = Prod (BVar s rs) rs -> BVar s rs a

-- | The basic unit of manipulation inside <a>BP</a>. Instead of directly
--   working with values, you work with <a>BVar</a>s contating those
--   values. When you work with a <a>BVar</a>, the <i>backprop</i> library
--   can keep track of what values refer to which other values, and so can
--   perform backpropagation to compute gradients.
--   
--   A <tt><a>BVar</a> s rs a</tt> refers to a value of type <tt>a</tt>,
--   with an environment of values of the types <tt>rs</tt>. The phantom
--   parameter <tt>s</tt> is used to ensure that stray <a>BVar</a>s don't
--   leak outside of the backprop process.
--   
--   (That is, if you're using implicit backprop, it ensures that you
--   interact with <a>BVar</a>s in a polymorphic way. And, if you're using
--   implicit backprop, it ensures that a <tt><a>BVar</a> s rs a</tt> never
--   leaves the <tt><a>BP</a> s rs</tt> that it was created in.)
--   
--   <a>BVar</a>s have <a>Num</a>, <a>Fractional</a>, <a>Floating</a>, etc.
--   instances, so they can be manipulated using polymorphic functions and
--   numeric functions in Haskell. You can add them, subtract them, etc.,
--   in "implicit" backprop style.
--   
--   (However, note that if you directly manipulate <a>BVar</a>s using
--   those instances or using <a>liftB</a>, it delays evaluation, so every
--   usage site has to re-compute the result/create a new node. If you want
--   to re-use a <a>BVar</a> you created using <a>+</a> or <a>-</a> or
--   <a>liftB</a>, use <a>bindVar</a> to force it first. See documentation
--   for <a>bindVar</a> for more details.)
data BVar :: Type -> [Type] -> Type -> Type

-- | An <tt><a>Op</a> as a</tt> is a type synonym over <a>OpM</a> that
--   describes a differentiable function from <tt>as</tt> to <tt>a</tt>.
--   
--   For example, an
--   
--   <pre>
--   <a>Op</a> '[Int, Bool] Double
--   </pre>
--   
--   is a function from an <a>Int</a> and a <a>Bool</a>, returning a
--   <a>Double</a>. It can be differentiated to give a <i>gradient</i> of
--   an <a>Int</a> and a <a>Bool</a> if given a total derivative for
--   <tt>a</tt>.
--   
--   See <a>runOp</a>, <a>gradOp</a>, and <a>gradOpWith</a> for examples on
--   how to run it, and <a>Op</a> for instructions on creating it.
--   
--   This type is abstracted over using the pattern synonym with
--   constructor <a>Op</a>, so you can create one from scratch with it.
--   However, it's simplest to create it using <a>op2'</a>, <a>op1'</a>,
--   <a>op2'</a>, and <a>op3'</a> helper smart constructors And, if your
--   function is a numeric function, they can even be created automatically
--   using <a>op1</a>, <a>op2</a>, <a>op3</a>, and <a>opN</a> with a little
--   help from <a>Numeric.AD</a> from the <i>ad</i> library.
--   
--   Note that this type is a <i>subset</i> or <i>subtype</i> of
--   <a>OpM</a>. So, if a function ever expects an <tt><a>OpM</a> m as
--   a</tt>, you can always provide an <tt><a>Op</a> as a</tt> instead.
--   
--   Many functions in this library will expect an <tt><a>OpM</a> m as
--   a</tt> (or an <tt><a>OpB</a> s as a</tt>), and in all of these cases,
--   you can provide an <tt><a>Op</a> as a</tt>.
type Op as a = forall m. Monad m => OpM m as a

-- | A type synonym for <a>OpM</a> specialized to what the <i>backprop</i>
--   library uses to perform backpropagation.
--   
--   An
--   
--   <pre>
--   <a>OpB</a> s rs a
--   </pre>
--   
--   represents a differentiable function that takes a tuple of <tt>rs</tt>
--   and produces an a <tt>a</tt>, which can be run on <tt><a>BVar</a>
--   s</tt> and also inside <tt><a>BP</a> s</tt>s. For example, an
--   <tt><a>OpB</a> s '[ Int, Double ] Bool</tt> takes an <a>Int</a> and a
--   <a>Double</a> and produces a <a>Bool</a>, and does it in a
--   differentiable way.
--   
--   Note that <a>OpB</a> is a <i>superset</i> of <a>Op</a>, so, if you see
--   any function that expects an <a>OpB</a> (like <a>opVar'</a> and
--   <a>~$</a>, for example), you can give them an <a>Op</a>, as well.
--   
--   You can think of <a>OpB</a> as a superclass/parent class of <a>Op</a>
--   in this sense, and of <a>Op</a> as a subclass of <a>OpB</a>.
type OpB s as a = OpM (ST s) as a
data Prod k (f :: k -> *) (a :: [k]) :: forall k. (k -> *) -> [k] -> *
[Ø] :: Prod k f ([] k)
[:<] :: Prod k f ((:) k a1 as)

-- | A Prod of simple Haskell types.
type Tuple = Prod * I

-- | Perform backpropagation on the given <a>BPOp</a>. Returns the result
--   of the operation it represents, as well as the gradient of the result
--   with respect to its inputs. See module header for
--   <a>Numeric.Backprop</a> and package documentation for examples and
--   usages.
backprop :: forall rs a. Every Num rs => (forall s. BPOp s rs a) -> Tuple rs -> (a, Tuple rs)

-- | Simply run the <a>BPOp</a> on an input tuple, getting the result
--   without bothering with the gradient or with backpropagation.
evalBPOp :: (forall s. BPOp s rs a) -> Tuple rs -> a

-- | Run the <a>BPOp</a> on an input tuple and return the gradient of the
--   result with respect to the input tuple.
gradBPOp :: Every Num rs => (forall s. BPOp s rs a) -> Tuple rs -> Tuple rs

-- | A version of <a>backprop</a> taking explicit <a>Summer</a>s and
--   <a>Unity</a>s, so it can be run with types that aren't instances of
--   <a>Num</a>.
backprop' :: Prod Summer rs -> Prod Unity rs -> (forall s. BPOp s rs a) -> Tuple rs -> (a, Tuple rs)

-- | A version of <a>gradBPOp</a> taking explicit <a>Summer</a>s and
--   <a>Unity</a>s, so it can be run with types that aren't instances of
--   <a>Num</a>.
gradBPOp' :: Prod Summer rs -> Prod Unity rs -> (forall s. BPOp s rs a) -> Tuple rs -> Tuple rs

-- | Runs a continuation on a <a>Prod</a> of all of the input <a>BVar</a>s.
--   
--   Handy for bringing the environment into scope and doing stuff with it:
--   
--   <pre>
--   foo :: <a>BPOp</a> '[Double, Int] a
--   foo = <a>withInps</a> $ \(x :&lt; y :&lt; Ø) -&gt; do
--       -- do stuff with inputs
--   </pre>
--   
--   Looks kinda like <tt>foo (x :&lt; y :&lt; Ø) = -- ...</tt>, don't it?
--   
--   Note that the above is the same as
--   
--   <pre>
--   foo :: <a>BPOp</a> '[Double, Int] a
--   foo = do
--       x :&lt; y :&lt; Ø &lt;- <a>inpVars</a>
--       -- do stuff with inputs
--   </pre>
--   
--   But just a little nicer!
withInps :: Known Length rs => (Prod (BVar s rs) rs -> BP s rs a) -> BP s rs a

-- | Convert a <a>BPOpI</a> into a <a>BPOp</a>. That is, convert a function
--   on a bundle of <a>BVar</a>s (generating an implicit graph) into a
--   fully fledged <a>BPOp</a> that you can run <a>backprop</a> on. See
--   <a>BPOpI</a> for more information.
--   
--   If you are going to write exclusively using implicit <a>BVar</a>
--   operations, it might be more convenient to use
--   <a>Numeric.Backprop.Implicit</a> instead, which is geared around that
--   use case.
implicitly :: Known Length rs => BPOpI s rs a -> BPOp s rs a

-- | A version of <a>withInps</a> taking explicit <a>Length</a>, indicating
--   the number of inputs required and their types.
--   
--   Mostly useful for rare "extremely polymorphic" situations, where GHC
--   can't infer the type and length of the list of inputs. If you ever
--   actually explicitly write down <tt>rs</tt> as a list of types, you
--   should be able to just use <a>withInps</a>.
withInps' :: Length rs -> (Prod (BVar s rs) rs -> BP s rs a) -> BP s rs a

-- | A version of <a>implicitly</a> taking explicit <a>Length</a>,
--   indicating the number of inputs required and their types.
--   
--   Mostly useful for rare "extremely polymorphic" situations, where GHC
--   can't infer the type and length of the list of inputs. If you ever
--   actually explicitly write down <tt>rs</tt> as a list of types, you
--   should be able to just use <a>implicitly</a>.
implicitly' :: Length rs -> BPOpI s rs a -> BPOp s rs a

-- | Create a <a>BVar</a> that represents just a specific value, that
--   doesn't depend on any other <a>BVar</a>s.
constVar :: a -> BVar s rs a

-- | Create a <a>BVar</a> given an index into the input environment. For an
--   example,
--   
--   <pre>
--   <a>inpVar</a> <a>IZ</a>
--   </pre>
--   
--   would refer to the <i>first</i> input variable (the <a>Int</a> in a
--   <tt><a>BP</a> s '[Int, Bool]</tt>), and
--   
--   <pre>
--   <a>inpVar</a> (<a>IS</a> <a>IZ</a>)
--   </pre>
--   
--   Would refer to the <i>second</i> input variable (the <a>Bool</a> in a
--   <tt><a>BP</a> s '[Int, Bool]</tt>)
--   
--   Typically, there shouldn't be any reason to use <a>inpVar</a>
--   directly. It's cleaner to get all of your input <a>BVar</a>s together
--   using <a>withInps</a> or <a>inpVars</a>.
inpVar :: Index rs a -> BVar s rs a

-- | Get a <a>Prod</a> (tupling) of <a>BVar</a>s for all of the input
--   environment (<tt>rs</tt>) of the <tt><a>BP</a> s rs</tt>
--   
--   For example, if your <a>BP</a> has an <a>Int</a> and <a>Double</a> in
--   its input environment (a <tt><a>BP</a> s '[Int, Double]</tt>), this
--   would return a <a>BVar</a> pointing to the <a>Int</a> and a
--   <a>BVar</a> pointing to the <a>Double</a>.
--   
--   <pre>
--   let x :&lt; y :&lt; Ø = <a>inpVars</a> :: <a>Prod</a> (<a>BVar</a> s '[Int, Double]) '[Int, Double]
--   
--   -- the first item, x, is a var to the input <a>Int</a>
--   x :: <a>BVar</a> s '[Int, Double] Int
--   -- the second item, y, is a var to the input <a>Double</a>
--   y :: <a>BVar</a> s '[Int, Double] Double
--   </pre>
inpVars :: Known Length rs => Prod (BVar s rs) rs

-- | Turn a <a>BPOp</a> into an <a>OpB</a>. Basically converts a <a>BP</a>
--   taking an <tt>rs</tt> and producing an <tt>a</tt> into an <a>Op</a>
--   taking an <tt>rs</tt> and returning an <tt>a</tt>, with all of the
--   powers and utility of an <a>Op</a>, including all of its
--   gradient-finding glory.
--   
--   Handy because an <a>OpB</a> can be used with almost all of the
--   <a>Op</a>-related functions in this moduel, including <a>opVar</a>,
--   <a>~$</a>, etc.
bpOp :: (Every Num rs, Known Length rs) => BPOp s rs a -> OpB s rs a

-- | Concretizes a delayed <a>BVar</a>. If you build up a <a>BVar</a> using
--   numeric functions like <a>+</a> or <a>*</a> or using <tt>liftR</tt>,
--   it'll defer the evaluation, and all of its usage sites will create a
--   separate graph node.
--   
--   Use <a>bindVar</a> if you ever intend to use a <a>BVar</a> in more
--   than one location.
--   
--   <pre>
--   -- bad
--   errSquared :: Num a =&gt; <a>BP</a> s '[a, a] a
--   errSquared = <tt>withInp</tt> $ \(r :&lt; t :&lt; Ø) -&gt; do
--       let err = r - t
--       <a>return</a> (err * err)   -- err is used twice!
--   
--   -- good
--   errSquared :: Num a =&gt; <a>BP</a> s '[a, a] a
--   errSquared = <a>withInps</a> $ \(r :&lt; t :&lt; Ø) -&gt; do
--       let err = r - t
--       e &lt;- <a>bindVar</a> err     -- force e, so that it's safe to use twice!
--       <a>return</a> (e * e)
--   
--   -- better
--   errSquared :: Num a =&gt; <a>BP</a> s '[a, a] a
--   errSquared = <a>withInps</a> $ \(r :&lt; t :&lt; Ø) -&gt; do
--       let err = r - t
--       e &lt;- <a>bindVar</a> err
--       <a>bindVar</a> (e * e)      -- result is forced so user doesn't have to worry
--   </pre>
--   
--   Note the relation to <a>opVar</a> <i> <a>~$</a> </i> <tt>liftR</tt> /
--   <a>.$</a>:
--   
--   <pre>
--   <a>opVar</a> o xs    = <a>bindVar</a> (<tt>liftR</tt> o xs)
--   o <a>~$</a> xs       = <a>bindVar</a> (o <a>.$</a> xs)
--   <a>op2</a> (*) <a>~$</a> (x :&lt; y :&lt; Ø) = <a>bindVar</a> (x * y)
--   </pre>
--   
--   So you can avoid <a>bindVar</a> altogether if you use the explicitly
--   binding <a>~$</a> and <a>opVar</a> etc.
--   
--   Note that <a>bindVar</a> on <a>BVar</a>s that are already forced is a
--   no-op.
bindVar :: Num a => BVar s rs a -> BP s rs (BVar s rs a)

-- | A version of <a>inpVars</a> taking explicit <a>Length</a>, indicating
--   the number of inputs required and their types.
--   
--   Mostly useful for rare "extremely polymorphic" situations, where GHC
--   can't infer the type and length of the list of inputs. If you ever
--   actually explicitly write down <tt>rs</tt> as a list of types, you
--   should be able to just use <a>inpVars</a>.
inpVars' :: Length rs -> Prod (BVar s rs) rs

-- | <a>bpOp</a>, but taking explicit <a>Summer</a>s and <a>Unity</a>s, for
--   the situation where the <tt>rs</tt> are not instance of <a>Num</a>.
bpOp' :: Prod Summer rs -> Prod Unity rs -> BPOp s rs a -> OpB s rs a

-- | A version of <a>bindVar</a> that requires an explicit <a>Summer</a>,
--   so that you can use it on values whose types aren't instances of
--   <a>Num</a>.
bindVar' :: Summer a -> BVar s rs a -> BP s rs (BVar s rs a)

-- | Apply an <a>OpB</a> to a <a>Prod</a> (tupling) of <a>BVar</a>s.
--   
--   If you had an <tt><a>OpB</a> s '[a, b, c] d</tt>, this function will
--   expect a 3-Prod of a <tt><a>BVar</a> s rs a</tt>, a <tt><a>BVar</a> s
--   rs b</tt>, and a <tt><a>BVar</a> s rs c</tt>, and the result will be a
--   <tt><a>BVar</a> s rs d</tt>:
--   
--   <pre>
--   myOp :: <a>OpB</a> s '[a, b, c] d
--   x    :: <a>BVar</a> s rs a
--   y    :: <a>BVar</a> s rs b
--   z    :: <a>BVar</a> s rs c
--   
--   x :&lt; y :&lt; z :&lt; Ø              :: <a>Prod</a> (<a>BVar</a> s rs) '[a, b, c]
--   <a>opVar</a> myOp (x :&lt; y :&lt; z :&lt; Ø) :: <a>BP</a> s rs (<a>BVar</a> s rs d)
--   </pre>
--   
--   Note that <a>OpB</a> is a superclass of <a>Op</a>, so you can provide
--   any <a>Op</a> here, as well (like those created by <a>op1</a>,
--   <a>op2</a>, <tt>constOp</tt>, <a>op0</a> etc.)
--   
--   <a>opVar</a> has an infix alias, <a>~$</a>, so the above example can
--   also be written as:
--   
--   <pre>
--   myOp <a>~$</a> (x :&lt; y :&lt; z :&lt; Ø) :: <a>BP</a> s rs (<a>BVar</a> s rs d)
--   </pre>
--   
--   to let you pretend that you're applying the <tt>myOp</tt> function to
--   three inputs.
--   
--   Also note the relation between <a>opVar</a> and <a>liftB</a> and
--   <a>bindVar</a>:
--   
--   <pre>
--   <a>opVar</a> o xs = <a>bindVar</a> (<a>liftB</a> o xs)
--   </pre>
--   
--   <a>opVar</a> can be thought of as a "binding" version of <a>liftB</a>.
opVar :: Num a => OpB s as a -> Prod (BVar s rs) as -> BP s rs (BVar s rs a)

-- | Infix synonym for <a>opVar</a>, which lets you pretend that you're
--   applying <a>OpB</a>s as if they were functions:
--   
--   <pre>
--   myOp :: <a>OpB</a> s '[a, b, c] d
--   x    :: <a>BVar</a> s rs a
--   y    :: <a>BVar</a> s rs b
--   z    :: <a>BVar</a> s rs c
--   
--   x :&lt; y :&lt; z :&lt; Ø           :: <a>Prod</a> (<a>BVar</a> s rs) '[a, b, c]
--   myOp <a>~$</a> (x :&lt; y :&lt; z :&lt; Ø) :: <a>BP</a> s rs (<a>BVar</a> s rs d)
--   </pre>
--   
--   Note that <a>OpB</a> is a superclass of <a>Op</a>, so you can pass in
--   any <a>Op</a> here, as well (like those created by <a>op1</a>,
--   <a>op2</a>, <tt>constOp</tt>, <a>op0</a> etc.)
--   
--   <a>~$</a> can also be thought of as a "binding" version of <a>.$</a>:
--   
--   <pre>
--   o <a>~$</a> xs = <a>bindVar</a> (o <a>.$</a> xs)
--   </pre>
(~$) :: Num a => OpB s as a -> Prod (BVar s rs) as -> BP s rs (BVar s rs a)
infixr 1 ~$

-- | Convenient wrapper over <a>opVar</a> that takes an <a>OpB</a> with one
--   argument and a single <a>BVar</a> argument. Lets you not have to type
--   out the entire <a>Prod</a>.
--   
--   <pre>
--   <a>opVar1</a> o x = <a>opVar</a> o (x <a>:&lt;</a> 'Ø')
--   
--   myOp :: <a>Op</a> '[a] b
--   x    :: <a>BVar</a> s rs a
--   
--   <a>opVar1</a> myOp x :: <a>BP</a> s rs (<a>BVar</a> s rs b)
--   </pre>
--   
--   Note that <a>OpB</a> is a superclass of <a>Op</a>, so you can pass in
--   an <a>Op</a> here (like one made with <a>op1</a>) as well.
opVar1 :: Num b => OpB s '[a] b -> BVar s rs a -> BP s rs (BVar s rs b)

-- | Convenient wrapper over <a>opVar</a> that takes an <a>OpB</a> with two
--   arguments and two <a>BVar</a> arguments. Lets you not have to type out
--   the entire <a>Prod</a>.
--   
--   <pre>
--   <a>opVar2</a> o x y = <a>opVar</a> o (x <a>:&lt;</a> y <a>:&lt;</a> 'Ø')
--   
--   myOp :: <a>Op</a> '[a, b] c
--   x    :: <a>BVar</a> s rs a
--   y    :: <a>BVar</a> s rs b
--   
--   <a>opVar2</a> myOp x y :: <a>BP</a> s rs (<a>BVar</a> s rs c)
--   </pre>
--   
--   Note that <a>OpB</a> is a superclass of <a>Op</a>, so you can pass in
--   an <a>Op</a> here (like one made with <a>op2</a>) as well.
opVar2 :: Num c => OpB s '[a, b] c -> BVar s rs a -> BVar s rs b -> BP s rs (BVar s rs c)

-- | Convenient wrapper over <a>opVar</a> that takes an <a>OpB</a> with
--   three arguments and three <a>BVar</a> arguments. Lets you not have to
--   type out the entire <a>Prod</a>.
--   
--   <pre>
--   <a>opVar3</a> o x y z = <a>opVar</a> o (x <a>:&lt;</a> y <a>:&lt;</a> z <a>:&lt;</a> 'Ø')
--   
--   myOp :: <a>Op</a> '[a, b, c] d
--   x    :: <a>BVar</a> s rs a
--   y    :: <a>BVar</a> s rs b
--   z    :: <a>BVar</a> s rs c
--   
--   <a>opVar3</a> myOp x y z :: <a>BP</a> s rs (<a>BVar</a> s rs d)
--   </pre>
--   
--   Note that <a>OpB</a> is a superclass of <a>Op</a>, so you can pass in
--   an <a>Op</a> here (like one made with <a>op3</a>) as well.
opVar3 :: Num d => OpB s '[a, b, c] d -> BVar s rs a -> BVar s rs b -> BVar s rs c -> BP s rs (BVar s rs d)

-- | Lets you treat a <tt>'BPOp s as b</tt> as an <tt><a>Op</a> as b</tt>,
--   and "apply" arguments to it just like you would with an <a>Op</a> and
--   <a>~$</a> / <a>opVar</a>.
--   
--   Basically a convenient wrapper over <a>bpOp</a>:
--   
--   <pre>
--   o <a>-$</a> xs = bpOp o <a>~$</a> xs
--   </pre>
--   
--   So for a <tt><a>BPOp</a> s as b</tt>, you can "plug in" <a>BVar</a>s
--   to <tt>as</tt>, and get a <tt>b</tt> as a result.
--   
--   Useful for running a <tt><a>BPOp</a> s rs a</tt> that you got from a
--   different function, and "plugging in" its <tt>rs</tt> inputs with
--   <a>BVar</a>s from your current environment.
(-$) :: (Every Num as, Known Length as, Num a) => BPOp s as a -> Prod (BVar s rs) as -> BPOp s rs a
infixr 1 -$

-- | A version of <a>opVar</a> taking an explicit <a>Summer</a>, so can be
--   used on values of types that aren't instances of <a>Num</a>.
opVar' :: forall s rs as a. Summer a -> OpB s as a -> Prod (BVar s rs) as -> BP s rs (BVar s rs a)

-- | A version of <a>opVar1</a> taking an explicit <a>Summer</a>, so can be
--   used on values of types that aren't instances of <a>Num</a>.
opVar1' :: Summer b -> OpB s '[a] b -> BVar s rs a -> BP s rs (BVar s rs b)

-- | A version of <a>opVar2</a> taking an explicit <a>Summer</a>, so can be
--   used on values of types that aren't instances of <a>Num</a>.
opVar2' :: Summer c -> OpB s '[a, b] c -> BVar s rs a -> BVar s rs b -> BP s rs (BVar s rs c)

-- | A version of <a>opVar3</a> taking an explicit <a>Summer</a>, so can be
--   used on values of types that aren't instances of <a>Num</a>.
opVar3' :: Summer d -> OpB s '[a, b, c] d -> BVar s rs a -> BVar s rs b -> BVar s rs c -> BP s rs (BVar s rs d)

-- | Use an <a>Iso</a> (or compatible <a>Iso</a> from the lens library) to
--   "pull out" the parts of a data type and work with each part as a
--   <a>BVar</a>.
--   
--   If there is an isomorphism between a <tt>b</tt> and a <tt><a>Tuple</a>
--   as</tt> (that is, if an <tt>a</tt> is just a container for a bunch of
--   <tt>as</tt>), then it lets you break out the <tt>as</tt> inside and
--   work with those.
--   
--   <pre>
--   data Foo = F Int Bool
--   
--   fooIso :: <a>Iso'</a> Foo (Tuple '[Int, Bool])
--   fooIso = <a>iso</a> (\(F i b)         -&gt; i ::&lt; b ::&lt; Ø)
--                (\(i ::&lt; b ::&lt; Ø) -&gt; F i b        )
--   
--   <a>partsVar</a> fooIso :: <a>BVar</a> rs Foo -&gt; <a>BP</a> s rs (<a>Prod</a> (<a>BVar</a> s rs) '[Int, Bool])
--   
--   stuff :: <a>BP</a> s '[Foo] a
--   stuff = <a>withInps</a> $ \(foo :&lt; Ø) -&gt; do
--       i :&lt; b :&lt; Ø &lt;- partsVar fooIso foo
--       -- now, i is a <a>BVar</a> pointing to the <a>Int</a> inside foo
--       -- and b is a <a>BVar</a> pointing to the <a>Bool</a> inside foo
--       -- you can do stuff with the i and b here
--   </pre>
--   
--   You can use this to pass in product types as the environment to a
--   <a>BP</a>, and then break out the type into its constituent products.
--   
--   Note that for a type like <tt>Foo</tt>, <tt>fooIso</tt> can be
--   generated automatically with <a>Generic</a> from <a>GHC.Generics</a>
--   and <a>Generic</a> from <a>Generics.SOP</a> and <i>generics-sop</i>,
--   using the <a>gTuple</a> iso. See <a>gSplit</a> for more information.
--   
--   Also, if you are literally passing a tuple (like <tt><a>BP</a> s
--   '[Tuple '[Int, Bool]</tt>) then you can give in the identity
--   isomorphism (<a>id</a>) or use <a>splitVars</a>.
partsVar :: forall s rs bs b. (Every Num bs, Known Length bs) => Iso' b (Tuple bs) -> BVar s rs b -> BP s rs (Prod (BVar s rs) bs)

-- | A useful infix alias for <a>partsVar</a>.
--   
--   Building on the example from <a>partsVar</a>:
--   
--   <pre>
--   data Foo = F Int Bool
--   
--   fooIso :: <a>Iso'</a> Foo (Tuple '[Int, Bool])
--   fooIso = <a>iso</a> (\(F i b)         -&gt; i ::&lt; b ::&lt; Ø)
--                (\(i ::&lt; b ::&lt; Ø) -&gt; F i b        )
--   
--   stuff :: <a>BP</a> s '[Foo] a
--   stuff = <a>withInps</a> $ \(foo :&lt; Ø) -&gt; do
--       i :&lt; b :&lt; Ø &lt;- fooIso <a>#&lt;~</a> foo
--       -- now, i is a <a>BVar</a> pointing to the <a>Int</a> inside foo
--       -- and b is a <a>BVar</a> pointing to the <a>Bool</a> inside foo
--       -- you can do stuff with the i and b here
--   </pre>
--   
--   See <a>gSplit</a> for an example usage of splitting up an arbitrary
--   product type (like <tt>Foo</tt>) using <a>GHC.Geneics</a> and
--   <a>Generics.SOP</a>.
(#<~) :: (Every Num bs, Known Length bs) => Iso' b (Tuple bs) -> BVar s rs b -> BP s rs (Prod (BVar s rs) bs)
infixr 1 #<~

-- | A continuation-based version of <a>partsVar</a>. Instead of binding
--   the parts and using it in the rest of the block, provide a
--   continuation to handle do stuff with the parts inside.
--   
--   Building on the example from <a>partsVar</a>:
--   
--   <pre>
--   data Foo = F Int Bool
--   
--   fooIso :: <a>Iso'</a> Foo (Tuple '[Int, Bool])
--   fooIso = <a>iso</a> (\(F i b)         -&gt; i ::&lt; b ::&lt; Ø)
--                (\(i ::&lt; b ::&lt; Ø) -&gt; F i b        )
--   
--   stuff :: <a>BP</a> s '[Foo] a
--   stuff = <a>withInps</a> $ \(foo :&lt; Ø) -&gt; do
--       <a>withParts</a> fooIso foo $ \(i :&lt; b :&lt; Ø) -&gt; do
--         -- now, i is a <a>BVar</a> pointing to the <a>Int</a> inside foo
--         -- and b is a <a>BVar</a> pointing to the <a>Bool</a> inside foo
--         -- you can do stuff with the i and b here
--   </pre>
--   
--   Useful so that you can work with the internal parts of the data type
--   in a closure, so the parts don't leak out to the rest of your
--   <a>BP</a>. But, mostly just a stylistic choice.
withParts :: (Every Num bs, Known Length bs) => Iso' b (Tuple bs) -> BVar s rs b -> (Prod (BVar s rs) bs -> BP s rs a) -> BP s rs a

-- | Split out a <a>BVar</a> of a tuple into a tuple (<a>Prod</a>) of
--   <a>BVar</a>s.
--   
--   <pre>
--   -- the environment is a single Int-Bool tuple, tup
--   stuff :: <a>BP</a> s '[ Tuple '[Int, Bool] ] a
--   stuff = <a>withInps</a> $ \(tup :&lt; Ø) -&gt; do
--       i :&lt; b :&lt; Ø &lt;- <a>splitVars</a> tup
--       -- now, i is a <a>BVar</a> pointing to the <a>Int</a> inside tup
--       -- and b is a <a>BVar</a> pointing to the <a>Bool</a> inside tup
--       -- you can do stuff with the i and b here
--   </pre>
--   
--   Note that
--   
--   <pre>
--   <a>splitVars</a> = <a>partsVar</a> <a>id</a>
--   </pre>
splitVars :: forall s rs as. (Every Num as, Known Length as) => BVar s rs (Tuple as) -> BP s rs (Prod (BVar s rs) as)

-- | Using <a>Generic</a> from <a>GHC.Generics</a> and <a>Generic</a> from
--   <a>Generics.SOP</a>, <i>split</i> a <a>BVar</a> containing a product
--   type into a tuple (<a>Prod</a>) of <a>BVar</a>s pointing to each value
--   inside.
--   
--   Building on the example from <a>partsVar</a>:
--   
--   <pre>
--   import qualified Generics.SOP as SOP
--   
--   data Foo = F Int Bool
--     deriving Generic
--   
--   instance SOP.Generic Foo
--   
--   <a>gSplit</a> :: <a>BVar</a> rs Foo -&gt; <a>BP</a> s rs (<a>Prod</a> (<a>BVar</a> s rs) '[Int, Bool])
--   
--   stuff :: <a>BP</a> s '[Foo] a
--   stuff = <a>withInps</a> $ \(foo :&lt; Ø) -&gt; do
--       i :&lt; b :&lt; Ø &lt;- <a>gSplit</a> foo
--       -- now, i is a <a>BVar</a> pointing to the <a>Int</a> inside foo
--       -- and b is a <a>BVar</a> pointing to the <a>Bool</a> inside foo
--       -- you can do stuff with the i and b here
--   </pre>
--   
--   Because <tt>Foo</tt> is a straight up product type, <a>gSplit</a> can
--   use <a>GHC.Generics</a> and take out the items inside.
--   
--   Note that because
--   
--   <pre>
--   <a>gSplit</a> = <a>splitVars</a> <a>gTuple</a>
--   </pre>
--   
--   Then, you can also use <a>gTuple</a> with <a>#&lt;~</a>:
--   
--   <pre>
--   stuff :: <a>BP</a> s '[Foo] a
--   stuff = <a>withInps</a> $ \(foo :&lt; Ø) -&gt; do
--       i :&lt; b :&lt; Ø &lt;- <a>gTuple</a> <a>#&lt;~</a> foo
--       -- now, i is a <a>BVar</a> pointing to the <a>Int</a> inside foo
--       -- and b is a <a>BVar</a> pointing to the <a>Bool</a> inside foo
--       -- you can do stuff with the i and b here
--   </pre>
gSplit :: (Every Num bs, Known Length bs, Generic b, Code b ~ '[bs]) => BVar s rs b -> BP s rs (Prod (BVar s rs) bs)

-- | An <a>Iso</a> between a type that is a product type, and a tuple that
--   contains all of its components. Uses <a>Generics.SOP</a> and the
--   <a>Generic</a> typeclass.
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Generics.SOP as SOP
--   
--   &gt;&gt;&gt; data Foo = A Int Bool      deriving Generic
--   
--   &gt;&gt;&gt; instance SOP.Generic Foo
--   
--   &gt;&gt;&gt; view gTuple (A 10 True)
--   10 ::&lt; True ::&lt; Ø
--   
--   &gt;&gt;&gt; review gTuple (15 ::&lt; False ::&lt; Ø)
--   A 15 False
--   </pre>
gTuple :: (Generic a, Code a ~ '[as]) => Iso' a (Tuple as)

-- | A version of <a>partsVar</a> taking explicit <a>Summer</a>s and
--   <a>Unity</a>s, so it can be run with internal types that aren't
--   instances of <a>Num</a>.
partsVar' :: forall s rs bs b. Prod Summer bs -> Prod Unity bs -> Iso' b (Tuple bs) -> BVar s rs b -> BP s rs (Prod (BVar s rs) bs)

-- | A version of <a>withParts</a> taking explicit <a>Summer</a>s and
--   <a>Unity</a>s, so it can be run with internal types that aren't
--   instances of <a>Num</a>.
withParts' :: Prod Summer bs -> Prod Unity bs -> Iso' b (Tuple bs) -> BVar s rs b -> (Prod (BVar s rs) bs -> BP s rs a) -> BP s rs a

-- | A version of <a>splitVars</a> taking explicit <a>Summer</a>s and
--   <a>Unity</a>s, so it can be run with types that aren't instances of
--   <a>Num</a>.
splitVars' :: forall s rs as. Prod Summer as -> Prod Unity as -> BVar s rs (Tuple as) -> BP s rs (Prod (BVar s rs) as)

-- | A version of <a>gSplit</a> taking explicit <a>Summer</a>s and
--   <a>Unity</a>s, so it can be run with internal types that aren't
--   instances of <a>Num</a>.
gSplit' :: (Generic b, Code b ~ '[bs]) => Prod Summer bs -> Prod Unity bs -> BVar s rs b -> BP s rs (Prod (BVar s rs) bs)

-- | Use an <a>Iso</a> (or compatible <a>Iso</a> from the lens library) to
--   "pull out" the different constructors of a sum type and return a
--   (choice) sum of <a>BVar</a>s that you can pattern match on.
--   
--   If there is an isomorphism between a <tt>b</tt> and a <tt><a>Sum</a>
--   <a>I</a> as</tt> (that is, if an <tt>a</tt> is just a sum type for
--   every type in <tt>as</tt>), then it lets you <i>branch</i> on which
--   constructor is used inside the <tt>b</tt>.
--   
--   Essentially implements pattern matching on <a>BVar</a> values.
--   
--   <pre>
--   data Bar = A Int | B Bool | C String
--   
--   barIso :: <a>Iso'</a> Bar (<a>Sum</a> I '[Int, Bool, String])
--   barIso = <a>iso</a> (\case A i -&gt; <a>InL</a> (I i)
--                         B b -&gt; <a>InR</a> (<a>InL</a> (I b))
--                         C s -&gt; <a>InR</a> (<a>InR</a> (<a>InL</a> (I s))
--                  )
--                  (\case <a>InL</a> (I i)           -&gt; A i
--                         <a>InR</a> (<a>InL</a> (I b))       -&gt; B b
--                         <a>InR</a> (<a>InR</a> (<a>InL</a> (I s))) -&gt; C s
--                  )
--   
--   choicesVar barIso :: BVar rs Bar -&gt; BP s rs (Sum I (BVar s rs) '[Int, Bool, String])
--   
--   stuff :: <a>BP</a> s '[Bar] a
--   stuff = <a>withInps</a> $ \(bar :&lt; Ø) -&gt; do
--       c &lt;- <a>choicesVar</a> barIso bar
--       case c of
--         <a>InL</a> i -&gt; do
--            -- in this branch, bar was made with the A constructor
--            -- i is the Int inside it
--         <a>InR</a> (<a>InL</a> b) -&gt; do
--            -- in this branch, bar was made with the B constructor
--            -- b is the Bool inside it
--         <a>InR</a> (<a>InR</a> (<a>InL</a> s)) -&gt; do
--            -- in this branch, bar was made with the B constructor
--            -- s is the String inside it
--   </pre>
--   
--   You can use this to pass in sum types as the environment to a
--   <a>BP</a>, and then branch on which constructor the value was made
--   with.
choicesVar :: forall s rs bs b. (Every Num bs, Known Length bs) => Iso' b (Sum I bs) -> BVar s rs b -> BP s rs (Sum (BVar s rs) bs)

-- | A useful infix alias for <a>choicesVar</a>.
--   
--   Building on the example from <a>choicesVar</a>:
--   
--   <pre>
--   data Bar = A Int | B Bool | C String
--   
--   barIso :: <a>Iso'</a> Bar (<a>Sum</a> I '[Int, Bool, String])
--   barIso = <a>iso</a> (\case A i -&gt; <a>InL</a> (I i)
--                         B b -&gt; <a>InR</a> (<a>InL</a> (I b))
--                         C s -&gt; <a>InR</a> (<a>InR</a> (<a>InL</a> (I s))
--                  )
--                  (\case <a>InL</a> (I i)           -&gt; A i
--                         <a>InR</a> (<a>InL</a> (I b))       -&gt; B b
--                         <a>InR</a> (<a>InR</a> (<a>InL</a> (I s))) -&gt; C s
--                  )
--   
--   stuff :: <a>BP</a> s '[Bar] a
--   stuff = <a>withInps</a> $ \(bar :&lt; Ø) -&gt; do
--       c &lt;- barIso <a>?&lt;~</a> bar
--       case c of
--         <a>InL</a> i -&gt; do
--            -- in this branch, bar was made with the A constructor
--            -- i is the Int inside it
--         <a>InR</a> (<a>InL</a> b) -&gt; do
--            -- in this branch, bar was made with the B constructor
--            -- b is the Bool inside it
--         <a>InR</a> (<a>InR</a> (<a>InL</a> s)) -&gt; do
--            -- in this branch, bar was made with the B constructor
--            -- s is the String inside it
--   </pre>
(?<~) :: (Every Num bs, Known Length bs) => Iso' b (Sum I bs) -> BVar s rs b -> BP s rs (Sum (BVar s rs) bs)
infixr 1 ?<~

-- | A continuation-based version of <a>choicesVar</a>. Instead of binding
--   the parts and using it in the rest of the block, provide a
--   continuation that will handle every possible constructor/case of the
--   type of the value the <a>BVar</a> points to.
--   
--   Building on the example from <a>choicesVar</a>:
--   
--   <pre>
--   data Bar = A Int | B Bool | C String
--   
--   barIso :: <a>Iso'</a> Bar (<a>Sum</a> I '[Int, Bool, String])
--   barIso = <a>iso</a> (\case A i -&gt; <a>InL</a> (I i)
--                         B b -&gt; <a>InR</a> (<a>InL</a> (I b))
--                         C s -&gt; <a>InR</a> (<a>InR</a> (<a>InL</a> (I s))
--                  )
--                  (\case <a>InL</a> (I i)           -&gt; A i
--                         <a>InR</a> (<a>InL</a> (I b))       -&gt; B b
--                         <a>InR</a> (<a>InR</a> (<a>InL</a> (I s))) -&gt; C s
--                  )
--   
--   <a>choicesVar</a> barIso :: BVar rs Bar -&gt; BP s rs (Sum I (BVar s rs) '[Int, Bool, String])
--   
--   stuff :: <a>BP</a> s '[Bar] a
--   stuff = <a>withInps</a> $ \(bar :&lt; Ø) -&gt; do
--       <a>withChoices</a> barIso bar $ case
--         <a>InL</a> i -&gt; do
--            -- in this branch, bar was made with the A constructor
--            -- i is the Int inside it
--         <a>InR</a> (<a>InL</a> b) -&gt; do
--            -- in this branch, bar was made with the B constructor
--            -- b is the Bool inside it
--         <a>InR</a> (<a>InR</a> (<a>InL</a> s)) -&gt; do
--            -- in this branch, bar was made with the B constructor
--            -- s is the String inside it
--   </pre>
--   
--   Nicer than <a>choicesVar</a> directly, because you don't have to give
--   the result a superfluous name before pattern matching on it. You can
--   just directly pattern match in the lambda, so there's a lot less
--   syntactical noise.
withChoices :: forall s rs bs b a. (Every Num bs, Known Length bs) => Iso' b (Sum I bs) -> BVar s rs b -> (Sum (BVar s rs) bs -> BP s rs a) -> BP s rs a

-- | A version of <a>choicesVar</a> taking explicit <a>Summer</a>s and
--   <a>Unity</a>s, so it can be run with internal types that aren't
--   instances of <a>Num</a>.
choicesVar' :: forall s rs bs b. Prod Summer bs -> Prod Unity bs -> Iso' b (Sum I bs) -> BVar s rs b -> BP s rs (Sum (BVar s rs) bs)

-- | A version of <a>withChoices</a> taking explicit <a>Summer</a>s and
--   <a>Unity</a>s, so it can be run with internal types that aren't
--   instances of <a>Num</a>.
withChoices' :: forall s rs bs b a. Prod Summer bs -> Prod Unity bs -> Iso' b (Sum I bs) -> BVar s rs b -> (Sum (BVar s rs) bs -> BP s rs a) -> BP s rs a

-- | A combination of <a>partsVar</a> and <a>choicesVar</a>, that lets you
--   split a type into a sum of products. Using an <a>Iso</a> (or
--   compatible <a>Iso</a> from the lens library), you can pull out a type
--   that is a sum of products into a sum of products of <a>BVar</a>s.
--   
--   Implements branching on the constructors of a value that a <a>BVar</a>
--   contains, and also splitting out the different items inside each
--   constructor.
--   
--   <pre>
--   data Baz = A Int    Bool
--            | B String Double
--   
--   
--   bazIso :: <a>Iso'</a> Baz (<a>Sum</a> <a>Tuple</a> '[ '[Int, Bool], '[String, Double] ])
--   bazIso = <a>iso</a> (\case A i b -&gt; <a>InL</a> (I (i ::&lt; b ::&lt; Ø))
--                         B s d -&gt; <a>InR</a> (<a>InL</a> (I (s ::&lt; d ::&lt; Ø)))
--                  )
--                  (\case <a>InL</a> (I (i ::<a>::&lt; Ø))     -</a> A i b
--                         <a>InR</a> (<a>InL</a> (I (s ::<a>::&lt; Ø))) -</a> B s d
--                  )
--   
--   <a>sopVar</a> bazIso :: <a>BVar</a> rs Baz -&gt; <a>BP</a> s rs (<a>Sum</a> (<a>Prod</a> (<a>BVar</a> s rs)) '[ '[Int, Bool], '[String, Double] ])
--   
--   stuff :: <a>BP</a> s '[Baz] a
--   stuff = <a>withInps</a> $ \(baz :&lt; Ø) -&gt; do
--       c &lt;- <a>sopVar</a> barIso baz
--       case c of
--         <a>InL</a> (i :<a>:&lt; Ø) -</a> do
--            -- in this branch, baz was made with the A constructor
--            -- i and b are the Int and Bool inside it
--         <a>InR</a> (<a>InL</a> (s :<a>:&lt; Ø)) -</a> do
--            -- in this branch, baz was made with the B constructor
--            -- s and d are the String and Double inside it
--   </pre>
--   
--   Essentially exists to implement "pattern matching" on multiple
--   constructors and fields for the value inside a <a>BVar</a>.
--   
--   Note that for a type like <tt>Baz</tt>, <tt>bazIso</tt> can be
--   generated automatically with <a>Generic</a> from <a>GHC.Generics</a>
--   and <a>Generic</a> from <a>Generics.SOP</a> and <i>generics-sop</i>,
--   with <a>gSOP</a>. See <a>gSplits</a> for more information.
sopVar :: forall s rs bss b. (Known Length bss, Every (Every Num ∧ Known Length) bss) => Iso' b (Sum Tuple bss) -> BVar s rs b -> BP s rs (Sum (Prod (BVar s rs)) bss)

-- | Using <a>Generic</a> from <a>GHC.Generics</a> and <a>Generic</a> from
--   <a>Generics.SOP</a>, <i>split</i> a <a>BVar</a> containing a sum of
--   products (any simple ADT, essentialy) into a <a>Sum</a> of each
--   constructor, each containing a tuple (<a>Prod</a>) of <a>BVar</a>s
--   pointing to each value inside.
--   
--   Building on the example from <a>sopVar</a>:
--   
--   <pre>
--   import qualified Generics.SOP as SOP
--   
--   data Baz = A Int    Bool
--            | B String Double
--     deriving Generic
--   
--   instance SOP.Generic Baz
--   
--   <a>gSplits</a> :: <a>BVar</a> rs Baz -&gt; <a>BP</a> s rs (<a>Sum</a> (<a>Prod</a> (<a>BVar</a> s rs)) '[ '[Int, Bool], '[String, Double] ])
--   
--   stuff :: <a>BP</a> s '[Baz] a
--   stuff = <a>withInps</a> $ \(baz :&lt; Ø) -&gt; do
--       c &lt;- gSplits baz
--       case c of
--         <a>InL</a> (i :<a>:&lt; Ø) -</a> do
--            -- in this branch, baz was made with the A constructor
--            -- i and b are the Int and Bool inside it
--         <a>InR</a> (<a>InL</a> (s :<a>:&lt; Ø)) -</a> do
--            -- in this branch, baz was made with the B constructor
--            -- s and d are the String and Double inside it
--   </pre>
--   
--   Because <tt>Foo</tt> is a straight up sum-of-products type,
--   <a>gSplits</a> can use <a>GHC.Generics</a> and take out the items
--   inside.
--   
--   Note:
--   
--   <pre>
--   <a>gSplit</a> = <a>splitVars</a> <a>gSOP</a>
--   </pre>
gSplits :: forall s rs b. (Generic b, Known Length (Code b), Every (Every Num ∧ Known Length) (Code b)) => BVar s rs b -> BP s rs (Sum (Prod (BVar s rs)) (Code b))

-- | An <a>Iso</a> between a sum type whose constructors are products, and
--   a sum (<a>Sum</a>) of products (<a>Tuple</a>). Uses
--   <a>Generics.SOP</a> and the <a>Generic</a> typeclass.
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Generics.SOP as SOP
--   
--   &gt;&gt;&gt; data Bar = A Int Bool | B String Double
--   
--   &gt;&gt;&gt; instance SOP.Generic Bar
--   
--   &gt;&gt;&gt; 'view' 'gSOP' (A 10 True)
--   'InL' (10 ::&lt; True ::&lt; Ø)
--   
--   &gt;&gt;&gt; 'view' 'gSOP' (B "hello" 3.4)
--   'InR' ('InL' ("hello" ::&lt; 3.4 ::&lt; Ø))
--   
--   &gt;&gt;&gt; 'review' 'gTuple' ('InL' (15 ::&lt; False ::&lt; Ø))
--   A 15 False
--   
--   &gt;&gt;&gt; 'review' 'gTuple' ('InR' ('InL' ("bye" ::&lt; 9.8 ::&lt; Ø)))
--   B "bye" 9.8
--   </pre>
gSOP :: Generic a => Iso' a (Sum Tuple (Code a))

-- | A version of <a>sopVar</a> taking explicit <a>Summer</a>s and
--   <a>Unity</a>s, so it can be run with internal types that aren't
--   instances of <a>Num</a>.
sopVar' :: forall s rs bss b. Prod (Prod Summer) bss -> Prod (Prod Unity) bss -> Iso' b (Sum Tuple bss) -> BVar s rs b -> BP s rs (Sum (Prod (BVar s rs)) bss)

-- | A version of <a>gSplits</a> taking explicit <a>Summer</a>s and
--   <a>Unity</a>s, so it can be run with internal types that aren't
--   instances of <a>Num</a>.
gSplits' :: forall s rs b. Generic b => Prod (Prod Summer) (Code b) -> Prod (Prod Unity) (Code b) -> BVar s rs b -> BP s rs (Sum (Prod (BVar s rs)) (Code b))

-- | Apply <a>OpB</a> over a <a>Prod</a> of <a>BVar</a>s, as inputs.
--   Provides "implicit" backpropagation, with deferred evaluation.
--   
--   If you had an <tt><a>OpB</a> s '[a, b, c] d</tt>, this function will
--   expect a 3-Prod of a <tt><a>BVar</a> s rs a</tt>, a <tt><a>BVar</a> s
--   rs b</tt>, and a <tt><a>BVar</a> s rs c</tt>, and the result will be a
--   <tt><a>BVar</a> s rs d</tt>:
--   
--   <pre>
--   myOp :: <a>OpB</a> s '[a, b, c] d
--   x    :: <a>BVar</a> s rs a
--   y    :: <a>BVar</a> s rs b
--   z    :: <a>BVar</a> s rs c
--   
--   x :&lt; y :&lt; z :&lt; Ø              :: <a>Prod</a> (<a>BVar</a> s rs) '[a, b, c]
--   <a>liftB</a> myOp (x :&lt; y :&lt; z :&lt; Ø) :: <a>BVar</a> s rs d
--   </pre>
--   
--   Note that <a>OpB</a> is a superclass of <a>Op</a>, so you can provide
--   any <a>Op</a> here, as well (like those created by <a>op1</a>,
--   <a>op2</a>, <tt>constOp</tt>, <a>op0</a> etc.)
--   
--   <a>opVar</a> has an infix alias, <a>.$</a>, so the above example can
--   also be written as:
--   
--   <pre>
--   myOp <a>.$</a> (x :&lt; y :&lt; z :&lt; Ø) :: <a>BVar</a> s rs d
--   </pre>
--   
--   to let you pretend that you're applying the <tt>myOp</tt> function to
--   three inputs.
--   
--   The result is a new <i>deferred</i> <a>BVar</a>. This should be fine
--   in most cases, unless you use the result in more than one location.
--   This will cause evaluation to be duplicated and multiple redundant
--   graph nodes to be created. If you need to use it in two locations, you
--   should use <a>opVar</a> instead of <a>liftB</a>, or use
--   <a>bindVar</a>:
--   
--   <pre>
--   <a>opVar</a> o xs = <a>bindVar</a> (<a>liftB</a> o xs)
--   </pre>
--   
--   <a>liftB</a> can be thought of as a "deferred evaluation" version of
--   <a>liftB</a>.
liftB :: OpB s as a -> Prod (BVar s rs) as -> BVar s rs a

-- | Infix synonym for <a>liftB</a>, which lets you pretend that you're
--   applying <a>OpB</a>s as if they were functions:
--   
--   <pre>
--   myOp :: <a>OpB</a> s '[a, b, c] d
--   x    :: <a>BVar</a> s rs a
--   y    :: <a>BVar</a> s rs b
--   z    :: <a>BVar</a> s rs c
--   
--   x :&lt; y :&lt; z :&lt; Ø           :: <a>Prod</a> (<a>BVar</a> s rs) '[a, b, c]
--   myOp <a>.$</a> (x :&lt; y :&lt; z :&lt; Ø) :: <a>BVar</a> s rs d
--   </pre>
--   
--   Note that <a>OpB</a> is a superclass of <a>Op</a>, so you can pass in
--   any <a>Op</a> here, as well (like those created by <a>op1</a>,
--   <a>op2</a>, <tt>constOp</tt>, <a>op0</a> etc.)
--   
--   See the documentation for <a>liftB</a> for all the caveats of this
--   usage.
--   
--   <a>.$</a> can also be thought of as a "deferred evaluation" version of
--   <a>~$</a>:
--   
--   <pre>
--   o <a>~$</a> xs = <a>bindVar</a> (o <a>.$</a> xs)
--   </pre>
(.$) :: OpB s as a -> Prod (BVar s rs) as -> BVar s rs a
infixr 1 .$

-- | Convenient wrapper over <a>liftB</a> that takes an <a>OpB</a> with one
--   argument and a single <a>BVar</a> argument. Lets you not have to type
--   out the entire <a>Prod</a>.
--   
--   <pre>
--   <a>liftB1</a> o x = <a>liftB</a> o (x <a>:&lt;</a> 'Ø')
--   
--   myOp :: <a>Op</a> '[a] b
--   x    :: <a>BVar</a> s rs a
--   
--   <a>liftB1</a> myOp x :: <a>BVar</a> s rs b
--   </pre>
--   
--   Note that <a>OpB</a> is a superclass of <a>Op</a>, so you can pass in
--   an <a>Op</a> here (like one made with <a>op1</a>) as well.
--   
--   See the documentation for <a>liftB</a> for caveats and potential
--   problematic situations with this.
liftB1 :: OpB s '[a] b -> BVar s rs a -> BVar s rs b

-- | Convenient wrapper over <a>liftB</a> that takes an <a>OpB</a> with two
--   arguments and two <a>BVar</a> arguments. Lets you not have to type out
--   the entire <a>Prod</a>.
--   
--   <pre>
--   <a>liftB2</a> o x y = <a>liftB</a> o (x <a>:&lt;</a> y <a>:&lt;</a> 'Ø')
--   
--   myOp :: <a>Op</a> '[a, b] c
--   x    :: <a>BVar</a> s rs a
--   y    :: <a>BVar</a> s rs b
--   
--   <a>liftB2</a> myOp x y :: <a>BVar</a> s rs c
--   </pre>
--   
--   Note that <a>OpB</a> is a superclass of <a>Op</a>, so you can pass in
--   an <a>Op</a> here (like one made with <a>op2</a>) as well.
--   
--   See the documentation for <a>liftB</a> for caveats and potential
--   problematic situations with this.
liftB2 :: OpB s '[a, b] c -> BVar s rs a -> BVar s rs b -> BVar s rs c

-- | Convenient wrapper over <a>liftB</a> that takes an <a>OpB</a> with
--   three arguments and three <a>BVar</a> arguments. Lets you not have to
--   type out the entire <a>Prod</a>.
--   
--   <pre>
--   <a>liftB3</a> o x y z = <a>liftB</a> o (x <a>:&lt;</a> y <a>:&lt;</a> z <a>:&lt;</a> 'Ø')
--   
--   myOp :: <a>Op</a> '[a, b, c] d
--   x    :: <a>BVar</a> s rs a
--   y    :: <a>BVar</a> s rs b
--   z    :: <a>BVar</a> s rs c
--   
--   <a>liftB3</a> myOp x y z :: <a>BVar</a> s rs d
--   </pre>
--   
--   Note that <a>OpB</a> is a superclass of <a>Op</a>, so you can pass in
--   an <a>Op</a> here (like one made with <a>op3</a>) as well.
--   
--   See the documentation for <a>liftB</a> for caveats and potential
--   problematic situations with this.
liftB3 :: OpB s '[a, b, c] d -> BVar s rs a -> BVar s rs b -> BVar s rs c -> BVar s rs d

-- | Automatically create an <a>Op</a> of a numerical function taking one
--   argument. Uses <a>diff</a>, and so can take any numerical function
--   polymorphic over the standard numeric types.
--   
--   <pre>
--   &gt;&gt;&gt; gradOp' (op1 (recip . negate)) (5 ::&lt; Ø)
--   (-0.2, 0.04 ::&lt; Ø)
--   </pre>
op1 :: Num a => (forall s. AD s (Forward a) -> AD s (Forward a)) -> Op '[a] a

-- | Automatically create an <a>Op</a> of a numerical function taking two
--   arguments. Uses <a>grad</a>, and so can take any numerical function
--   polymorphic over the standard numeric types.
--   
--   <pre>
--   &gt;&gt;&gt; gradOp' (op2 (\x y -&gt; x * sqrt y)) (3 ::&lt; 4 ::&lt; Ø)
--   (6.0, 2.0 ::&lt; 0.75 ::&lt; Ø)
--   </pre>
op2 :: Num a => (forall s. Reifies s Tape => Reverse s a -> Reverse s a -> Reverse s a) -> Op '[a, a] a

-- | Automatically create an <a>Op</a> of a numerical function taking three
--   arguments. Uses <a>grad</a>, and so can take any numerical function
--   polymorphic over the standard numeric types.
--   
--   <pre>
--   &gt;&gt;&gt; gradOp' (op3 (\x y z -&gt; (x * sqrt y)**z)) (3 ::&lt; 4 ::&lt; 2 ::&lt; Ø)
--   (36.0, 24.0 ::&lt; 9.0 ::&lt; 64.503 ::&lt; Ø)
--   </pre>
op3 :: Num a => (forall s. Reifies s Tape => Reverse s a -> Reverse s a -> Reverse s a -> Reverse s a) -> Op '[a, a, a] a

-- | Automatically create an <a>Op</a> of a numerical function taking
--   multiple arguments. Uses <a>grad</a>, and so can take any numerical
--   function polymorphic over the standard numeric types.
--   
--   <pre>
--   &gt;&gt;&gt; gradOp' (opN (\(x :+ y :+ Ø) -&gt; x * sqrt y)) (3 ::&lt; 4 ::&lt; Ø)
--   (6.0, 2.0 ::&lt; 0.75 ::&lt; Ø)
--   </pre>
opN :: (Num a, Known Nat n) => (forall s. Reifies s Tape => Vec n (Reverse s a) -> Reverse s a) -> Op (Replicate n a) a

-- | Create an <a>Op</a> of a function taking one input, by giving its
--   explicit derivative. The function should return a tuple containing the
--   result of the function, and also a function taking the derivative of
--   the result and return the derivative of the input.
--   
--   If we have
--   
--   &lt;math&gt;
--   
--   Then the derivative &lt;math&gt;, it would be:
--   
--   &lt;math&gt;
--   
--   If our <a>Op</a> represents &lt;math&gt;, then the second item in the
--   resulting tuple should be a function that takes &lt;math&gt; and
--   returns &lt;math&gt;.
--   
--   If the input is <a>Nothing</a>, then &lt;math&gt; should be taken to
--   be &lt;math&gt;.
--   
--   As an example, here is an <a>Op</a> that squares its input:
--   
--   <pre>
--   square :: Num a =&gt; <a>Op</a> '[a] a
--   square = <a>op1'</a> $ \x -&gt; (x*x, \case Nothing -&gt; 2 * x
--                                     Just d  -&gt; 2 * d * x
--                         )
--   </pre>
--   
--   Remember that, generally, end users shouldn't directly construct
--   <a>Op</a>s; they should be provided by libraries or generated
--   automatically.
--   
--   For numeric functions, single-input <a>Op</a>s can be generated
--   automatically using <a>op1</a>.
op1' :: (a -> (b, Maybe b -> a)) -> Op '[a] b

-- | Create an <a>Op</a> of a function taking two inputs, by giving its
--   explicit gradient. The function should return a tuple containing the
--   result of the function, and also a function taking the derivative of
--   the result and return the derivative of the input.
--   
--   If we have
--   
--   &lt;math&gt;
--   
--   Then the gradient &lt;math&gt; would be:
--   
--   &lt;math&gt;
--   
--   If our <a>Op</a> represents &lt;math&gt;, then the second item in the
--   resulting tuple should be a function that takes &lt;math&gt; and
--   returns &lt;math&gt;.
--   
--   If the input is <a>Nothing</a>, then &lt;math&gt; should be taken to
--   be &lt;math&gt;.
--   
--   As an example, here is an <a>Op</a> that multiplies its inputs:
--   
--   <pre>
--   mul :: Num a =&gt; <a>Op</a> '[a, a] a
--   mul = <a>op2'</a> $ \x y -&gt; (x*y, \case Nothing -&gt; (y  , x  )
--                                    Just d  -&gt; (d*y, x*d)
--                        )
--   </pre>
--   
--   Remember that, generally, end users shouldn't directly construct
--   <a>Op</a>s; they should be provided by libraries or generated
--   automatically.
--   
--   For numeric functions, two-input <a>Op</a>s can be generated
--   automatically using <a>op2</a>.
op2' :: (a -> b -> (c, Maybe c -> (a, b))) -> Op '[a, b] c

-- | Create an <a>Op</a> of a function taking three inputs, by giving its
--   explicit gradient. See documentation for <a>op2'</a> for more details.
op3' :: (a -> b -> c -> (d, Maybe d -> (a, b, c))) -> Op '[a, b, c] d

-- | Construct a two element Prod. Since the precedence of (:&gt;) is
--   higher than (:&lt;), we can conveniently write lists like:
--   
--   <pre>
--   &gt;&gt;&gt; a :&lt; b :&gt; c
--   </pre>
--   
--   Which is identical to:
--   
--   <pre>
--   &gt;&gt;&gt; a :&lt; b :&lt; c :&lt; Ø
--   </pre>
infix 6 :>

-- | Build a singleton Prod.
only :: f a -> Prod k f ((:) k a ([] k))
head' :: Prod k f ((:<) k a as) -> f a

-- | Cons onto a Tuple.
infixr 5 ::<

-- | Singleton Tuple.
only_ :: a -> Tuple ((:) * a ([] *))

-- | Instructions on how to "sum" a list of values of a given type.
--   Basically used as an explicit witness for a <a>Num</a> instance.
--   
--   For most types, the only meaningful value of type <tt><a>Summer</a>
--   a</tt> is <tt><a>Summer</a> <a>sum</a></tt>. However, using
--   <a>Summer</a> lets us use <tt>BP</tt> with types that are <i>not</i>
--   instances of <a>Num</a>. Any type can be used, as long as you provide
--   a way to "sum" it!
--   
--   For most of the functions in this library, you can completely ignore
--   this, as they will be generated automatically. You only need to work
--   with this directly if you want to use custom types that <i>aren't</i>
--   instances of <a>Num</a> with this library.
--   
--   If 'Num a' is satisfied, one can create the canonical <a>Summer</a>
--   using <tt><a>known</a> :: <a>Num</a> a =&gt; <a>Summer</a> a</tt>.
newtype Summer a
Summer :: ([a] -> a) -> Summer a
[runSummer] :: Summer a -> [a] -> a

-- | A canonical "unity" (the multiplicative identity) for a given type.
--   Basically used as an explicit witness for a <a>Num</a> instance.
--   
--   For most types, the only meaningful value of type <tt><a>Unity</a>
--   a</tt> is <tt><a>Unity</a> 1'</tt>. However, using <a>Unity</a> lets
--   us use <tt>BP</tt> with types that are <i>not</i> instances of
--   <a>Num</a>. Any type can be used, as long as you provide a way to get
--   a multiplicative identity in it!
--   
--   For most of the functions in this library, you can completely ignore
--   this, as they will be generated automatically. You only need to work
--   with this directly if you want to use custom types that <i>aren't</i>
--   instances of <a>Num</a> with this library.
--   
--   If 'Num a' is satisfied, one can create the canonical <a>Unity</a>
--   using <tt><a>known</a> :: <a>Num</a> a =&gt; <a>Unity</a> a</tt>.
newtype Unity a
Unity :: a -> Unity a
[getUnity] :: Unity a -> a

-- | If all the types in <tt>as</tt> are instances of <a>Num</a>, generate
--   a <tt><a>Prod</a> <a>Summer</a> as</tt>, or a tuple of <a>Summer</a>s
--   for every type in <tt>as</tt>.
summers :: (Every Num as, Known Length as) => Prod Summer as

-- | If all the types in <tt>as</tt> are instances of <a>Num</a>, generate
--   a <tt><a>Prod</a> <a>Unity</a> as</tt>, or a tuple of <a>Unity</a>s
--   for every type in <tt>as</tt>.
unities :: (Every Num as, Known Length as) => Prod Unity as

-- | Like <a>summers</a>, but requiring an explicit witness for the number
--   of types in the list <tt>as</tt>.
summers' :: Every Num as => Length as -> Prod Summer as

-- | Like <a>unities</a>, but requiring an explicit witness for the number
--   of types in the list <tt>as</tt>.
unities' :: Every Num as => Length as -> Prod Unity as


-- | Offers full functionality for implicit-graph backpropagation. The main
--   function, <a>backprop</a>, takes a function from <a>BVar</a>s to a
--   result <a>BVar</a>. These <a>BVar</a>s can be manipulated using their
--   <a>Num</a> / <a>Fractional</a> / <a>Floating</a> instances, and the
--   library can perform backpropagation on the function by using an
--   implicitly built graph.
--   
--   This should actually be powerful enough for most use cases, but falls
--   short for a couple of situations:
--   
--   <ol>
--   <li>If the result of a function on <a>BVar</a>s is used twice (like
--   <tt>z</tt> in <tt>let z = x * y in z + z</tt>), this will allocate a
--   new redundant graph node for every usage site of <tt>z</tt>. You can
--   explicitly <i>force</i> <tt>z</tt>, but only using an explicit graph
--   description using <a>Numeric.Backprop</a>.</li>
--   <li>This can't handle sum types, like <a>Numeric.Backprop</a> can. You
--   can never pattern match on the constructors of a value inside a
--   <a>BVar</a>. I'm not sure if this is a fundamental limitation (I
--   suspect it might be) or if I just can't figure out how to implement
--   it. Suggestions welcome!</li>
--   </ol>
module Numeric.Backprop.Implicit

-- | The basic unit of manipulation inside <a>BP</a>. Instead of directly
--   working with values, you work with <a>BVar</a>s contating those
--   values. When you work with a <a>BVar</a>, the <i>backprop</i> library
--   can keep track of what values refer to which other values, and so can
--   perform backpropagation to compute gradients.
--   
--   A <tt><a>BVar</a> s rs a</tt> refers to a value of type <tt>a</tt>,
--   with an environment of values of the types <tt>rs</tt>. The phantom
--   parameter <tt>s</tt> is used to ensure that stray <a>BVar</a>s don't
--   leak outside of the backprop process.
--   
--   (That is, if you're using implicit backprop, it ensures that you
--   interact with <a>BVar</a>s in a polymorphic way. And, if you're using
--   implicit backprop, it ensures that a <tt><a>BVar</a> s rs a</tt> never
--   leaves the <tt><a>BP</a> s rs</tt> that it was created in.)
--   
--   <a>BVar</a>s have <a>Num</a>, <a>Fractional</a>, <a>Floating</a>, etc.
--   instances, so they can be manipulated using polymorphic functions and
--   numeric functions in Haskell. You can add them, subtract them, etc.,
--   in "implicit" backprop style.
--   
--   (However, note that if you directly manipulate <a>BVar</a>s using
--   those instances or using <a>liftB</a>, it delays evaluation, so every
--   usage site has to re-compute the result/create a new node. If you want
--   to re-use a <a>BVar</a> you created using <a>+</a> or <a>-</a> or
--   <a>liftB</a>, use <a>bindVar</a> to force it first. See documentation
--   for <a>bindVar</a> for more details.)
data BVar :: Type -> [Type] -> Type -> Type

-- | An operation on <a>BVar</a>s that can be backpropagated. A value of
--   type:
--   
--   <pre>
--   <a>BPOp</a> rs a
--   </pre>
--   
--   takes a bunch of <a>BVar</a>s containg <tt>rs</tt> and uses them to
--   (purely) produce a <a>BVar</a> containing an <tt>a</tt>.
--   
--   <pre>
--   foo :: BPOp '[ Double, Double ] Float
--   foo (x :&lt; y :&lt; Ø) = x + sqrt y
--   </pre>
--   
--   <a>BPOp</a> here is related to <a>BPOpI</a> from the normal
--   explicit-graph backprop module <a>Numeric.Backprop</a>.
type BPOp rs a = forall s. Prod (BVar s rs) rs -> BVar s rs a

-- | An <tt><a>Op</a> as a</tt> is a type synonym over <a>OpM</a> that
--   describes a differentiable function from <tt>as</tt> to <tt>a</tt>.
--   
--   For example, an
--   
--   <pre>
--   <a>Op</a> '[Int, Bool] Double
--   </pre>
--   
--   is a function from an <a>Int</a> and a <a>Bool</a>, returning a
--   <a>Double</a>. It can be differentiated to give a <i>gradient</i> of
--   an <a>Int</a> and a <a>Bool</a> if given a total derivative for
--   <tt>a</tt>.
--   
--   See <a>runOp</a>, <a>gradOp</a>, and <a>gradOpWith</a> for examples on
--   how to run it, and <a>Op</a> for instructions on creating it.
--   
--   This type is abstracted over using the pattern synonym with
--   constructor <a>Op</a>, so you can create one from scratch with it.
--   However, it's simplest to create it using <a>op2'</a>, <a>op1'</a>,
--   <a>op2'</a>, and <a>op3'</a> helper smart constructors And, if your
--   function is a numeric function, they can even be created automatically
--   using <a>op1</a>, <a>op2</a>, <a>op3</a>, and <a>opN</a> with a little
--   help from <a>Numeric.AD</a> from the <i>ad</i> library.
--   
--   Note that this type is a <i>subset</i> or <i>subtype</i> of
--   <a>OpM</a>. So, if a function ever expects an <tt><a>OpM</a> m as
--   a</tt>, you can always provide an <tt><a>Op</a> as a</tt> instead.
--   
--   Many functions in this library will expect an <tt><a>OpM</a> m as
--   a</tt> (or an <tt><a>OpB</a> s as a</tt>), and in all of these cases,
--   you can provide an <tt><a>Op</a> as a</tt>.
type Op as a = forall m. Monad m => OpM m as a

-- | A type synonym for <a>OpM</a> specialized to what the <i>backprop</i>
--   library uses to perform backpropagation.
--   
--   An
--   
--   <pre>
--   <a>OpB</a> s rs a
--   </pre>
--   
--   represents a differentiable function that takes a tuple of <tt>rs</tt>
--   and produces an a <tt>a</tt>, which can be run on <tt><a>BVar</a>
--   s</tt> and also inside <tt><a>BP</a> s</tt>s. For example, an
--   <tt><a>OpB</a> s '[ Int, Double ] Bool</tt> takes an <a>Int</a> and a
--   <a>Double</a> and produces a <a>Bool</a>, and does it in a
--   differentiable way.
--   
--   Note that <a>OpB</a> is a <i>superset</i> of <a>Op</a>, so, if you see
--   any function that expects an <a>OpB</a> (like <a>opVar'</a> and
--   <a>~$</a>, for example), you can give them an <a>Op</a>, as well.
--   
--   You can think of <a>OpB</a> as a superclass/parent class of <a>Op</a>
--   in this sense, and of <a>Op</a> as a subclass of <a>OpB</a>.
type OpB s as a = OpM (ST s) as a
data Prod k (f :: k -> *) (a :: [k]) :: forall k. (k -> *) -> [k] -> *
[Ø] :: Prod k f ([] k)
[:<] :: Prod k f ((:) k a1 as)

-- | A Prod of simple Haskell types.
type Tuple = Prod * I

-- | Run backpropagation on a <a>BPOp</a> function, getting both the result
--   and the gradient of the result with respect to the inputs.
--   
--   <pre>
--   foo :: <a>BPOp</a> '[Double, Double] Double
--   foo (x :&lt; y :&lt; Ø) =
--     let z = x * sqrt y
--     in  z + x ** y
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; backprop foo (2 ::&lt; 3 ::&lt; Ø)
--   (11.46, 13.73 ::&lt; 6.12 ::&lt; Ø)
--   </pre>
backprop :: (Known Length rs, Every Num rs) => BPOp rs a -> Tuple rs -> (a, Tuple rs)

-- | Run the <a>BPOp</a> on an input tuple and return the gradient of the
--   result with respect to the input tuple.
--   
--   <pre>
--   foo :: <a>BPOp</a> '[Double, Double] Double
--   foo (x :&lt; y :&lt; Ø) =
--     let z = x * sqrt y
--     in  z + x ** y
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; grad foo (2 ::&lt; 3 ::&lt; Ø)
--   13.73 ::&lt; 6.12 ::&lt; Ø
--   </pre>
grad :: (Known Length rs, Every Num rs) => BPOp rs a -> Tuple rs -> Tuple rs

-- | Simply run the <a>BPOp</a> on an input tuple, getting the result
--   without bothering with the gradient or with backpropagation.
--   
--   <pre>
--   foo :: <a>BPOp</a> '[Double, Double] Double
--   foo (x :&lt; y :&lt; Ø) =
--     let z = x * sqrt y
--     in  z + x ** y
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; eval foo (2 ::&lt; 3 ::&lt; Ø)
--   11.46
--   </pre>
eval :: (Known Length rs, Every Num rs) => BPOp rs a -> Tuple rs -> a

-- | A version of <a>backprop</a> taking explicit <a>Summer</a>s and
--   <a>Unity</a>s, so it can be run with types that aren't instances of
--   <a>Num</a>.
backprop' :: Prod Summer rs -> Prod Unity rs -> BPOp rs a -> Tuple rs -> (a, Tuple rs)

-- | A version of <a>grad</a> taking explicit <a>Summer</a>s and
--   <a>Unity</a>s, so it can be run with types that aren't instances of
--   <a>Num</a>.
grad' :: Prod Summer rs -> Prod Unity rs -> BPOp rs a -> Tuple rs -> Tuple rs

-- | Create a <a>BVar</a> that represents just a specific value, that
--   doesn't depend on any other <a>BVar</a>s.
constVar :: a -> BVar s rs a

-- | Apply <a>OpB</a> over a <a>Prod</a> of <a>BVar</a>s, as inputs.
--   Provides "implicit" backpropagation, with deferred evaluation.
--   
--   If you had an <tt><a>OpB</a> s '[a, b, c] d</tt>, this function will
--   expect a 3-Prod of a <tt><a>BVar</a> s rs a</tt>, a <tt><a>BVar</a> s
--   rs b</tt>, and a <tt><a>BVar</a> s rs c</tt>, and the result will be a
--   <tt><a>BVar</a> s rs d</tt>:
--   
--   <pre>
--   myOp :: <a>OpB</a> s '[a, b, c] d
--   x    :: <a>BVar</a> s rs a
--   y    :: <a>BVar</a> s rs b
--   z    :: <a>BVar</a> s rs c
--   
--   x :&lt; y :&lt; z :&lt; Ø              :: <a>Prod</a> (<a>BVar</a> s rs) '[a, b, c]
--   <a>liftB</a> myOp (x :&lt; y :&lt; z :&lt; Ø) :: <a>BVar</a> s rs d
--   </pre>
--   
--   Note that <a>OpB</a> is a superclass of <a>Op</a>, so you can provide
--   any <a>Op</a> here, as well (like those created by <a>op1</a>,
--   <a>op2</a>, <tt>constOp</tt>, <a>op0</a> etc.)
--   
--   <a>opVar</a> has an infix alias, <a>.$</a>, so the above example can
--   also be written as:
--   
--   <pre>
--   myOp <a>.$</a> (x :&lt; y :&lt; z :&lt; Ø) :: <a>BVar</a> s rs d
--   </pre>
--   
--   to let you pretend that you're applying the <tt>myOp</tt> function to
--   three inputs.
--   
--   The result is a new <i>deferred</i> <a>BVar</a>. This should be fine
--   in most cases, unless you use the result in more than one location.
--   This will cause evaluation to be duplicated and multiple redundant
--   graph nodes to be created. If you need to use it in two locations, you
--   should use <a>opVar</a> instead of <a>liftB</a>, or use
--   <a>bindVar</a>:
--   
--   <pre>
--   <a>opVar</a> o xs = <a>bindVar</a> (<a>liftB</a> o xs)
--   </pre>
--   
--   <a>liftB</a> can be thought of as a "deferred evaluation" version of
--   <a>liftB</a>.
liftB :: OpB s as a -> Prod (BVar s rs) as -> BVar s rs a

-- | Infix synonym for <a>liftB</a>, which lets you pretend that you're
--   applying <a>OpB</a>s as if they were functions:
--   
--   <pre>
--   myOp :: <a>OpB</a> s '[a, b, c] d
--   x    :: <a>BVar</a> s rs a
--   y    :: <a>BVar</a> s rs b
--   z    :: <a>BVar</a> s rs c
--   
--   x :&lt; y :&lt; z :&lt; Ø           :: <a>Prod</a> (<a>BVar</a> s rs) '[a, b, c]
--   myOp <a>.$</a> (x :&lt; y :&lt; z :&lt; Ø) :: <a>BVar</a> s rs d
--   </pre>
--   
--   Note that <a>OpB</a> is a superclass of <a>Op</a>, so you can pass in
--   any <a>Op</a> here, as well (like those created by <a>op1</a>,
--   <a>op2</a>, <tt>constOp</tt>, <a>op0</a> etc.)
--   
--   See the documentation for <a>liftB</a> for all the caveats of this
--   usage.
--   
--   <a>.$</a> can also be thought of as a "deferred evaluation" version of
--   <a>~$</a>:
--   
--   <pre>
--   o <a>~$</a> xs = <a>bindVar</a> (o <a>.$</a> xs)
--   </pre>
(.$) :: OpB s as a -> Prod (BVar s rs) as -> BVar s rs a
infixr 1 .$

-- | Convenient wrapper over <a>liftB</a> that takes an <a>OpB</a> with one
--   argument and a single <a>BVar</a> argument. Lets you not have to type
--   out the entire <a>Prod</a>.
--   
--   <pre>
--   <a>liftB1</a> o x = <a>liftB</a> o (x <a>:&lt;</a> 'Ø')
--   
--   myOp :: <a>Op</a> '[a] b
--   x    :: <a>BVar</a> s rs a
--   
--   <a>liftB1</a> myOp x :: <a>BVar</a> s rs b
--   </pre>
--   
--   Note that <a>OpB</a> is a superclass of <a>Op</a>, so you can pass in
--   an <a>Op</a> here (like one made with <a>op1</a>) as well.
--   
--   See the documentation for <a>liftB</a> for caveats and potential
--   problematic situations with this.
liftB1 :: OpB s '[a] b -> BVar s rs a -> BVar s rs b

-- | Convenient wrapper over <a>liftB</a> that takes an <a>OpB</a> with two
--   arguments and two <a>BVar</a> arguments. Lets you not have to type out
--   the entire <a>Prod</a>.
--   
--   <pre>
--   <a>liftB2</a> o x y = <a>liftB</a> o (x <a>:&lt;</a> y <a>:&lt;</a> 'Ø')
--   
--   myOp :: <a>Op</a> '[a, b] c
--   x    :: <a>BVar</a> s rs a
--   y    :: <a>BVar</a> s rs b
--   
--   <a>liftB2</a> myOp x y :: <a>BVar</a> s rs c
--   </pre>
--   
--   Note that <a>OpB</a> is a superclass of <a>Op</a>, so you can pass in
--   an <a>Op</a> here (like one made with <a>op2</a>) as well.
--   
--   See the documentation for <a>liftB</a> for caveats and potential
--   problematic situations with this.
liftB2 :: OpB s '[a, b] c -> BVar s rs a -> BVar s rs b -> BVar s rs c

-- | Convenient wrapper over <a>liftB</a> that takes an <a>OpB</a> with
--   three arguments and three <a>BVar</a> arguments. Lets you not have to
--   type out the entire <a>Prod</a>.
--   
--   <pre>
--   <a>liftB3</a> o x y z = <a>liftB</a> o (x <a>:&lt;</a> y <a>:&lt;</a> z <a>:&lt;</a> 'Ø')
--   
--   myOp :: <a>Op</a> '[a, b, c] d
--   x    :: <a>BVar</a> s rs a
--   y    :: <a>BVar</a> s rs b
--   z    :: <a>BVar</a> s rs c
--   
--   <a>liftB3</a> myOp x y z :: <a>BVar</a> s rs d
--   </pre>
--   
--   Note that <a>OpB</a> is a superclass of <a>Op</a>, so you can pass in
--   an <a>Op</a> here (like one made with <a>op3</a>) as well.
--   
--   See the documentation for <a>liftB</a> for caveats and potential
--   problematic situations with this.
liftB3 :: OpB s '[a, b, c] d -> BVar s rs a -> BVar s rs b -> BVar s rs c -> BVar s rs d

-- | Use an <a>Iso</a> (or compatible <a>Iso</a> from the lens library) to
--   "pull out" the parts of a data type and work with each part as a
--   <a>BVar</a>.
--   
--   If there is an isomorphism between a <tt>b</tt> and a <tt><a>Tuple</a>
--   as</tt> (that is, if an <tt>a</tt> is just a container for a bunch of
--   <tt>as</tt>), then it lets you break out the <tt>as</tt> inside and
--   work with those.
--   
--   <pre>
--   data Foo = F Int Bool
--   
--   fooIso :: <a>Iso'</a> Foo (Tuple '[Int, Bool])
--   fooIso = <a>iso</a> (\(F i b)         -&gt; i ::&lt; b ::&lt; Ø)
--                (\(i ::&lt; b ::&lt; Ø) -&gt; F i b        )
--   
--   <a>partsVar</a> fooIso :: <a>BVar</a> rs Foo -&gt; <a>Prod</a> (<a>BVar</a> s rs) '[Int, Bool]
--   
--   stuff :: <a>BPOp</a> s '[Foo] a
--   stuff (foo :&lt; Ø) =
--       case <a>partsVar</a> fooIso foo of
--         i :<a>:&lt; Ø -</a>
--           -- now, i is a <a>BVar</a> pointing to the <a>Int</a> inside foo
--           -- and b is a <a>BVar</a> pointing to the <a>Bool</a> inside foo
--           -- you can do stuff with the i and b here
--   </pre>
--   
--   You can use this to pass in product types as the environment to a
--   <a>BP</a>, and then break out the type into its constituent products.
--   
--   Note that for a type like <tt>Foo</tt>, <tt>fooIso</tt> can be
--   generated automatically with <a>Generic</a> from <a>GHC.Generics</a>
--   and <a>Generic</a> from <a>Generics.SOP</a> and <i>generics-sop</i>,
--   using the <a>gTuple</a> iso. See <a>gSplit</a> for more information.
--   
--   Also, if you are literally passing a tuple (like <tt><a>BP</a> s
--   '[Tuple '[Int, Bool]</tt>) then you can give in the identity
--   isomorphism (<a>id</a>) or use <a>splitVars</a>.
partsVar :: forall s rs bs a. (Known Length bs, Every Num bs) => Iso' a (Tuple bs) -> BVar s rs a -> Prod (BVar s rs) bs

-- | A continuation-based version of <a>partsVar</a>. Instead of binding
--   the parts and using it in the rest of the block, provide a
--   continuation to handle do stuff with the parts inside.
--   
--   Building on the example from <a>partsVar</a>:
--   
--   <pre>
--   data Foo = F Int Bool
--   
--   fooIso :: <a>Iso'</a> Foo (Tuple '[Int, Bool])
--   fooIso = <a>iso</a> (\(F i b)         -&gt; i ::&lt; b ::&lt; Ø)
--                (\(i ::&lt; b ::&lt; Ø) -&gt; F i b        )
--   
--   stuff :: <a>BPOp</a> s '[Foo] a
--   stuff (foo :&lt; Ø) = <a>withParts</a> fooIso foo $ case
--       i :<a>:&lt; Ø -</a>
--         -- now, i is a <a>BVar</a> pointing to the <a>Int</a> inside foo
--         -- and b is a <a>BVar</a> pointing to the <a>Bool</a> inside foo
--         -- you can do stuff with the i and b here
--   </pre>
--   
--   Mostly just a stylistic alternative to <a>partsVar</a>.
withParts :: forall s rs bs a r. (Known Length bs, Every Num bs) => Iso' a (Tuple bs) -> BVar s rs a -> (Prod (BVar s rs) bs -> r) -> r

-- | Split out a <a>BVar</a> of a tuple into a tuple (<a>Prod</a>) of
--   <a>BVar</a>s.
--   
--   <pre>
--   -- the environment is a single Int-Bool tuple, tup
--   stuff :: <a>BPOp</a> s '[ Tuple '[Int, Bool] ] a
--   stuff (tup :&lt; Ø) =
--     case <tt>splitVar</tt> tup of
--       i :&lt; b :&lt; Ø &lt;- <a>splitVars</a> tup
--       -- now, i is a <a>BVar</a> pointing to the <a>Int</a> inside tup
--       -- and b is a <a>BVar</a> pointing to the <a>Bool</a> inside tup
--       -- you can do stuff with the i and b here
--   </pre>
--   
--   Note that
--   
--   <pre>
--   <a>splitVars</a> = <a>partsVar</a> <a>id</a>
--   </pre>
splitVars :: forall s rs as. (Known Length as, Every Num as) => BVar s rs (Tuple as) -> Prod (BVar s rs) as

-- | Using <a>Generic</a> from <a>GHC.Generics</a> and <a>Generic</a> from
--   <a>Generics.SOP</a>, <i>split</i> a <a>BVar</a> containing a product
--   type into a tuple (<a>Prod</a>) of <a>BVar</a>s pointing to each value
--   inside.
--   
--   Building on the example from <a>partsVar</a>:
--   
--   <pre>
--   import qualified Generics.SOP as SOP
--   
--   data Foo = F Int Bool
--     deriving Generic
--   
--   instance SOP.Generic Foo
--   
--   <a>gSplit</a> :: <a>BVar</a> rs Foo -&gt; <a>Prod</a> (<a>BVar</a> s rs) '[Int, Bool]
--   
--   stuff :: <a>BPOp</a> s '[Foo] a
--   stuff (foo :&lt; Ø) =
--       case <a>gSplit</a> foo of
--         i :<a>:&lt; Ø -</a>
--           -- now, i is a <a>BVar</a> pointing to the <a>Int</a> inside foo
--           -- and b is a <a>BVar</a> pointing to the <a>Bool</a> inside foo
--           -- you can do stuff with the i and b here
--   </pre>
--   
--   Because <tt>Foo</tt> is a straight up product type, <a>gSplit</a> can
--   use <a>GHC.Generics</a> and take out the items inside.
--   
--   Note that
--   
--   <pre>
--   <a>gSplit</a> = <a>splitVars</a> <a>gTuple</a>
--   </pre>
gSplit :: forall s rs as a. (Generic a, Code a ~ '[as], Known Length as, Every Num as) => BVar s rs a -> Prod (BVar s rs) as

-- | An <a>Iso</a> between a type that is a product type, and a tuple that
--   contains all of its components. Uses <a>Generics.SOP</a> and the
--   <a>Generic</a> typeclass.
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Generics.SOP as SOP
--   
--   &gt;&gt;&gt; data Foo = A Int Bool      deriving Generic
--   
--   &gt;&gt;&gt; instance SOP.Generic Foo
--   
--   &gt;&gt;&gt; view gTuple (A 10 True)
--   10 ::&lt; True ::&lt; Ø
--   
--   &gt;&gt;&gt; review gTuple (15 ::&lt; False ::&lt; Ø)
--   A 15 False
--   </pre>
gTuple :: (Generic a, Code a ~ '[as]) => Iso' a (Tuple as)

-- | A version of <a>partsVar</a> taking explicit <a>Summer</a>s and
--   <a>Unity</a>s, so it can be run with internal types that aren't
--   instances of <a>Num</a>.
partsVar' :: forall s rs bs a. Prod Summer bs -> Prod Unity bs -> Iso' a (Tuple bs) -> BVar s rs a -> Prod (BVar s rs) bs

-- | A version of <a>withParts</a> taking explicit <a>Summer</a>s and
--   <a>Unity</a>s, so it can be run with internal types that aren't
--   instances of <a>Num</a>.
withParts' :: forall s rs bs a r. Prod Summer bs -> Prod Unity bs -> Iso' a (Tuple bs) -> BVar s rs a -> (Prod (BVar s rs) bs -> r) -> r

-- | A version of <a>splitVars</a> taking explicit <a>Summer</a>s and
--   <a>Unity</a>s, so it can be run with types that aren't instances of
--   <a>Num</a>.
splitVars' :: forall s rs as. Prod Summer as -> Prod Unity as -> BVar s rs (Tuple as) -> Prod (BVar s rs) as

-- | A version of <a>gSplit</a> taking explicit <a>Summer</a>s and
--   <a>Unity</a>s, so it can be run with internal types that aren't
--   instances of <a>Num</a>.
gSplit' :: forall s rs as a. (Generic a, Code a ~ '[as]) => Prod Summer as -> Prod Unity as -> BVar s rs a -> Prod (BVar s rs) as

-- | Automatically create an <a>Op</a> of a numerical function taking one
--   argument. Uses <a>diff</a>, and so can take any numerical function
--   polymorphic over the standard numeric types.
--   
--   <pre>
--   &gt;&gt;&gt; gradOp' (op1 (recip . negate)) (5 ::&lt; Ø)
--   (-0.2, 0.04 ::&lt; Ø)
--   </pre>
op1 :: Num a => (forall s. AD s (Forward a) -> AD s (Forward a)) -> Op '[a] a

-- | Automatically create an <a>Op</a> of a numerical function taking two
--   arguments. Uses <a>grad</a>, and so can take any numerical function
--   polymorphic over the standard numeric types.
--   
--   <pre>
--   &gt;&gt;&gt; gradOp' (op2 (\x y -&gt; x * sqrt y)) (3 ::&lt; 4 ::&lt; Ø)
--   (6.0, 2.0 ::&lt; 0.75 ::&lt; Ø)
--   </pre>
op2 :: Num a => (forall s. Reifies s Tape => Reverse s a -> Reverse s a -> Reverse s a) -> Op '[a, a] a

-- | Automatically create an <a>Op</a> of a numerical function taking three
--   arguments. Uses <a>grad</a>, and so can take any numerical function
--   polymorphic over the standard numeric types.
--   
--   <pre>
--   &gt;&gt;&gt; gradOp' (op3 (\x y z -&gt; (x * sqrt y)**z)) (3 ::&lt; 4 ::&lt; 2 ::&lt; Ø)
--   (36.0, 24.0 ::&lt; 9.0 ::&lt; 64.503 ::&lt; Ø)
--   </pre>
op3 :: Num a => (forall s. Reifies s Tape => Reverse s a -> Reverse s a -> Reverse s a -> Reverse s a) -> Op '[a, a, a] a

-- | Automatically create an <a>Op</a> of a numerical function taking
--   multiple arguments. Uses <a>grad</a>, and so can take any numerical
--   function polymorphic over the standard numeric types.
--   
--   <pre>
--   &gt;&gt;&gt; gradOp' (opN (\(x :+ y :+ Ø) -&gt; x * sqrt y)) (3 ::&lt; 4 ::&lt; Ø)
--   (6.0, 2.0 ::&lt; 0.75 ::&lt; Ø)
--   </pre>
opN :: (Num a, Known Nat n) => (forall s. Reifies s Tape => Vec n (Reverse s a) -> Reverse s a) -> Op (Replicate n a) a

-- | Create an <a>Op</a> of a function taking one input, by giving its
--   explicit derivative. The function should return a tuple containing the
--   result of the function, and also a function taking the derivative of
--   the result and return the derivative of the input.
--   
--   If we have
--   
--   &lt;math&gt;
--   
--   Then the derivative &lt;math&gt;, it would be:
--   
--   &lt;math&gt;
--   
--   If our <a>Op</a> represents &lt;math&gt;, then the second item in the
--   resulting tuple should be a function that takes &lt;math&gt; and
--   returns &lt;math&gt;.
--   
--   If the input is <a>Nothing</a>, then &lt;math&gt; should be taken to
--   be &lt;math&gt;.
--   
--   As an example, here is an <a>Op</a> that squares its input:
--   
--   <pre>
--   square :: Num a =&gt; <a>Op</a> '[a] a
--   square = <a>op1'</a> $ \x -&gt; (x*x, \case Nothing -&gt; 2 * x
--                                     Just d  -&gt; 2 * d * x
--                         )
--   </pre>
--   
--   Remember that, generally, end users shouldn't directly construct
--   <a>Op</a>s; they should be provided by libraries or generated
--   automatically.
--   
--   For numeric functions, single-input <a>Op</a>s can be generated
--   automatically using <a>op1</a>.
op1' :: (a -> (b, Maybe b -> a)) -> Op '[a] b

-- | Create an <a>Op</a> of a function taking two inputs, by giving its
--   explicit gradient. The function should return a tuple containing the
--   result of the function, and also a function taking the derivative of
--   the result and return the derivative of the input.
--   
--   If we have
--   
--   &lt;math&gt;
--   
--   Then the gradient &lt;math&gt; would be:
--   
--   &lt;math&gt;
--   
--   If our <a>Op</a> represents &lt;math&gt;, then the second item in the
--   resulting tuple should be a function that takes &lt;math&gt; and
--   returns &lt;math&gt;.
--   
--   If the input is <a>Nothing</a>, then &lt;math&gt; should be taken to
--   be &lt;math&gt;.
--   
--   As an example, here is an <a>Op</a> that multiplies its inputs:
--   
--   <pre>
--   mul :: Num a =&gt; <a>Op</a> '[a, a] a
--   mul = <a>op2'</a> $ \x y -&gt; (x*y, \case Nothing -&gt; (y  , x  )
--                                    Just d  -&gt; (d*y, x*d)
--                        )
--   </pre>
--   
--   Remember that, generally, end users shouldn't directly construct
--   <a>Op</a>s; they should be provided by libraries or generated
--   automatically.
--   
--   For numeric functions, two-input <a>Op</a>s can be generated
--   automatically using <a>op2</a>.
op2' :: (a -> b -> (c, Maybe c -> (a, b))) -> Op '[a, b] c

-- | Create an <a>Op</a> of a function taking three inputs, by giving its
--   explicit gradient. See documentation for <a>op2'</a> for more details.
op3' :: (a -> b -> c -> (d, Maybe d -> (a, b, c))) -> Op '[a, b, c] d

-- | Construct a two element Prod. Since the precedence of (:&gt;) is
--   higher than (:&lt;), we can conveniently write lists like:
--   
--   <pre>
--   &gt;&gt;&gt; a :&lt; b :&gt; c
--   </pre>
--   
--   Which is identical to:
--   
--   <pre>
--   &gt;&gt;&gt; a :&lt; b :&lt; c :&lt; Ø
--   </pre>
infix 6 :>

-- | Build a singleton Prod.
only :: f a -> Prod k f ((:) k a ([] k))
head' :: Prod k f ((:<) k a as) -> f a

-- | Cons onto a Tuple.
infixr 5 ::<

-- | Singleton Tuple.
only_ :: a -> Tuple ((:) * a ([] *))

-- | Instructions on how to "sum" a list of values of a given type.
--   Basically used as an explicit witness for a <a>Num</a> instance.
--   
--   For most types, the only meaningful value of type <tt><a>Summer</a>
--   a</tt> is <tt><a>Summer</a> <a>sum</a></tt>. However, using
--   <a>Summer</a> lets us use <tt>BP</tt> with types that are <i>not</i>
--   instances of <a>Num</a>. Any type can be used, as long as you provide
--   a way to "sum" it!
--   
--   For most of the functions in this library, you can completely ignore
--   this, as they will be generated automatically. You only need to work
--   with this directly if you want to use custom types that <i>aren't</i>
--   instances of <a>Num</a> with this library.
--   
--   If 'Num a' is satisfied, one can create the canonical <a>Summer</a>
--   using <tt><a>known</a> :: <a>Num</a> a =&gt; <a>Summer</a> a</tt>.
newtype Summer a
Summer :: ([a] -> a) -> Summer a
[runSummer] :: Summer a -> [a] -> a

-- | A canonical "unity" (the multiplicative identity) for a given type.
--   Basically used as an explicit witness for a <a>Num</a> instance.
--   
--   For most types, the only meaningful value of type <tt><a>Unity</a>
--   a</tt> is <tt><a>Unity</a> 1'</tt>. However, using <a>Unity</a> lets
--   us use <tt>BP</tt> with types that are <i>not</i> instances of
--   <a>Num</a>. Any type can be used, as long as you provide a way to get
--   a multiplicative identity in it!
--   
--   For most of the functions in this library, you can completely ignore
--   this, as they will be generated automatically. You only need to work
--   with this directly if you want to use custom types that <i>aren't</i>
--   instances of <a>Num</a> with this library.
--   
--   If 'Num a' is satisfied, one can create the canonical <a>Unity</a>
--   using <tt><a>known</a> :: <a>Num</a> a =&gt; <a>Unity</a> a</tt>.
newtype Unity a
Unity :: a -> Unity a
[getUnity] :: Unity a -> a

-- | If all the types in <tt>as</tt> are instances of <a>Num</a>, generate
--   a <tt><a>Prod</a> <a>Summer</a> as</tt>, or a tuple of <a>Summer</a>s
--   for every type in <tt>as</tt>.
summers :: (Every Num as, Known Length as) => Prod Summer as

-- | If all the types in <tt>as</tt> are instances of <a>Num</a>, generate
--   a <tt><a>Prod</a> <a>Unity</a> as</tt>, or a tuple of <a>Unity</a>s
--   for every type in <tt>as</tt>.
unities :: (Every Num as, Known Length as) => Prod Unity as

-- | Like <a>summers</a>, but requiring an explicit witness for the number
--   of types in the list <tt>as</tt>.
summers' :: Every Num as => Length as -> Prod Summer as

-- | Like <a>unities</a>, but requiring an explicit witness for the number
--   of types in the list <tt>as</tt>.
unities' :: Every Num as => Length as -> Prod Unity as


-- | Provides monomorphic versions of the types and combinators in
--   <a>Numeric.Backprop.Op</a>, for usage with
--   <a>Numeric.Backprop.Mono</a> and
--   <a>Numeric.Backprop.Mono.Implicit</a>.
--   
--   Note that <a>Op</a> is a <i>subset</i> or <i>subtype</i> of
--   <a>OpM</a>, and so, any function that expects an <tt><a>OpM</a> m as
--   a</tt> (or an <tt><a>OpB</a> s as a</tt>) can be given an
--   <tt><a>Op</a> as a</tt> and it'll work just fine.
module Numeric.Backprop.Op.Mono
type Op n a b = Op (Replicate n a) b
type OpM m n a = OpM m (Replicate n a)
data VecT k (n :: N) (f :: k -> *) (a :: k) :: forall k. N -> (k -> *) -> k -> *
[ØV] :: VecT k Z f a
[:*] :: VecT k (S n1) f a
type Vec (n :: N) = VecT * n I
runOp' :: Op n a b -> Vec n a -> (b, Maybe b -> Vec n a)
runOp :: Op n a b -> Vec n a -> b
gradOp :: Op n a b -> Vec n a -> Vec n a
gradOpWith :: Op n a b -> Vec n a -> b -> Vec n a
gradOpWith' :: Op n a b -> Vec n a -> Maybe b -> Vec n a
op1 :: Num a => (forall s. AD s (Forward a) -> AD s (Forward a)) -> Op N1 a a
op2 :: Num a => (forall s. Reifies s Tape => Reverse s a -> Reverse s a -> Reverse s a) -> Op N2 a a
op3 :: Num a => (forall s. Reifies s Tape => Reverse s a -> Reverse s a -> Reverse s a -> Reverse s a) -> Op N3 a a
opN :: (Num a, Known Nat n) => (forall s. Reifies s Tape => Vec n (Reverse s a) -> Reverse s a) -> Op n a a
infixr 4 :+
(*:) :: f a -> f a -> VecT k (S (S Z)) f a
infix 5 *:
(+:) :: a -> a -> Vec (S (S Z)) a
infix 5 +:
head' :: VecT k (S n) f a -> f a

-- | Convenient aliases for low-value Peano numbers.
type N0 = Z
type N1 = S N0
type N2 = S N1
type N3 = S N2
type N4 = S N3
type N5 = S N4
type N6 = S N5
type N7 = S N6
type N8 = S N7
type N9 = S N8
type N10 = S N9

module Numeric.Backprop.Mono
type BP s n a = BP s (Replicate n a)
type BPOp s n a b = BP s n a (BVar s n a b)
type BVar s n a = BVar s (Replicate n a)
type Op n a b = Op (Replicate n a) b
backprop :: forall n a b. Num a => (forall s. BPOp s n a b) -> Vec n a -> (b, Vec n a)
evalBPOp :: forall n a b. (forall s. BPOp s n a b) -> Vec n a -> b
gradBPOp :: forall n a b. Num a => (forall s. BPOp s n a b) -> Vec n a -> Vec n a
bpOp :: forall s n a b. (Num a, Known Nat n) => BPOp s n a b -> OpB s n a b
withInps :: Known Nat n => (VecT n (BVar s n a) a -> BP s n a b) -> BP s n a b
implicitly :: Known Nat n => BPOpI s n a b -> BPOp s n a b
constVar :: b -> BVar s n a b
inpVar :: Fin n -> BVar s n a a
inpVars :: Known Nat n => VecT n (BVar s n a) a
opVar :: forall s m n a b. Num b => OpB s m a b -> VecT m (BVar s n a) a -> BP s n a (BVar s n a b)
(~$) :: Num b => OpB s m a b -> VecT m (BVar s n a) a -> BP s n a (BVar s n a b)
infixr 1 ~$
opVar1 :: forall s n a b. Num b => OpB s N1 a b -> BVar s n a a -> BP s n a (BVar s n a b)
opVar2 :: forall s n a b. Num b => OpB s N2 a b -> BVar s n a a -> BVar s n a a -> BP s n a (BVar s n a b)
opVar3 :: forall s n a b. Num b => OpB s N3 a b -> BVar s n a a -> BVar s n a a -> BVar s n a a -> BP s n a (BVar s n a b)
(-$) :: forall s m n a b. (Num a, Num b, Known Nat m) => BPOp s m a b -> VecT m (BVar s n a) a -> BP s n a (BVar s n a b)
infixr 1 -$
liftB :: forall s m n a b r. OpB s m a b -> VecT m (BVar s n r) a -> BVar s n r b
(.$) :: forall s m n a b r. OpB s m a b -> VecT m (BVar s n r) a -> BVar s n r b
liftB1 :: OpB s N1 a a -> BVar s n r a -> BVar s n r a
liftB2 :: OpB s N2 a a -> BVar s n r a -> BVar s n r a -> BVar s n r a
liftB3 :: OpB s N3 a a -> BVar s n r a -> BVar s n r a -> BVar s n r a -> BVar s n r a
op1 :: Num a => (forall s. AD s (Forward a) -> AD s (Forward a)) -> Op N1 a a
op2 :: Num a => (forall s. Reifies s Tape => Reverse s a -> Reverse s a -> Reverse s a) -> Op N2 a a
op3 :: Num a => (forall s. Reifies s Tape => Reverse s a -> Reverse s a -> Reverse s a -> Reverse s a) -> Op N3 a a
opN :: (Num a, Known Nat n) => (forall s. Reifies s Tape => Vec n (Reverse s a) -> Reverse s a) -> Op n a a

-- | Convenient aliases for low-value Peano numbers.
type N0 = Z
type N1 = S N0
type N2 = S N1
type N3 = S N2
type N4 = S N3
type N5 = S N4
type N6 = S N5
type N7 = S N6
type N8 = S N7
type N9 = S N8
type N10 = S N9
data VecT k (n :: N) (f :: k -> *) (a :: k) :: forall k. N -> (k -> *) -> k -> *
[ØV] :: VecT k Z f a
[:*] :: VecT k (S n1) f a
type Vec (n :: N) = VecT * n I
infixr 4 :+
(*:) :: f a -> f a -> VecT k (S (S Z)) f a
infix 5 *:
(+:) :: a -> a -> Vec (S (S Z)) a
infix 5 +:
head' :: VecT k (S n) f a -> f a

module Numeric.Backprop.Mono.Implicit
type BVar s n a = BVar s (Replicate n a)
type BPOp n a b = forall s. VecT n (BVar s n a) a -> BVar s n a b
type Op n a b = Op (Replicate n a) b
backprop :: forall n a b. (Num a, Known Nat n) => BPOp n a b -> Vec n a -> (b, Vec n a)
grad :: forall n a b. (Num a, Known Nat n) => BPOp n a b -> Vec n a -> Vec n a
eval :: forall n a b. (Num a, Known Nat n) => BPOp n a b -> Vec n a -> b
constVar :: b -> BVar s n a b
liftB :: forall s m n a b r. OpB s m a b -> VecT m (BVar s n r) a -> BVar s n r b
(.$) :: forall s m n a b r. OpB s m a b -> VecT m (BVar s n r) a -> BVar s n r b
liftB1 :: OpB s N1 a a -> BVar s n r a -> BVar s n r a
liftB2 :: OpB s N2 a a -> BVar s n r a -> BVar s n r a -> BVar s n r a
liftB3 :: OpB s N3 a a -> BVar s n r a -> BVar s n r a -> BVar s n r a -> BVar s n r a
op1 :: Num a => (forall s. AD s (Forward a) -> AD s (Forward a)) -> Op N1 a a
op2 :: Num a => (forall s. Reifies s Tape => Reverse s a -> Reverse s a -> Reverse s a) -> Op N2 a a
op3 :: Num a => (forall s. Reifies s Tape => Reverse s a -> Reverse s a -> Reverse s a -> Reverse s a) -> Op N3 a a
opN :: (Num a, Known Nat n) => (forall s. Reifies s Tape => Vec n (Reverse s a) -> Reverse s a) -> Op n a a

-- | Convenient aliases for low-value Peano numbers.
type N0 = Z
type N1 = S N0
type N2 = S N1
type N3 = S N2
type N4 = S N3
type N5 = S N4
type N6 = S N5
type N7 = S N6
type N8 = S N7
type N9 = S N8
type N10 = S N9
data VecT k (n :: N) (f :: k -> *) (a :: k) :: forall k. N -> (k -> *) -> k -> *
[ØV] :: VecT k Z f a
[:*] :: VecT k (S n1) f a
type Vec (n :: N) = VecT * n I
infixr 4 :+
(*:) :: f a -> f a -> VecT k (S (S Z)) f a
infix 5 *:
(+:) :: a -> a -> Vec (S (S Z)) a
infix 5 +:
head' :: VecT k (S n) f a -> f a
